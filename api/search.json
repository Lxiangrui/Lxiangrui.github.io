[{"id":"a22b5a6b2aea63003d83f444c152a314","title":"pid学习","content":"pid学习PID 实指“比例 proportional”、“积分 integral”、“微分 derivative”\n理解位置式pid和增量式pid：为什么有位置式pid和增量式pid？数字 PID 控制算法因时间离散化不同，通常分为位置式 PID 控制算法和增量式 PID 控制算法。\n[(81条消息) 位置式与增量式PID_苏守坤的博客-CSDN博客_pid位置式和增量式]:\n位置式:位置式是我一直理解的那种比较简单的pid\n\n串级核心理念：（参考逐飞！！！）串级pid的核心理念，用除最内环外的其他所有环，来纠正最内环\n\n\n角速度环控制：仅对陀螺仪采集到的角速度进行闭环控制，因此得到的效果也仅仅在小车晃动时（即有角速度的时候），动量轮才有一些阻力感即可，并不能平衡\n速度环控制：根据小车倾斜的角度闭环输出，单独控制角度环时，直接输出到电机，得到的效果与角速度环差不多\n速度环控制：对电机的转速进行闭环控制，速度环应该为正反馈，当电机旋转时，跳过速度环，应该转的更快。\n\n\nPWM_accel = - Velocity_Control(X_balance_Control(X_balancetwo_Control(ECPULSE1)));\n\n\n/**************************************************************************\n内环------角速度环------增量式PI控制\n**************************************************************************/\nfloat Velocity_Control(float Re_Gyro)//  参数：速度环反馈（速度环输出反馈）\n&#123;   static int flag=0;\t\t\t\t//可以使形参的生命周期和main函数一样\n    static float PWM_Plus_P;\n    float Bias,PWM_F;\n    float Gyro;\n    static float New_error,Old_error;\n    Gyro=gyro[0];\n    New_error=Gyro+Re_Gyro-0;\n    Bias=New_error-Old_error;\n    PWM_Plus_P += X_Velocity_KP*Bias;\n    PWM_Plus_I += X_Velocity_KI*New_error;\n    PWM_F= PWM_Plus_P + PWM_Plus_I;\n    Old_error=New_error;\n    return PWM_F;\n&#125;\n\n/**************************************************************************\n中环------角度环\n**************************************************************************/\nfloat X_balance_Control(float Angle)  //参数：速度环反馈值（速度环输出反馈）\n&#123;\n     float Error;\n     Error=Pitch-Angle-Pitch_Zero;        //注意这里可能是他极性是-\n\n\n     PWM_S=X_Balance_KP*Error + gyro[0]*X_Balance_KD;\n     return PWM_S;\n&#125;\n\n/**************************************************************************\n外环------速度环\n**************************************************************************/\nfloat X_balancetwo_Control(float Enc)  //参数：编码器反馈\n&#123;\n     PWM_T =X_Speed_KP*Enc/100;\n     return PWM_T;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\nTi大佬的提示：Ti大佬是我在b站认识的一个大佬，他在群里面分享了这两句话，说是很关键，所以我将它们贴到这里防止我把它们弄丢了，哈哈哈\n\n\n\n\n\n\n\n\n","slug":"pid学习","date":"2022-04-12T15:46:49.000Z","categories_index":"控制原理","tags_index":"知识学习","author_index":"祥瑞"},{"id":"cea6e522f75ce7dc72f7d48196283264","title":"自动打卡.py","content":"屁话：这是一个超级简单的脚本，是我第一次用python实现的一个小功能吧。\n一开始的目标就是做一个能自动打卡的脚本，但是在做的过程中，发现如果要做到很好，还是很困难的。\n现在脚本的功能就是：每天自动在7：00打卡（通过bat执行）\n采样python的webdriver来控制浏览器打开网页，用pyautogui来控制鼠标键盘\n还是有很多可以完善的地方的：1、比如因为我在使用webdriver时，不能寻找到新的页面的元素，这导致我用了pyautogui来操纵鼠标控制，而使用这种方式后就以为着不能直接在其他电脑上执行，当然，解决办法，还是有的，pyautogui也是有查找元素的功能的，但是它是通过图片的方式，相较于webdriver，它只能查找显示到屏幕的内容，但也是一种选择。\n2、我们学校的打卡网页，必须在移动端打开才能打卡，所以使用webdriver的时候需要先把它模拟为移动端的浏览器，也是通过pyautogui控制键盘打开，就很拉。\n3、在打卡的时候，需要获取实时地址，实际测试下，chrom获取的位置根本不行，后来发现edge还行，这也导致了我不能将它部署在服务器上，需要一种将我的电脑打开，就很蠢。如果可以了解更深里面的，比如网页时如何获取实时地址的话，那应该可以解决，但是对于现在的我，这样就行了。\nMORE:我听说我的一个学长，他直接也做了一个自动打卡的，他是全栈加硬件，我可以去问一些他是怎么实现的哈。我能想到的就是，大家经常说的抓包啥的了。\n程序源码：from ast import Pass\nfrom selenium.webdriver.common.by import By\n#from selenium.webdriver import edge\nfrom selenium import webdriver\n#from selenium.webdriver.edge.options import Options\nimport pyautogui\nimport time\n \nwidth,height = pyautogui.size()\nprint(width,height)  # 1920 1080\n\nprint(pyautogui.position())   # 得到当前鼠标位置；输出：Point(x=200, y=800)\n\n# pyautogui.moveTo(179,503,duration=1)   # 第一个参数是左右移动像素值，第二个是上下，\n\n\n \nwd = webdriver.Edge(r'd:\\MicroftWebDriver.exe')\n# wd =   webdriver.Chrome(r'd:\\chromedriver.exe')\ntime.sleep(0.5)\n\n\nwd.get('https://wb.scujj.edu.cn/relax/mobile/index.html#/common/office/login')\n \ntime.sleep(0.5)\npyautogui.click(208,520,button='left')  \n\ntime.sleep(0.5)\n\n#快捷键设置 模拟手机请求\npyautogui.press('f12')\npyautogui.press('left')\npyautogui.press('enter')\ntime.sleep(0.5)\npyautogui.keyDown('ctrl')\npyautogui.keyDown('shift')\ntime.sleep(0.5)\npyautogui.press('m')\ntime.sleep(0.5)\npyautogui.keyUp('ctrl')\npyautogui.keyUp('shift')\n\n\n\ntime.sleep(5)\n\nusar_num = wd.find_elements(By.CLASS_NAME, \"weui-input\")\n\n\n#输入账号和密码\nusar_num[0].send_keys(\"1906100147\")          \nusar_num[1].send_keys(\"1906100147\")\n\n# wd.find_element(By.CLASS_NAME,'weui_btn_primary').click()\ntime.sleep(2)\npyautogui.click(208,520,button='left')  \n\ntime.sleep(2)\n\npyautogui.click(179,503,button='left')  \ntime.sleep(4)\n\n\npyautogui.click(318,597,button='left')  # 健康\ntime.sleep(0.5)\npyautogui.click(214,602,button='left') \ntime.sleep(0.5)\n\n\npyautogui.click(190,642,button='left')  # 是否发热\ntime.sleep(0.5)\npyautogui.click(202,656,button='left')  \ntime.sleep(0.5)\n\npyautogui.click(196,699,button='left')  # 其他症状\ntime.sleep(0.5)\npyautogui.click(196,418,button='left')  \ntime.sleep(0.5)\npyautogui.click(337,319,button='left') \ntime.sleep(0.5)\n\n\npyautogui.click(242,900,button='left')  # 地区风险等级\ntime.sleep(0.5)\npyautogui.click(210,704,button='left') \ntime.sleep(0.5)\npyautogui.click(200,984,button='left')  #   提交\ntime.sleep(5)\nprint(\"打卡完成！！！当前鼠标位置:\",pyautogui.position())   # 得到当前鼠标位置；输出：Point(x=200, y=800)\n\n","slug":"自动打卡-py","date":"2022-02-08T18:04:50.000Z","categories_index":"图一乐","tags_index":"python","author_index":"祥瑞"},{"id":"e81953d080c3cdbe02749919d9ab3a38","title":"X-bot","content":"X-bot前言这个项目是我在稚辉君的视频里面看见的，是一个完全开源的项目，而且对他来说是一个比较简单的项目，但对于我这种没有什么DIY经验的同学来说，还是有点难的，不过可能我运气比较好吧，在他的视频评论区下面找到了一个大佬，他帮助了我很多,最后好像玩着玩着断断续续一直弄了1个多月才做好。\n展示环节！ \n\n关于机械臂这个项目里面的机械结构叫做 CoreXY结构CoreXY（主要是并联运动）意味着电机（通常是DIY级平台上最大的惯性源）是固定的。这允许快速加速。(但是我的好像不是很快可能还要调试一下)CoreXY它的原理是通过两个电机同时控制XY的移动，左右两个电机同向的时候，往X轴移动，两个电机反向的时候往Y轴移动。；两个电机的同时作用，力量比单个电机控制一轴来得要稳定，还能减少了XY平台上面一个电机的重量。接下来的衍生的结构也是一样的原理。\n关于控制方式这个项目采用的是GRBLGRBL是国外大牛编写的一套arduino单片机的G代码编译和运动控制的开源程序，而在这个项目里，稚辉君将GRBL移植到了STM32平台，可能当时在15年左右stm32比较便宜吧，性价比较高，而在现在2021的现在stm32的价格是以前的几倍不止/(ㄒoㄒ)/~~，话说回来，Grbl经常被用于DIY制作小型CNC调刻机或者写字机。\n不同之处硬件方面因为对于稚辉君还是追求极致性能不考虑成本的~，咱们还是得考虑成本的，所以一些地方做出了改变，其中有步进电机的驱动电路是用的A4988,也是DIY项目常用的驱动模块。然后因为现在的我也没有稚辉君那样的技术力,开始我也是采用的网上PCB打板后，然后在tb购买元器件，焊接完后，就是一直点亮不了  /(ㄒoㄒ)/~~，也检查了很久，最后就放弃了这个方案，换成了洞洞板。报废的板子我 &gt;:(我采用的是洞洞板焊接电路，同时安装了stm32103c8t6对应的排母，便于拆卸。然后与上位机的连接方式我这里用了3种1、直接使用ch340串口连接电脑和写字机；2、使用无线串口连接；3、使用蓝牙模块hc_06，作为串口连接。\n软件上位机我使用的上位机是评论区大佬分享给我的，是奎享免费版，比较低的版本，可能网上下载不到了，如果有人要的话，可以联系我。\n总结这次的项目其实我的工作并不是很多，大多数代码，硬件，机械结构都是稚辉君开源的，可我应该还是学到一些东西的。比如了解了GRBL这种控制方式，步进电机的使用，熟悉了蓝牙模块的使用，上位机的强大功能。但这个项目有些地方我还是没有搞清楚，比如稚辉君是如何将GRBL从arduino移植到stm32的，这是个问题更多来源于我的技术不够，需要继续学习了解，还有稚辉君使用的上位机应该是他自己编写的，能够很好的适配。所以，我准备还是得继续学习stm32这个平台，之前只是看了我们学校日常课程的内容，看来必须得继续学啊！同时计划学习c#编写上位机程序，那样以后也可以用unity，岂不美滋滋！！O(∩_∩)O所以这就是这期博客的全部内容了。\n希望和大家一起玩耍，能看到这里的都是人才啊🤣😂🤣😂，当然应该不太可能有人会看到这里哈，因为这个项目对于入行的大佬们确实实在是太简单了，而对于现在的我来说正好，所以其实我这里更多的是给自己的一个总结吧。\n","slug":"X-bot","date":"2021-10-23T13:41:29.000Z","categories_index":"DIY","tags_index":"写字机器人","author_index":"祥瑞"},{"id":"a66f27aecf2233b9864ca3ce3962950b","title":"硬件控制-arm-linux","content":"环境搭建实现链路\n嵌入式交叉编译开发环境\nuart串口调试 jtag口 //隐藏在金手指核心板的背部，未引出到扩展板的管脚上，不好调试\nuart调试口 //在SD卡底部，横着一排(2G板子时在摄像头 排线的旁边)           \n​                 //GND: usb转串口的黑线接板子的  TXD: 接白线  RXD: 接绿线 红线(电源):不接  打开win10设备管理器，查看有COM口吗 \n​                //没有或异常，需安装驱动PL2303_Prolific_GPS_1013_20090319.exe                \n​                //驱动报错：pl2303hxa自2012已停产,请联系供货商             \n​              //下载老的驱动，更新驱动时 选老版本驱动即可,或卸载重装\n我用软件是  PUTTY.EXE\n1、将串口和咱们的linux板卡连接上，我使用的win10的系统，所以不要安装串口驱动，如果不能用的化重新装一下驱动就好了，如果识别到可以查看串口设备是否被识别到。\n\n2、打开 PUTTY.EXE，\n\n3、打开\n\nuboot的tftp下载uboot的tftp下载 -&gt; 裸机调试(因jtag仿真用不了 uboot本身是裸机程序\n主机安装TFTP服务$ sudo apt-get install xinetd tftpd tftp\t\n$ sudo vim &#x2F;etc&#x2F;xinetd.d&#x2F;tftp &#x2F;*添加下面内容, \nservice tftp\n&#123;\nprotocol        &#x3D; udp\nport            &#x3D; 69\nsocket_type     &#x3D; dgram\nwait            &#x3D; yes\nuser            &#x3D; nobody\nserver          &#x3D; &#x2F;usr&#x2F;sbin&#x2F;in.tftpd\nserver_args     &#x3D; &#x2F;tftpboot\ndisable         &#x3D; no\n&#125;\n \n注意： win10下内容拷贝不过来 需要去掉.vimrc &quot; 启用鼠标 部分内容如 if has(&#39;mouse&#39;) set mouse&#x3D;a endif\n\n *&#x2F;\n\n$ sudo mkdir &#x2F;tftpboot\n$ sudo chmod -R 777 &#x2F;tftpboot\n$ sudo chown -R nobody &#x2F;tftpboot \n$ vim &#x2F;tfpboot&#x2F;test &#x2F;&#x2F;创建测试文件\n$ sudo service xinetd restart  &#x2F;&#x2F;新系统的重启服务\n$ sudo &#x2F;etc&#x2F;init.d&#x2F;xinetd restart  \t&#x2F;&#x2F;老系统的重启服务\n\n$ tftp localhost  &#x2F;&#x2F;自环测试\ntftp&gt; get  test\nReceived 7 bytes in 0.0 seconds  &#x2F;&#x2F;有下载到文件，表示tftp服务安装成功\ntftp&gt; q &#x2F;&#x2F;退出\n\n\n\n板子与虚拟机能ping通用网线连接板子和电脑  &#x2F;&#x2F;需买网线，笔记本电脑还需买 usb转网卡 设备\n\n&#x2F;&#x2F;win10设置：\n  右下脚无线网图标上右键 -&gt; 打开网络和internet设置 -&gt; 以太网 -&gt; 网络和共享中心\n  -&gt; 点以太网（有线网卡） -&gt; 属性 -&gt; TCP&#x2F;ipv4-&gt; 选使用下面的ip地址\n  -&gt; IP地址    192.168.9.120   -&gt; 确定\n     子网掩码  255.255.255.0\n     网关      192.168.9.1\n \n  关闭防火墙 &#x2F;&#x2F; 右下角向上箭头 -&gt; 点盾牌的图标 -&gt; 把域网络 专有网络 公有网络 防火墙全部关闭（否则是ping不通的）\n命令行输入  &gt; ipconfig      &#x2F;&#x2F;能看到以太网适配器里右ip  192.168.9.120表示设置成功\n&#x2F;&#x2F;板子设置：\t\n$ sudo ifconfig eth0 192.168.9.110 up  &#x2F;&#x2F;设置有限网卡的ip地址(默认eth0是有些网卡)\n$ ifconifg   &#x2F;&#x2F;看到 eth0 设为 192.168.9.110 表示设置成功\n$ ping 192.168.9.120 &#x2F;*如果有回下面信息表示板子与电脑网络连接成功\n    PING 192.168.9.120 (192.168.9.120) 56(84) bytes of data.\n    64 bytes from 192.168.9.120: icmp_seq&#x3D;1 ttl&#x3D;128 time&#x3D;1.67 ms\n    64 bytes from 192.168.9.120: icmp_seq&#x3D;2 ttl&#x3D;128 time&#x3D;1.90 ms\n   \t*&#x2F;\n\n主机关联有线网卡设定静态ip\nWorkStation -&gt; 编辑 -&gt; 虚拟网络编辑器 -&gt; 更改设置 -&gt; 桥接模式 -&gt; 选usb有线网卡 -&gt; 确定退出\nWorkStation -&gt; 虚拟机 -&gt; 设置 -&gt; 自定义 -&gt; 选Vnet0 &#x2F;&#x2F;需和前一个一致\nubuntu -&gt; 右键右上角的网络图标 -&gt; 设置 -&gt; 点+ 号新加网卡 -&gt; 身份 名称设为 board -&gt; \n选ipv4 -&gt; 手动 -&gt; 地址 设为192.168.9.119  子网掩码 255.255.255.255.0  网关：192.168.9.1 -&gt; 确定退出\n$ ifconfig &#x2F;&#x2F;如果看到有 192.168.9.119 的网卡，表示设置成功\n\nTFTP下载文件到板子上# pci enum;pci  &#x2F;* 激活pci设备(否则ping时报：No ethernet found.)\nScanning PCI devices on bus 0\nBusDevFun  VendorId   DeviceId   Device Class       Sub-Class\n_____________________________________________________________\n00.01.00   0x10de     0x0fae     Bridge device           0x04\n00.02.00   0x10de     0x0faf     Bridge device           0x04\t\n  *&#x2F;\t\n# setenv serverip  192.168.9.119 \n# setenv ipaddr 192.168.9.9\n# ping 192.168.9.120 &#x2F;*先ping通win10\n  Using eth_rtl8169 device\n  host 192.168.9.120 is alive\n\t*&#x2F;\n# ping  192.168.9.119   &#x2F;*再ping通虚拟机(如果不通，看一下前面 主机关联有线网卡设定静态ip）\n   Using eth_rtl8169 device\n   host 192.168.9.119 is alive\n    *&#x2F;\n# saveeenv\n# tftp Image  &#x2F;*内核33M下载要3分钟（太慢了，为什么）\n\tUsing eth_rtl8169 device\n\tTFTP from server 192.168.9.119; our IP address is 192.168.9.9\n\tFilename &#39;Image&#39;.\n\tLoad address: 0x84000000\n\tLoading: ##########....\n\n         ####################################################\n         308.6 KiB&#x2F;s\n\tdone\n\tBytes transferred &#x3D; 34484232 (20e3008 hex)\n\t\n\t占用地址范围  0x84000000 ~ 0x84000000+20e3008\n   *&#x2F;\t\n# tftp 0x88000000 tegra210-p3448-0002-p3449-0000-b00.dtb   \n\n交叉编译工具安装$ cp &#x2F;mnt&#x2F;hgfs&#x2F;share&#x2F;gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu.tar.xz  . &#x2F;&#x2F;从与win10的共享目录拷贝过来(不要采用拖拉到虚拟机中方式，文件太大了会不完整)\n$ tar -xvf \tgcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu.tar.xz\n$ cd gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu&#x2F;bin&#x2F;\n$ pwd &#x2F;&#x2F;如  &#x2F;home&#x2F;yhai&#x2F;store&#x2F;gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu&#x2F;bin\n$ export PATH&#x3D;&#x2F;home&#x2F;yhai&#x2F;store&#x2F;gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu&#x2F;bin:$PATH &#x2F;&#x2F; 注：export 路径要和你自己的pwd 一致\n$ export &#x2F;&#x2F;查看环境变量，可成功看到PATH变化 ，系统会通过它来找到aarch64-linux-gcc\t\t\t\n$ aar 后按tab键能补全为aarch64-linux-gnu- 表示成功\n      &#x2F;&#x2F;但export只是才当前有效，重开新终端，或重启就消失了，需重设，故可把它添加到启动脚本里，让它自动生效。\n$ vim ~&#x2F;.bashrc &#x2F;&#x2F;在其末尾添加export PATH&#x3D;&#x2F;home&#x2F;yhai&#x2F;store&#x2F;gcc-linaro-7.3.1-2018.05-x86_64_aarch64-linux-gnu&#x2F;bin:$PATH\n$ source ~&#x2F;.bashrc &#x2F;&#x2F;使启动脚本修改生效\n关掉终端重新打开\n$ aarc 按tab健 &#x2F;&#x2F;能补全为 aarch64-linux-gnu- 表示安装成功\n\n运行裸机程序$ make\n$ cp led.bin  /tftpboot\n\n//板子重启 停在u-boot处\n# pci enum;pci\n\nsetenv serverip  192.168.9.119 \t//设置服务器ip\nsetenv ipaddr 192.168.9.9\t\t//现在我理解为设置本机的ip\n\n# tftp led.bin\n# go 84000000  //运行程序\n               //如果是异常重启，可能是顺序执行到非法区域，或某指令写非法地址\n\nled.s//led.s\n\tmov x3,#0x5A\n\tmov x4,#0x55\nloop:\n\tb   loop\n\nMakefileCROSS = aarch64-linux-gnu-\nCC=$(CROSS)gcc\nLD=$(CROSS)ld\nOBJCOPY=$(CROSS)objcopy\n    \nall: led.s\n\t$(CC) -g -c -o led.o led.s  \n\t$(LD) led.o -Ttext 0x80090000 -o led.elf\n\t$(OBJCOPY)  -O binary -S led.elf led.bin\n\t$(CROSS)objdump -D led.elf > led.dis\n\t \nclean:\n\trm -f *.o *.elf *.bin *.dis\t\n\n\n\n出现问题：问题一：在将虚拟机编译好的led.bin通过tftp传到板子上后，使用go 指令无法执行 led.bin，也就是使用指令后，板子直接加入了内核。\n自己确定的事情：\n1、虚拟机成功生成了文件，并且汇编文件是带有死循环的。\n\n2、板子上的uboot成功收到了led.bin\n\n","slug":"硬件控制-arm-linux","date":"2022-04-09T03:53:52.000Z","categories_index":"","tags_index":"arm_linux","author_index":"祥瑞"},{"id":"1b233e39e81d8746e996add6970c9f45","title":"ARMV8_汇编","content":"指令集手册      https://developer.arm.com/documentation/ddi0596/2021-09/Base-Instructions\nARMV8发明的原因：\n三大动因 //应对大内存 虚拟化和安全的需求        //大内存(Large Memory): 突破32位机的4G空间限制  -&gt; 硬件越来越强，软件越来越复杂         //虚拟化(Virtualization): 隔离 高效  -&gt; 虚拟机               //安全(Security):  物理隔离  -&gt; 交易支付，隐私数据安全 \n还有pc端的涉足，比如新款的苹果笔记本都是arm架构\n\n三大创新  //执行状态,异常级别，和安全模式 \n\n执行状态  //AArch64 和 AArch32 两种可切换           //AArch64: 新增A64(ARM 64bit)指令集 -&gt; 大内存(突破4G限制)         //AArch32: 可用以前A32(ARM 32bit)指令集和 T32(Thumb 32bit)指令集 -&gt; 向前兼容 \n\n异常级别  //EL0(应用) &lt; EL1(OS) &lt; EL2(虚拟化) &lt; EL3(安全固件) -&gt; 替代啰嗦的工作模式 \n\n安全模式  //分为正常世界 和 安全世界  -&gt; 真正的安全(物理隔离,如支付场景)   \n\n\n多核处理器Z\n内存管理单元MMU\n内存管理单元使得上层应用用的内存空间映射到物理空间。\nARMv8寄存器框架\n现在的v8是32位的所以寄存器是64bit\n31个通用寄存器X/W  //X是64位  W是低32位 ARMv7 中使用Bank来减少异常的延迟 //然而使用的寄存器都不到一半\n\nAArch64 执行状态\t具有 31 × 64 位通用寄存器 //可在所有时间和所有异常级别访问\t\n\n\n\n特殊寄存器XZR     //零寄存器: 用作源寄存器时读为零，用作目标寄存器时丢弃结果\t\nSP      //堆栈指针 (每个异常级别，独有一个副本SP_ELn)\nPC      //程序计数器\nSPSR    //发生异常时，存储处理器状态(类似于 ARMv7 中的 CPSR)\nELR_EL  //异常链接寄存器\t保存导致异常的指令的地址\t\n\nPSTATE   //可独立访问的处理器状态的寄存器组 (取代 CPSR的状态字段)\nNZCV  //条件标志\n      //bit[31:29]: N Z C V  \n      //源头：搜索NZCV 在https://developer.arm.com/documentation/ddi0595/2021-09/AArch64-Registers\n      //mrs X0, NZCV      \nDAIF  //中断屏蔽位(为1时屏蔽)\n      //bit[9:6]: D A I F  D(断点观察点)   A:SError  I(IRQ)  F(FIQ)\nCurrentEL //当前的异常级别  \n          //bit[3:2]: 00(EL0)  01(EL1) 10(EL2) 11(EL3)      \n          // mrs x1, CurrentEL   可独立访问          \nSPSel //选择堆栈指针的异常级别 \n      //bit[0]:   0(都用SP_EL0)   1(用对应的SP_ELx) \n\n系统寄存器寄存器手册 // https://developer.arm.com/documentation/ddi0595/2021-09?lang=en\nSCTLR  //系统控制机器： 如MMU、缓存和对齐检查\t\nTTBR0_EL1 //转换表基址寄存器0  -> 物理空间 映射 应用空间 \nTTBR1_EL1 //转换表基址寄存器1  -> 物理空间 映射 内核空间\nMPIDR        //多处理器关联寄存器\nICC_SRE_EL3  //中断控制寄存器\nESR_EL      //异常综合症寄存器: 包括有关异常原因的信息\nHCR_EL      //管理程序配置寄存器： 控制虚拟化设置和捕获 EL2 的异常     \n\n向前兼容64位机可以兼容32位机\n\n在 AArch32 中执行时，无法访问 AArch64 寄存器的高 32 位 &#x2F;&#x2F;它使用 32 位 W 寄存器(相当于32 位 ARMv7 寄存器)\n\nARMV8异常级别减少了异常模式，现在只有4个级别的异常，分别是应用、系统、虚拟化、底层\n多了两个安全级别，运行一些厂商给库，一般不要去改这些东西\n\n环境搭建: 用qemu+ gdb + vscode -》实现特权寄存器的访问目的是实现模拟ARMv8的寄存器调试，之前是使用的keil但是，keil不支持armv8所以使用了新的平台来调试。\n\nqemu：是一个虚拟机模拟器，原因是直接在应用层调试机器的寄存器，会报错，所以模拟了一个虚拟机来调试。\n直接在应用层运行u-boot和内核不行 //因是不同地址空间\n但可以用模拟器在应用空间模拟调试 \n\n\n用qemu原因 //不能用$ gdb vmlinux调试内核，因在应用空间，不能运行内核空间的程序\n\t   //故用模拟器qemu来做，在应用空间模拟一个完整的系统。\n\n\n\nssh登录后 gdb调试 c/c++程序：创建工程：新开远程窗口   //点远程电脑图标 ->  点192.168.10.237 旁的加号 \n打开工作目录   //点 打开文件夹 -> 选工作目录(如 /home/yhbd/bsp)\n新建项目文件夹 //点 +号图标（新建文件夹）-> 输入文件夹名（如hello)  \n新建程序文件   // 点hello -> 点 +号图标（新建文件）-> 输入文件名（如main.c)   \n\n直接安装qemusudo apt-get instal qemu-system-arm\t\n$ qemu-system-aarch64 -h // 查看全部帮助信息\n$ qemu-system-aarch64 --version\n QEMU emulator version 2.11.1(Debian 1:2.11+dfsg-1ubuntu7.38)\n Copyright (c) 2003-2017 Fabrice Bellard and the QEMU Project developers\n\t \t\n$ qemu-system-aarch64 -machine help //查看支持的machine\n$ qemu-system-aarch64 -cpu help //查看machine支持的cpu类型\nWhen using -nographic, press 'ctrl-a h' to get some help\n\n版本太老  /*不支持A57 需源码编译\n\t 启动内核时会报错\n\trom: requested regions overlap (rom bootloader. free=0x000000004238ea00, \n         addr=0x0000000040000000)\n\tqemu-system-aarch64: rom check and register reset failed\n\t大概率是qemu版本问题。可考虑下载qemu源码，本地编译qemu二进制。   \n     */\n\n源码编译qemu因为ubuntu这个版本系统安装的qemu版本太低了，所以我们需要在官站上下载稳定版\nhttps://www.qemu.org/download/ 下载最新的稳定版本 qemu-6.2.0-rc2.tar.xz\n\t        //注：翻墙下载，用在板子上直接下载太慢了 wget https://download.qemu.org/qemu-6.2.0-rc2.tar.xz\n> scp qemu-6.2.0-rc2.tar.xz yhbd@192.168.10.237:/home/yhbd/bsp\n$ cd ~/bsp\n$ tar -xvf qemu-6.2.0-rc2.tar.xz\n$ cd qemu-6.2.0-rc2\n\n$ ./configure  /* 配置，报错解决如下\n   报错：ERROR: Cannot find Ninja\n   解决：sudo apt-get install ninja-build\n   \n   重运行./configure 还是会报很多错。\n      ERROR: Dependency \"pixman-1\" not found, tried pkgconfig\n   都是因为缺少软件，建议安装下面的\n  $ sudo apt-get install build-essential zlib1g-dev pkg-config libglib2.0-dev \n  $ sudo apt-get install binutils-dev libboost-all-dev autoconf libtool libssl-dev \n  $ sudo apt-get install libpixman-1-dev libpython-dev python-pip python-capstone virtualenv   \n\n   看到下面的信息表示成功了\n    Subprojects\n    libvhost-user                : YES\n\n\t\tFound ninja-1.8.2 at /usr/bin/ninja\n  \n   */\n$ make -j4  //4核并发编译，利用多核CPU并发能力\n           //最好用串口运行，因编译时间太长，而vscode ssh登录运行，容易超时退出。\n           //而且用串口运行，vscode 可以做别的事，相互不干扰\n$ sudo make install\n\n//查看版本，源码编译的，qemu它支持不同的硬件平台的虚拟，不仅是ARM\n$ qemu-arm --version\n   qemu-arm version 6.2.92\n   Copyright (c) 2003-2021 Fabrice Bellard and the QEMU Project developers\n$ qemu-riscv64 --version\n   qemu-riscv64 version 6.2.92\n   Copyright (c) 2003-2021 Fabrice Bellard and the QEMU Project developers\t\n\n$ qemu-system-aarch64 -cpu help //查看machine支持的cpu类型，发现支持A57\n  cortex-a53\n  cortex-a57\n  cortex-a72\n\n最简单start.s.globl\t_start\n_start:\n    mov x0, #1\n    ldr w1, &#x3D;0x778899\n    add x0, x0, x1\n    mrs x3, CurrentEL\nreset_end:\n    b reset_end\n\n\n\nmakefileCC &#x3D; aarch64-linux-gnu-gcc\nLD &#x3D; aarch64-linux-gnu-ld\n\nCFLAGS &#x3D; -g -O0 -nostdlib -nodefaultlibs\n\nstart: start.o\n\t$(LD) -o $@ $^\n\n%.o: %.S\n\t$(CC) $(CFLAGS) -c $&lt; -o $@\n\n.PHONY: clean\n\nclean:\n\t-rm start.o\n\t-rm start\t\n\n\n\n\n\nARMv8 汇编指令b.ne    label    &#x2F;&#x2F;不等时跳转\ncbz\tw10, 1f\t &#x2F;&#x2F;w10值等于0的适合，跳转导1f\t\nret              &#x2F;&#x2F;子程序返回指令，返回地址默认保存在LR（X30），代替了mov pc,lr\n\nldr \tx0,&#x3D;__main　 &#x2F;&#x2F;大范围的地址读取：把标号__main（地址）读入x0\nadr     x0,vector    &#x2F;&#x2F;小范围的地址读取：把标号vector（地址）读入x0,标号距当前指令PC的偏移小于1M\nstp\tx29, x30, [sp, #-16]!   \n    &#x2F;&#x2F;入栈：把x29, x30 存储到sp-16指向的空间后,sp自减16 (因寄存器是8字节，栈是向下生长故是 -16）                              \n    &#x2F;&#x2F;类似前索引： *(sp-16) &#x3D; x29,x30   sp&#x3D;sp-16 （!使得sp能自更新）  把 x29,x30看成整体              \n    &#x2F;&#x2F;stp只支持2个寄存器，代替了复杂的stmfd  (64位汇编，取消了批量操作指令)     \nldp \tx29, x30, [sp],#16   &#x2F;&#x2F;出栈: 把sp指向的空间内容载入到x29, x30后，sp加16\n                             &#x2F;&#x2F;类似后索引: x29,x30&#x3D;*sp  sp&#x3D;sp+16   \n\nmrs\tx0, sctlr_el1   &#x2F;&#x2F;读sctlr_el1内容到x0  (注：系统寄存器，都通过mrs msr来操作)\nmsr  \tsctlr_el1, x0   &#x2F;&#x2F;写x0内容到 sctlr_el1\nsvc     #2\t    &#x2F;&#x2F;系统调用指令(触发一个同步异常,cpu则会陷入EL1)\n\n.global  _start     &#x2F;&#x2F;声明_start 为全局符号(让链接脚本能看到)\n.quad  0x3FA0       &#x2F;&#x2F;在存储器中分配8个字节，初值设为0x3FA0\n.align  4           &#x2F;&#x2F;2^4 &#x3D;16 字节对齐 ， 预留空间\n.macro  myAdd, x,y  &#x2F;&#x2F;宏函数， 类似 myAdd(x, y) \n    add \\x,\\x,\\y\n.endm    \nmyAdd  x0,x2\n\n\n\n函数b.ne \tlable\t &#x2F;&#x2F;不等时跳转到标号，相对于咱v7的，多了一个点，n代表ni，e代表相等\ncbz\tw10, 1f\t \t &#x2F;&#x2F;w10值等于0的适合，跳转导1f\t\t\t1f函数是代表函数名为“1”，我们在调用的时候，只需要写‘1’就好了\t\nret              &#x2F;&#x2F;子程序返回指令，返回地址默认保存在LR（X30），代替了mov pc,lr\t，返回到函数调用的地方\n\n例: 延时函数是一个软件延迟，而且延迟时间很少\n.globl\t_start\t\t\t\t\n_start:\n    mov x0,#3\n    bl  delay\n\nreset_end:\n    b reset_end\n\ndelay:\t\n    ldr\t x4,&#x3D;0x03\nloop_delay:\n    sub     x4,x4,#1\n    cmp     x4,#0\n    cbz     x4,delay_end        \n    b.ne    loop_delay\ndelay_end:      \n    ret   \n\n宏函数注意在函数中使用，形式参数的时候，需要在它前面打一个” / “ \n.macro  myAdd, x,y      &#x2F;&#x2F;宏函数， 类似 myAdd(x, y) \t\n        add \t\\x,\\x,\\y\n.endm    \nmyAdd  x0,x2\t\n\nARMv8 异常处理异常类型\nSError //系统错误           //最常见的是异步数据中止（例如，由于脏数据从缓存行写回外部存储器而触发中止） \nFIQ  //快速中断     //group 0 or secure interrupts \nIRQ  //正常优先级中断       //group 1 (normal) interrupts \n同步异常 //是由于指令流的执行或尝试执行而产生的，并且返回地址提供了导致它的指令的详细信息，         //如未定义指令，从内存读取数据异常\n\n异常向量表\nadr\tx0, vectors    &#x2F;&#x2F;读取异常向量表的首地址\t\nmsr     vbar_el1,x0    &#x2F;&#x2F;设置异常表的基地址\nsvc     #2             &#x2F;&#x2F;系统调用(触发同步异常陷入， sp_el不同  陷入  不同异常) 具体怎么对应的，不太清楚\n\n异常向量表的设置与跳转现在V8的异常向量表没有放在起始地址，所以我们需要多一步设置，异常向量表的起始地址，异常类型，每个异常类型里面有4种异常 ，每个异常32条指令        16* *32 *4=2048 \n.globl\t_start\n_start:\n    mrs   x1,SPSel\n    mrs   x2,CurrentEL\n    mov   x0,#0\n    msr   SPSel,x0\n    mov   x0, #0x5\n    adr   x0,vectors\n    msr   vbar_el1,x0\n    svc   #0x02  &#x2F;&#x2F;系统调用 ，\nreset_end:\n    b  reset_end\n\ndo_bad_sync:\n   mov   x2,#1\n   b    reset_end\n\ndo_bad_irq:\n   mov   x2,#2\n   b    reset_end\n\n\t.align\t11  &#x2F;&#x2F;2^11&#x3D;2048  整个异常向量表 2K对齐  -&gt; 通过对齐，实现向量表空间的预留\n\t            &#x2F;&#x2F;16个异常 ，每个异常32条指令    16*32*4&#x3D;2048 \n                &#x2F;&#x2F;16个异常，这里使用前8个\nvectors:\n    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;sp0&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    &#x2F;&#x2F;---同步异常\n    .align  7  &#x2F;&#x2F;2^7     1000 0000 &#x3D;0x80   字节对齐  \n    mov  x0,#1\n    b    do_bad_sync\n    &#x2F;&#x2F;---irq异常\n    .align  7  &#x2F;&#x2F;2^7     1000 0000 &#x3D;0x80\n    mov  x0,#1\n    b    do_bad_irq\n    &#x2F;&#x2F;---fiq异常\n    .align  7  \n    mov  x0,#1\n    b    reset_end\n    &#x2F;&#x2F;---SError异常\n    .align  7  \n    mov  x0,#1\n    b    reset_end\n    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;sp_elx&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    &#x2F;&#x2F;---同步异常\n    .align  7  &#x2F;&#x2F;2^7     1000 0000 &#x3D;0x80   字节对齐\n    mov  x0,#1\n    b    do_bad_sync\n    &#x2F;&#x2F;---irq异常\n    .align  7  &#x2F;&#x2F;2^7     1000 0000 &#x3D;0x80\n    mov  x0,#1\n    b    do_bad_irq\n    &#x2F;&#x2F;---fiq异常\n    .align  7  \n    mov  x0,#1\n    b    reset_end\n    &#x2F;&#x2F;---SError异常\n    .align  7  \n    mov  x0,#1\n    b    reset_end\n\n","slug":"ARMV8-汇编","date":"2022-04-08T05:37:48.000Z","categories_index":"ARM开发","tags_index":"记录","author_index":"祥瑞"},{"id":"03ecb7b485f5674611d4371bbdb21945","title":"汇编初级-arm","content":"ARMv7-A (32bit)源头ARM Cortex-A 系列 ARMv7-A 程序员指南  // https://developer.arm.com/documentation/den0013/d    \n Armv7 和更早的 Arm 架构参考指南的指令集汇编指南 //https://developer.arm.com/documentation/100076/0200/a32-t32-instruction-set-reference/a32-and-t32-instructions     \n基本汇编语言程序设计  //https://developer.arm.com/documentation/dui0040/d/Basic-Assembly-Language-Programming     \nARM工作模式以及寄存器框图\n三角形代表这个模式下独有的寄存器。\n其他模式相对与User模式，r13和r14都发生了变化，原因是：    User模式下的r13和r14是SP寄存器和LR寄存器，而SP堆栈与函数调用等挂钩，最好不要用，但还是可以用，而r14连接寄存器，它和语句执行有关，一般不去主动使用它，所以其他模式相对与User模式，r13和r14都发生了变化。\nFIQ特有的寄存器比较多，r8_fiq到r14_fiq，原因是：    可以空间换时间\n例如User模式下，寄存器有值，然后中断触发，CPU切换到FIQ模式，保持User模式下的寄存器的值到FIQ模式下的特有的寄存器（r8_fiq到r14_fiq），这样当其他模式下，就可以使用r0到r12等寄存器，而当中断执行完后，r8_fiq到r14_fiq等寄存器可以返回到r0到r12等寄存器中。\n话说使空间换时间，是那cpu里面的寄存器空间换了什么时间哦？换了时间就是说速度变快了，也就是说还有一种方法，只是时间比较慢，哪种方法是什么哦？\n问：FIQ模式特有的寄存器(r8_fiq到r14_fiq)是切换到其他模式时用来保存当前寄存器（r0到r12）下的值，而设计的哈？这种模式可以空间换时间，空间是寄存器多了，换了时间就是说速度变快了，也就是说还有一种方法，只是时间比较慢，这另外一种方法就是只把通用寄存器的值写入内存单元（应该是内存哈）里面，然后中断完成后，再从内存里面取出来，这种就速度比较慢哦。\n简化一下就是说：FIQ模式特有的寄存器设计出来是为了加快速度，如果没有设计这玩意，我猜在切换cpu模式时，当前寄存器的值就要写入内存单元里面，然后模式切换回来后，再把值从内存移动到寄存器里面，这种方式就要比寄存器到寄存器要慢哦，所以是空间换时间哦？\n答：是的\n\n\nCPSR寄存器\n一个简单的汇编程序\t.text\t\t@代码段的开始\n\tb   main \t@调用 main函数\n\tnop\t\t\t@占位置用的，没有特殊含义\n\tb\tback\n\tnop\n\tnop\n\tnop\n\tnop\nmain: \t\t\t@main函数的内容\n    mov r0,#2\t @对寄存器r0赋值为2，其中的#，可使将源操作数看作立即数，而不是地址\nback:\n\tmov r1,#2\n\t\n\tend:\n\tb\tend\t\t@自己调自己，构成了一个循环，可使程序不会执行到其他位置\n\t\t\n\t.end\n\n\n通过CPSR寄存器切换arm工作模式    中断模式-&gt;user模式-&gt;中断模式\nCPSR寄存器的传送指令和普通寄存器不一样，普通寄存器的是mov，CPSR传入通用寄存器是msr，传出通用寄存器是mrs。\n\t.text\n\tb   main \n\tnop\t\n\tb\tc_mode\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\nmain: \n    mov r0,#2\n\tmrs r2,cpsr\t\nc_mode:\n\tmsr cpsr,#0x10\t@#代表数字，与其他字符区分，0x10对应处理器模式为是USER中断模式\n@\tmsr cpsr,#0x12   @想使用cpsr寄存器将处理器模式切换为SVC模式，但是编译报错，原因是没有这个权限（supervisor）\n\tswi 3 \t@以中断的方式，进入的SVC模式\n\tend:\n\tb\tend\n\t\t\n\t.end\n\n\n\n\n答：\n\nUSER模式，非特权模式，大部分任务执行在这个模式；\nARM一共有37个寄存器；\nPC（r15）      LR(r14)；\nr13 (SP)          他们是三个特殊的寄存器，中文名称是 程序计数器、连接寄存器、堆栈寄存器\nThumb是16位的，ARM是32位的，前者是后者的压缩，可以省空间。\n低5位\n\n关于Thumb和ARM指令：Thumb指令可以看做是ARM指令压缩形式的子集，是针对代码密度【1】的问题而提出的，它具有16为的代码密度。Thumb不是一个完整的体系结构，不能指望处理程序只执行Thumb指令而不支持ARM指令集。因此，Thumb指令只需要支持通用功能，必要时，可借助完善的ARM指令集，例如：所有异常自动进入ARM状态。\n为什么Supervisor模式又被称为SVC模ARM SVC（Supervisor Calls）\n\nPC的值，是程序准备执行（下一条）的指令的地址\n汇编初级指令搬移指令（传送指令）\n\n\n不报错\n报错\n\n\n\norr r0,#99\norr r0,#999\n\n\norr r0,#0xba\norr r0,#0x1ba\n\n\n感觉只要超过2位（不管什么进制），好像都会报错。\n报错信息为：“start.s(20): error: invalid constant (1ba) after fixup“ 无效产量\n规定立即数不能超过两位，咱也不知道为啥。\nLSL逻辑左移    LSR逻辑右移\n指令是如何存储、解析的？机器码会存储在FLASH中，通过总线和cpu（寄存器，运算单元，控制器），再到内存。\n指令的机器码32位机一条指令是32位（二进制）\n（所以就是这可能就是立即数不能太大的原因哦？）（这也说明了为什么两条相邻的语句内存地址相差了4，因为4*8=32，8bit代表一个字节）\n\n\n\n机器码\n指令\n\n\n\n0x01A03001\nmoveq r3,r1\n\n\n0xE1A03001\nmov r3,r1\n\n\n0xE0832001\nadd r2,r3,r1\n\n\n24位到21位是    操作数    例如    moveq就是“1101”\n\n伪指令    ldrldr r4,0x3FFFF\n可以将比较大的立即数转移到寄存器中\n跳转指令b指令，值得注意的是跳转指令和函数位置，必须在+-32M内部。\n具体原因是：adhsuafahf\nb    3main    跳转到标号为main地代码出（只能短跳转32M）\nbl    func    跳转函数func，并保存下一条要执行的指令位置到l寄存器，当跳转代码结束后，用mov pc,lr\nbeq    addr    相等时，跳转到地址addr处，相等（指CPSR寄存器中的Z条件码置位时，即为“1”时）\nbne    addr    不相等时\n用汇编 实现C语言功能void main(void)\n&#123;\n    int ret=0;\n    ret=func1(2);   \n    while(1)&#123;&#125;\t\n&#125;\t\nint  func1(int a)\n&#123;\n    if(a==2)\n        return func2(a);\n    else\n        return func3(a);  \n&#125;\nint  func2(int a) \n&#123;    \n    return a+3;\n&#125; \nint func3(int a)\n&#123;    \n    return a-1;\n&#125; \n\n\t.text\n\tb   main \n\tnop\t\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\nmain: \n\tmov r0,#0\t@r0~ret\t\n\tmov r1,#2\t@r1~a\n\tbl func1\n\t\nend_main:\n\tb\tend_main\n\t\nfunc1:\n\t\tmov r12,lr\n\t\tcmp r1,#2\t\n\t\tbleq func2\n\t\tblne func3\nend_func1:\n\t\tmov pc,r12\n\nfunc2:\n\tadd r1,#3\nend_func2:\n\tmov pc,lr\n\t\nfunc3:\n\tsub r1,#1\nend_func3:\n\tmov\tpc,lr\n\t\n\t.end\n\n\n逻辑指令and    r0,r1,r2    r1和r2相与，然后把结果放入r0\norr    类似\nbic    r0,r0,#0x0B    清除r0中的位 0、1、和 3   \ntst    r0,#0x20       测试第6位是否为0 ，为0则Z标志置1  \ncmp    r1,r0          将寄存器R1的值与寄存器R0的值相减，                      并根据结果设置CPSR的标志位\n1.判断当前工作状态是否是ARM状态，是则切换到user 工作模式？\t.text\n\tb   main \n\tnop\t\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\nmain: \n\tmrs\tr0,cpsr\n\ttst r0,#0x6\n\tmoveq r6,#0xAA\n\t\n\tbic\tr0,#0x3\n\tmsr\tcpsr,r0\n\t\n\tmrs\tr0,cpsr\n\ttst r0,#0x6\n\tmoveq r6,#0xAA\n\t\nend_main:\n\tb\tend_main\n\t\t\n\t.end\n\n\n\n\n2.使能中断和快速中断？mrs\tr0,cpsr\nbic\tr0,#0xc0\t@1100 0000\nmsr\tcpsr,ro\n\n算术指令add     r0,r1,r2       默认是不影响CPSR的标志位的\nadd     r0,#1\n\nsub     r0,r1,#3      类似  r0&#x3D; r1 - 3\nsub     r0,#1\n\nsub     r0,r1,r2,LSL#1    @先把r2里面的值，算术左移1位后，和r1相减，然后放入r0\n\n例如\nmov\tr0,#0x11\t@0001 0001\t-&gt;\t0010 0010\nmov r1,#0x22\t\nadd r2,r1,r0,lsl#0x1\n\n\n\n\n\n汇编指令高级Load/Store架构\nldr（ld代表load，r代表寄存器）    是将存储器里面的数据载入寄存器\nstr（st代表存储器，r代表寄存器）是将寄存器里面的值写入到存储器中\n最简示例\t.text\n\tb   main \n\tnop\t\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\nmain: \n\tldr r0,&#x3D;buf\t\t\t@保存源存储器的地址\n\tldr r1,&#x3D;destBuf\t\t@保存目的存储器的地址\n\tldr r3,[r0]\t\t\t@将源存储器的数载入到寄存器\n\tstr r3,[r1]\t\t\t@将寄存器里面的数写入到存储器\nend_main:\n\tb\tend_main\n\t\n\t.data\nbuf:\n\t.byte 0x00,0xAA,0xBB,0xcc\n\t\t\t\t\t\t@定义了4个字节的数据，分别是这些\ndestBuf:\t\n\t.space 4\t\t\t@分配了4个字节的空间\n\t\n\t.end\n\n就是先把目的和源的地址确定，然后把源存储器中的数据传入到寄存器，然后把寄存器的数据写入到存储器中。这样就实现了数据的转移。\nldr r9，_irq    表示将_irq的机器码放入目的寄存器            （irq代表标号）\nldr r9,=irq    表示伪指令，会将irq的地址传入目的寄存器\n例如：\n\t.text\n\tb   main \n\tnop\t\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\nmain: \n\tldr r0,end_main\t\t\t\n\tldr r1,&#x3D;end_main\t\t\n\nend_main:\n\tb\tend_main\n\t\n\t.data\nbuf:\n\t.byte 0x00,0xAA,0xBB,0xcc\ndestBuf:\t\n\t.space 4\t\t\t@分配了4个字节的空间\n\t\n\t.end\n\n\n前后索引前索引是        ldr    r0,[r1,#8]    先加地址，后放入值\n后索引是        ldr    r0,[r1],#8    先放入值，在加地址\n概念是会了，当时老师所说的应用情况还是不太清楚。\nload_store实现数据拷贝//用汇编实现C内容\nmain()\n&#123;\n\tint i=0;\n\tconst  char buf[]=&#123;1,2,3&#125;;\n\tchar destBuf[8];\n\tfor(i=0,i&lt;3,i++)\n\t&#123;\n\t\tdestBuf[i] = buf[i];\n\t&#125;\n&#125;\n\n\t.text\n\tb   main \n\tnop\t\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\nmain: \n\tmov\tr0,#0\t@r0~i\n\tldr\tr1,&#x3D;buf\n\tldr\tr2,&#x3D;destbuf\n\t\nloop:\n\tcmp\tr0,#7\n\tbeq end_main\n\tldrb r3,[r1],#1\n\tstrb r3,[r2],#1\n\tadd r0,#1\n\t\n\tb\tloop\n\nend_main:\n\tb\tend_main\nbuf:\n\t.byte 5,2,0,1,3,1,4\t\t\t@使用byte的原因是char类型的元素，大小为一个字节，值得一提的是这里的strb指令只能操作1个字\t\t\t\t\t\t\t\t   @节，strb，或者2个字节，strh，或者4个字节str。\n\t\n\t.data\ndestbuf:\n\t.space 8\n\t\n\t.end\n\n\nGNU汇编伪指令设计目的，汇编语言将帮助我们去实现一些功能，帮助我们理解。\n相当于调用了系统的汇编函数，虽然看起来就只有一句指令，但实际上使用了多条语句。\n看起来是一条指令，但编译成机器码后，可能会有多条机器码。\n.section\t\t\t\t\t\t\t&#x2F;&#x2F;定义内存段\n.text\t\t\t\t\t\t\t\t&#x2F;&#x2F;定义符开始的代码编译到代码段\t\t\n.data\t\t\t\t\t\t\t\t&#x2F;&#x2F;数据段\n.if\t.else .endif\t\t\t\t\t &#x2F;&#x2F;条件编译\n.end \t\t\t\t\t\t\t\t&#x2F;&#x2F;文件结束\n.byte\t0x11,&#39;a&#39;,0\t\t\t\t\t &#x2F;&#x2F;定义char类型的数组（.byte 就是一个字节）\n.word\t0x12,0x121\t\t\t\t\t &#x2F;&#x2F;定义int类型的数组（.word 是4个字节）\n.quad\t0x3FA0\t\t\t\t\t\t&#x2F;&#x2F;定义8字节的空间（.quad 代表8个字节）\n.string\t&quot;DASDAS\\0&quot;\t\t\t\t\t &#x2F;&#x2F;定义字符串\n.align 4\t\t\t\t\t\t\t&#x2F;&#x2F;4&#x3D;2^2\t字节对齐\n\nldr\tr0,&#x3D;0xE00221\t\t\t\t\t &#x2F;&#x2F;载入最大常数到寄存器中，如果是一般的汇编代码，一条指令对应一条机器码，而一条机器码是不能存放很大的数据的。\n.equ\tGPGASD,0X1212\t\t\t\t &#x2F;&#x2F;定义宏\n.global\t_start\t\t\t\t\t\t&#x2F;&#x2F;声名_start为全局符号\n\n批量操作指令之前做过，数据转移的操作，但是之前那个只是把存储器里面的数据只能放在一个寄存器里面，需要反复使用一个寄存器，不太方便，而这个指令可以同时使用多个寄存器批量操作。\n堆栈操作指令stmfd    sp!,{r0-r12,lr}\nldmfd    sp!,{r0-r12,pc}^\n软中断指令\nswi 0x22\n产生软中断，调用操作系统编号为02的系统例程\n异常向量表用的地址是从0开始的一段\n异常处理异常向量表\n如果要切换到，USER System模式下，是通过CPSR寄存器修改而边的。\n异常向量表和ARM处理器的工作模式是对应的进入那一个异常，就会进入这种工作模式。\n软中断最简\t.text\t\t\t\t\t\t\t\t\t@定义代码段\n\tb   main  \t@0x00 reset\n\tnop       \t@0x04 undef         \n\tb hander_swi\t@0x08 soft irq\n\tnop       \t@0x0c prefecth abort\n\tnop\t      \t@0x10 data abort\n\tnop\t\t@0x14 reserved\n\tnop\t\t@0x18 irq\n\tnop\t\t@0x1C fiq\n\t\t\t\t\t\t\t\t\t\t\t@异常向量表\nhander_swi:\n\tstmfd sp!,&#123;r0-r12,lr&#125;\t\t\t\t\t  @栈保存现场，包括了通用寄存器，和lr寄存器（存放了如果没有发生中断时，该执行的代码地址）\n\tldr r0 ,&#x3D;0x520\t\t\t\t\t\t\t @模拟寄存器变化，破坏现场\n\t\nhander_swi_end:\t\t\t\t\t\t\t\t \n\tldmfd sp!,&#123;r0-r12,pc&#125;\t\t\t\t\t @还原现场，包括通用寄存器和pc寄存器（下一页代码执行的地址）\n\t\n\t\nmain: \n\tldr sp,&#x3D;stack_top\t\t\t\t\t\t@给一个地址，作为栈顶\n\tmov r0 , #1\n\tmov r1 , #1\n\tmov r2 , #1\t\t\t\t\t\t\t    @构成现场\n\tswi 0x1;\t\t\t\t\t\t\t   @软中断\n\tmov r3 , #1\t\t\t\t\t\t\t\t\n\t\n\t\nend_main:\n\tb\tend_main\n\t\n\t.data\t\t\t\t\t\t\t\t@代码段\n\t\n\t.space 15*4\nstack_top:\t\t\t\t\t\t\t\t@因为栈是有着栈顶不变，元素线下生长的规定，所以将栈顶放到了高位的地址位\n\t\n\t.end\n\n\n现在的疑问：​    那么同等级的中断，比如我有两个软中断，我该如何设计呢？因为异常向量表只能方一个跳转指令。\n猜测：​    SWI  0x1和SWI  0x2，它们有一个标量的不同，所以我猜是，异常向量表中还是只放了一个跳转指令，当时跳转后没有直接执行目标函数，而是先执行通过标号判断是那个标号的中断触发，在去执行中断函数。\n软中断完整​    跟我猜想的差不多，实际运行原理是：\n​        中断标号其实是存在，SWI指令编译成的机器码中的，其中中断标号是低24位，所以我们只要找到这个指令的地址，然后用LDR指令将，指令地址上的机器码传入寄存器中,然后再将高8位置0,然后通过cmp，beq指令就可以判断要执行的标号具体哪一个了。\n\t.text\n\tb   main \n\tnop\t\t\t\n\tnop\t\t\t\n\tb hander_swi\t\t@SWI\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\t\nhander_swi:\n\tstmfd sp!,&#123;r0-r12,lr&#125;\t\n\tldr r0 , [lr,#-4]\t\t\t\t@lr是在执行中断时，将原本不发生中断时，要执行的指令的地址，然后将它减\n\t\t\t\t\t\t\t\t   @4这样就可以得到，软中断指令的地址，再将它的机器码传入寄存器，就可以得\t\t\t\t\t\t\t\t\t   @到，SWI中断标号得信息了\n\tbic r0 ,#0xFF000000\t\t\t\t @将高8位置0，因为swi指令的低24位才是标号的信息，高八位置操作码\n\tcmp r0,#0x1\t\t\t\t\t\t@判断是否为SWI 0x1\n\tbeq swi_1\n\tcmp r0,#0x2\t\t\t\t\t\t@判断是否为SWI 0x2\n\tbeq swi_2\nhander_swi_end:\n\tldmfd sp!,&#123;r0-r12,pc&#125;\n\t\nswi_1:\n\t\tldr r0,&#x3D;0x520\nswi_1_end:\n\tb hander_swi_end\n\t\t\nswi_2:\n\t\tldr r0,&#x3D;0x1314\nswi_2_end:\t\t\n\tb hander_swi_end\n\t\n\t\nmain: \n\tldr sp,&#x3D;stack_top\n\tmov r0 , #1\n\tmov r1 , #1\n\tmov r2 , #1\n\tswi 0x1;\n\tmov r3 , #1\n\tswi 0x2;\n\t\nend_main:\n\tb\tend_main\n\t\n\t.data\n\t\n\t.space 16*4\nstack_top:\n\t\n\t.end\n\n\ncontex-a 或者 contex-8的异常中断向量表\ncontex-a 或者 contex-8的异常中断向量表和ARM-7的好不太一样\n1、异常向量表的跳转没有用 “b”指令，而是使用的伪指令的ldr pc,“对应跳转的地址”（或者名称），这样就可以突破32M的范围（32M的原因是？）\n","slug":"汇编指令初级-arm","date":"2022-03-02T22:49:40.000Z","categories_index":"ARM开发","tags_index":"笔记","author_index":"祥瑞"},{"id":"0f8d9761b605a0589f071d0c0d4184a4","title":"嵌入式系统设计与应用","content":"前言材料及参考书获取资源\n\n\n\n\n\n\n\n书号是实体书背面的二维码\n相关网站www.arm.com\nwww.21ic.com/embed/\nwww.home.eeworld.com.cn（电子工程世界）\nbbs.elecfans.com(电子发烧友)    感觉不是很活跃\n第一章第一节课嵌入式概念：嵌入式系统即嵌入式计算机系统，为控制或监控目的而构筑，将其有机地植入目标系统。\n嵌入式系统有别于通用计算机系统，采用”量体裁衣“的方式把所需要的功能嵌入到各种应用系统中。———–系统移植裁剪\n几个重要特征：专业性强、系统内核小、系统精简、高效实时系统、嵌入式系统开发需要开发工具环境\n嵌入式系统的定义[P1-28]：“以应用为中心，以计算机技术为基础，软件硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。”\n嵌入式系统的定义(IEEE定义)嵌入式系统是“用于控制、监视或者辅助设备、机器和车间操作的装置。“原文为(Devices used to control, monitor, orassist the operation of equipment, machineryor plants.)\n\n引导系统：boot loader ，类似于bois\nBootLoader是嵌入式设备中用来启动操作系统内核的一段程序。uboot（universal bootloader）是一种可以用于多种嵌入式CPU的BootLoader程序，换言之，uboot是bootloader的一个子集。uboot的核心作用就是启动操作系统内核，uboot的本质就是一段裸机程序。\n\n第二节课操作系统的基本概念前后台系统：在该系统中应用程序是一个无限的循环，循环中调用相应的函数完成相应的操作。与中断很像。\n\n\n嵌入式系统的分类\n\n软/硬实时系统概念\n软件实时系统相当于人要不要女朋友，虽然会伤心，但是问题不大，而硬实时系统相当于人要吃饭，不吃会洗。\n硬实时系统的应用，是在实现与非常重要、需要实时处理的任务时采用。\n硬/软实时系统都是软件实现的\n\n几种常见的RTOS软实时    linux    wince        硬实时    wxworks\n\n\n\n著名的open RTOS（开源）\nucOS/II    Linux\n\n\n\n\n有产权的RTOS\nHOPEN      Delta OS\n\n\n\n本章小节\n1、嵌入式系统即嵌入式计算机系统，为控制或监控目的而构筑，将其有机地植入目标系统。\n2、\n3、\n4、\n5、\n\n第二章第一节课\n冯诺依曼结构：计算机在工作时能够自动地从存储器中取出指令并加以执行。\n程序和数据不做区分，编译成了同一种二进制代码\n哈佛结构（常见）：程序和数据，都有专门的通道，允许同时访问数据和程序，速度大大提高\n处理器体系结构：两大分支：\nCISC（复杂指令集）RISC（精简指令集，常见）\n着眼在如何使计算机的结构更加简单，合理地提高运算速度。\n优先选取使用频率高的简单指令;指令长度固定，指令格式和寻址方式种类减少;以控制逻辑为主，不用或少用微码控制（数字电路）。\n\n特点：\n\n采用固定长度指令格式，指令及寻址方式简单;\n使用单周期指令，便于流水线操作;(使用一个机器周期)\n大的、统一的寄存器文件;\nLoad / Store结构的指令。(既数据处理指令只对寄存器进行操作，而不直接对存储器操作，以提高指令的执行效率)\n\n问题1：为什么便于流水线操作？\n\n每个运行模块（取值功能的、译码功能的、执行功能的）都采用一个机器周期，能有交替使用模块，形成流水线。\nRISC和CISC的差异：\n指令系统:RISC设计者把主要精力放在那些经常使用的指令上，尽量使它们具有简单高效的特色。对不常用的功能，常通过组合指令来实现。而CISC计算机的指令系统比较丰富，有专用指令来完成特定的功能。\n存储器操作:RISC对存储器操作有限制，使控制简单化;而CISC机器的存储器操作指令多，操作直接。\n程序: RISC汇编语言程序一般需要较大的内存空间，实现特殊功能时程序复杂，不易设计;而CISC汇编语言程序编程相对简单，科学计算及复杂操作的程序设计相对容易，效率较高。\n中断:RISC机器在一条指令执行的适当地方可以响应中断;CISC机器是在一条指令执行结束后响应中断的。\nCPU:由于RISC CPU包含较少的单元电路，因而面积小、功耗低;而CISC CPU包含丰富的电路单元，因而功能强、面积大、功耗大。\n设计周期:RISC微处理器结构简单，布局紧凑，设计周期短，且易于采用最新技术;CISC微处理器结构复杂，设计周期长。\n易用性:RISC微处理器结构简单，指令规整，性能容易把握，易学易用;CISC微处理器结构复杂，功能强大，实现特殊功能容易。\n应用范围:RISC机器更适合于嵌入式应用;而.cISC机器则更适合于通用计算机。\n\nARM微处理器的特点\n采用RISC架构的ARM微处理器具有如下特点体积小、低功耗、低成本、高性能;\n支持Thumb (16位)IARM (32位)双指兼容8位/16位器件;\n大量使用寄存器，指令执行速度更快;口大多数数据操作都在寄存器中完成;\n寻址方式灵活简单，执行效率高;\n指令长度固定\n\n存储器\nRAM (Random Access Memory,随机访问存储器)RAM可分两类:静态RAM (Static RAM,即SRAM)和动态RAM (Dynamic RAM,即DRAM)\n\nROM (Read-Only Memory,只读存储器)\nROM是非易失性(在断电情况下仍能保持所存储的数据信息）存储器，通常使用的有EPROM及EEPROM。可用flash代替。\n\nFLASH (Flash EEPROM Memory , 闪存)是一种长寿命的非易失性的存储器，数据删除不是以单个的字节为单位而是以固定的区块为单位。是n个字节。\n\n\nFlash分为NOR Flash、NAND Flash两种。\nNOR Flash的特点是在芯片内执行(XIP,eXecute In Place),可以直接读取芯片内储存的数据，应用程序直接在Flash内运行，不必把代码读到系统RAM中运行。\nNAND Flash不能直接在Flash内运行应用程序，需要将数据复制到RAM中运行，NANDFlash的特点是容量大，擦写速度快。\n\n寄存器\n寄存器是处理器的内部存储部件。\n根据寄存器的作用，可将寄存器分为控制寄存器、状态寄存器和数据寄存器3大类\n所有的处理器都有一个程序计数器（也叫做指令指针)，它跟踪将要被读取并执行的下一条指令在内存中的单元地址。\n\n堆栈​    一种按后进先出的原则进行存取的连续的存储单元区。\n总线(BUS)\n所谓总线是具有相关功能的信号线的集合。\n多数处理器采用了三总线系统体系结构，分别是地址总线、数据总线和控制总线。\n总线的基本功能是实现信息交换和信息共享，主要由传输信息的物理介质和管理信息传输的协议组成。\n\nJTAG接口注意实验室操作规范并口报错 pararel，计算机出错，反之串口报错，则JTAG出错。\nJTAG可以看电脑是否运行。\n习题\n简述两种计算机结构\n冯诺依曼结构，程序和数据是一条通道在存储器和cpu之前传送，哈佛结构是程序和数据分别有一条单独的通道。\n\n简述RISC\n\n\n​    Load / Store结构的指令。\n","slug":"嵌入式系统设计与应用","date":"2022-03-01T02:43:21.000Z","categories_index":"课程学习","tags_index":"linux","author_index":"祥瑞"},{"id":"a74d8c03b21a96da74602aa82e615493","title":"日常踩坑-pip3","content":"我今天在安装这个pytorch\n然后安装的时候，需要使用python3.6以上的版本，然后我就找到了这篇文章\n(84条消息) ubuntu18.04升级Python3.6到Python3.7_isanth-CSDN博客\n成功的安装了3.7版本的python\n但是不知道为什么，这以后我就无法使用pip3..\n然后又搞了半天，找到了这篇文章\n(84条消息) pip升级以后 pip3怎么都使用不了_走遍星空的CG的博客-CSDN博客_pip3用不了\n解决办法： 重新安装pip3\nsudo python3 -m pip uninstall pip &amp;&amp; sudo apt install python3-pip –reinstall\n 如果不是找到了这篇文章，我估计我又得去重装系统了T.T\n","slug":"日常踩坑-pip3","date":"2022-02-23T23:06:39.000Z","categories_index":"taking","tags_index":"linux","author_index":"祥瑞"},{"id":"c42a0b3141aaa138d0f4817da34142c5","title":"C——更上一层楼","content":" 前言：写这么一篇blog的原因有：\n​                重走一边c路，巩固基础知识，基础不牢，地动山摇\n​                学会底层思维    //编译运行 资源分配回收 效率\n​                重点 难点 突破 //指针 内存\n             面向面试\n\n环境搭建\n环境搭建安装好vsc后，创建main.c后输入#include &lt;stdio.h&gt;后报错显示“检测到 #include 错误。请更新 includePath”\nvscode检测到#include错误请更新includePath的解决方法\nUbuntu16.04下配置VScode的C/C++开发环境_WavenZ的博客-CSDN博客_ubuntu vscode配置c++环境\n Ubantu下使用VSCode编译运行C语言程序\n创建代码文件  //文件 -> 打开文件夹（如C) \n\t     // 点 +号图标（新建文件）-> 输入文件名（如main.c)   \n\t     //注：vscode能自动识别.c文件，提示你安装C插件，安装即可\n\n运行和调试 //点 运行和调试 -> 创建lanuch.json (运行和调试的配置文件) -> 选gcc\n\n断点调试   // 在某行代码 行数字的前面 点击 设置断点(红点变亮) \n\t  // 点绿三角运行（或F5） -> 可单步调试(F11）   \n\n备份      //备份.vscode 文件，当有新的代码时，拷贝过去，无需花时间再配置    \n\n底层思维二进制&amp;十六进制1kb代表2的10次方的2进制\n1mb代表2的20次方的二进制\n1Gb代表2的30次方个二进制\ngcc编译$ gcc main.c  &#x2F;&#x2F;编译C程序，默认生成a.out执行文件\n&#x2F;&#x2F;也可以改名字，gcc main.c -o xxx.exe\n &#x2F;&#x2F;gcc -v main.c 显示详细的编译过程信息\n$ .&#x2F;a.out     &#x2F;&#x2F;运行程序\n\ngdb 调试原始的编译方式\nint b =5；int w = 6；他们的地址是相邻的\n$ gcc -g  main.c  &#x2F;&#x2F;编译生成带有调试信息的执行文件a.tou\n$ gdb a.out &#x2F;&#x2F;调试程序\n$ l     &#x2F;&#x2F;list: 查看源码(默认10行)\n        &#x2F;&#x2F;list 8  查看8行附近的代码\n        &#x2F;&#x2F;list main 查看函数名附近的码\n$ b 5   &#x2F;&#x2F;break: 在第5行设置断点\n$ r     &#x2F;&#x2F;run: 运行到断点处（如无则运行直到结束）\n$ s     &#x2F;&#x2F;step: 单步执行（如果是函数则进入）\n$ n     &#x2F;&#x2F;next: 单步跳过（如果是函数则跳过）\n$ p a   &#x2F;&#x2F;print: 查看变量内容\n        &#x2F;&#x2F; p &amp;a  查看变量a的地址\n        &#x2F;&#x2F; p &amp;b+1   b变量的地址根据数据类型递增(int型 会加4，char型则加1)\n        &#x2F;&#x2F; p *(&amp;b+1)\n        &#x2F;&#x2F; p a[1] \n        &#x2F;&#x2F; p *p1 查看p1指针里的内容 \n        &#x2F;&#x2F; p  add(4,7)  调用函数add 并打印返回值\n$ p&#x2F;t b &#x2F;&#x2F; t  二进制显示 变量的值  \n\t&#x2F;&#x2F; x  按十六进制格式显示变量。\n\t&#x2F;&#x2F; d  按十进制格式显示变量。\n\t&#x2F;&#x2F; u  按十六进制格式显示无符号整型。\n\t&#x2F;&#x2F; o  按八进制格式显示变量。\n\t&#x2F;&#x2F; a  按十六进制格式显示变量。\n\t&#x2F;&#x2F; c  按字符格式显示变量。\n\t&#x2F;&#x2F; f  按浮点数格式显示变量。      \n$ x &amp;a  &#x2F;&#x2F;显示某地址的内存值 \n        &#x2F;&#x2F;例如 float a &#x3D; 0.45; 的内存值为\n        &#x2F;&#x2F; 0x7fffffffdf8c:\t00111110111001100110011001100110        \n上下键  &#x2F;&#x2F;可查看历史命令\n$ bt     &#x2F;&#x2F;查看堆栈信息 （如嵌套调用多个函数时）\n$ c      &#x2F;&#x2F;continue： 继续执行程序（直到下一个断点或者结束）\n$ q      &#x2F;&#x2F;quit: 退出gdb调试\n$ dmesg  &#x2F;&#x2F;查看内核信息     \n\n如何编译生成执行文件1、预处理（cpp）：gcc -e，生成main.i，内容包括“宏替换，条件编译，include”\n2、编译（cc）：gcc -s，生成main.s汇编文件\n3、汇编（as）：gcc -c，生成main.o\n4、将main.o和libmy.a和fun.o链接（ld）：gcc,生成a.out执行文件（.bin  .exe）\n预处理$ gcc -E main.c -o main.i &#x2F;&#x2F;停在预处理阶段(生成 main.i文件) \n                          &#x2F;&#x2F;发现宏被替换了,条件编译生效\n\n编译$ gcc -S main.c  &#x2F;&#x2F;停在编译阶段(生成汇编文件 main.s) \n\n汇编$ gcc -c main.c  &#x2F;&#x2F;停在汇编阶段(生成目标文件 main.o )\n$ vim main.o  &#x2F;&#x2F;16进制显示 二进制文件\n              &#x2F;&#x2F;在命令行模式下输入  :%!xxd\n\n链接$ gcc -c fun.c \n\n$ gcc main.o fun.o  &#x2F;&#x2F;链接目标文件或库文件(.a .so)，生成执行文件 a.out(.bin .exe)\n                    &#x2F;&#x2F;独立的目标文件都是从0地址开始，需要链接来重新合并安排地址 \n                    &#x2F;&#x2F;链接异常 会报 collect2: error: ld returned 1 exit status               \n$ objdump -d a.out   &#x2F;&#x2F;查看反汇编代码\t\n                     &#x2F;&#x2F;可查看 objdump -d fun.o 等看链接过程是如何把代码嵌入式到main.o中\n\n变量和数据类型\n","slug":"C——更上一层楼","date":"2022-01-19T16:22:54.000Z","categories_index":"记录","tags_index":"c","author_index":"祥瑞"},{"id":"821b392c122e136488bc357accf1698d","title":"17届智能车日志","content":"2022年1月6日今天的话，期末考试实际上还是没有结束，但最后一个科目在五天后，而且学长说比较简单，那我就赶紧开始智能车这个项目啦，冲冲冲。\n我的意向是单车组别，今天查看了龙邱的方案，今天万能的群友试错，感觉效果还是非常不错的，所以就先跟着这个方案做了，用自己的钱（我的奖学金，本来还说买相机呢，希望后面老师能补助给我）先买些基础的配件，我想先跑起来再说，后期再慢慢调试。\n\n\n\n主要配件\n价格（元）\n作用\n\n\n\nK车模*1\n738\n车模本模，一个车模的价格居然比真的自行车还贵\n\n\nLQ-60mm动量轮套装\n324\n直接买了，先不去自己做折腾了，后期可考虑升级\n\n\nLQ-定制有刷电机*1\n上面有了\n驱动动量轮\n\n\nLQ-TC297核心板*1\n258\n考虑是否使用264\n\n\nLQ-TC系列2/3XX通用母板\n118\n🙄\n\n\nLQ-Miniwiggler调试器*1\n实验室有\n🙄\n\n\nLQ-K车mini512线编码器套件*1\n先不买\n飞轮套装已经有编码器了，所以只需要一个\n\n\nLQ-TFT1.8寸屏幕*1\n实验室有\n🙄\n\n\nLQ-DRV8701双路驱动*1\n117\n🙄6\n\n\n\n\n\n\n价格（元）\n作用\n\n\n\nLQ-6050陀螺仪模块*1\n19.8\n🙄🙄🙄🙄🙄🙄🙄🙄🙄🙄🙄🙄🙄🙄🙄🙄\n\n\nLQ-MT9V034神眼135°摄像头*1\n先不买\n\n\n\n电池\n\n\n\n\n\n\n\n🙄🙄🙄🙄🙄🙄🙄🙄🙄🙄\n共计🙄🙄\n🙄🙄🙄🙄🙄🙄🙄🙄🙄🙄🙄🙄🙄🙄🙄\n\n\n\n第一次购买（快递费何97开票费用）\n1616.8\n\n\n\n平衡单车直立程序视频讲解：\nhttps://www.bilibili.com/video/BV1J3411v7Lr?from=search&amp;seid=3922392162121695676&amp;spm_id_from=333.337.0.0\nADS安装使用教程：\nhttps://www.bilibili.com/video/BV1wV411E7PY?from=search&amp;seid=15035982395236446406&amp;spm_id_from=333.337.0.0\nTC264开发环境ADS修改字体大小：\nhttps://www.bilibili.com/video/BV1yi4y157mq\n（字体大小修改快捷为Ctrl shift +或Ctrl shift -）\n\n2022年1月7日今天就把配件下单吧，收货地址选在家里，那么为了能在家里面能直接开始调试，还需要拿实验室的一些东西\n有下载器（最好把两个都带上，因为这玩意容易失灵），电池以及充电器。\n\n2022年1月8日今天就把软件安装上吧，然后下载龙邱的程序来看看\nADS编译环境资料链接                                    提取码：eawu    \n十七届平衡单车组程序分享（含直立和循迹）提取码：sdry\nADS软件常见问题汇总\n\n2022年3月9日转眼已经过了一个寒假，其实在寒假也发生了很多东西，但是我没有坚持每天记录，主要在家里面不能有很多其他的事情。现在还是简单说一下，寒假都做了什么吧。\n开学后对队友说的话我们组，我主要负责软件吧，我都搞了这么久了哈，振汉和斌元主要负责硬件哦？虽然我们分了软硬件，但我都都得了解一下软件硬件哈，比如你们画pcb，肯定需要知道用的那个方案，这个方案里面的编码器引脚是哪一个，我在写软件的时候都会基于你们的板子来做，才能更好的合作。\n现阶段，我们需要解决的问题有：\n将车子机械结构重新设计一下（因为我之前使用热熔胶固定的，不是很好，而且重心比较高，要调整一下主板和驱动板的摆放位置），这个事情到到实验室我们照着车说，会需要设计pcb板当作支架（白嫖嘉立创）。\n然后调试摄像头循迹，这块主要我来做吧，我比较熟悉一点，但这个时候会非常耗时间，所以同时振汉和斌元你们就可以开始设计母版和驱动板了，因为我们自己设计的板需要反复验证，可能设计出问题了就要重新打板焊接。\n有什么建议都可以说哈，然后要多和群友交流，吸取他们的经验，会比我们自己单独搞好很多。\n阶段展示 \n\n2022年3月23日今天大佬（）给我分享了一段串级pid的代码，放到这里保存一下\n//-------------------------------------------------------------------------------------------------------------------\n//  @brief      速度计算\n//  @param      void\n//  @return     void\n//  @since\n//-------------------------------------------------------------------------------------------------------------------\nvoid FlyexpectSpeed_out(void)//计算速度\n&#123;\n    FlyMotor.RealSpeed = gpt12_get(GPT12_T2);\n    gpt12_clear(GPT12_T2);\n\n    FlyMotor.RealAngle = Angle;\n\n    /////// 动量轮控制//////////\n    angular_velocity_Control();\n\n    if(FlyMotor.SpeedOut > FlyMotor.SpeedMAX)   FlyMotor.SpeedOut = FlyMotor.SpeedMAX;\n    if(FlyMotor.SpeedOut &lt; -FlyMotor.SpeedMAX)  FlyMotor.SpeedOut = -FlyMotor.SpeedMAX;\n&#125;\n\nvoid Velocity_Control()\n&#123;\n    FlyVelocity.Target = 0;  //设定期望速度\n    FlyVelocity.Error =  FlyVelocity.Target - FlyMotor.RealSpeed;\n    FlyVelocity.SumError += FlyVelocity.Error;\n\n    if(FlyVelocity.SumError > +500) FlyVelocity.SumError = +500;//限幅 \n    if(FlyVelocity.SumError &lt; -500) FlyVelocity.SumError = -500;//限幅 \n\n    FlyVelocity.Output = FlyVelocity.Error * FlyVelocity.KP + FlyVelocity.SumError * FlyVelocity.KI;\n    FlyVelocity.Output = FlyVelocity.Output/1000;\n    //限制幅度\n    if(FlyVelocity.Output > +0.5)   FlyVelocity.Output = +0.5;\n    else if(FlyVelocity.Output &lt; -0.5)  FlyVelocity.Output = -0.5;                                                     //获取最终数值\n&#125;\n\nvoid angular_Control()\n&#123;\n     Velocity_Control();\n\n     FlyAngle.Error = FlyMotor.ExpectAngle - FlyMotor.RealAngle - FlyVelocity.Output;\n     FlyAngle.SumError += FlyAngle.Error;\n     if(FlyAngle.SumError > +100) FlyAngle.SumError = +100;//限幅                    \n     if(FlyAngle.SumError &lt; -100) FlyAngle.SumError = -100;//限幅                       \n\n     FlyAngle.Output = FlyAngle.Error * FlyAngle.KP + FlyAngle.SumError * FlyAngle.KI;\n     //获取最终数值\n&#125;\n\nvoid angular_velocity_Control()\n&#123;\n     angular_Control();\n     int16 KP1;\n     KP1 = FlyGyro.KP;\n     //if(FlyAngle.Output &lt; 16 &amp;&amp; FlyAngle.Output > -16) KP1 = FlyGyro.KP * 0.7;\n\n     FlyGyro.Error = Gyro_Final - FlyAngle.Output;\n     FlyGyro.SumError += FlyGyro.Error;\n     if(FlyGyro.SumError > +500) FlyGyro.SumError =+ 500;//限幅 \n     if(FlyGyro.SumError &lt; -500) FlyGyro.SumError =- 500;//限幅 \n\n     FlyMotor.SpeedOut = KP1 * FlyGyro.Error + FlyGyro.KI * FlyGyro.SumError + FlyGyro.KD * (FlyGyro.Error -FlyGyro.LastError);\n     //获取最终数值\n     FlyGyro.LastError = FlyGyro.Error;\n&#125;\n\n\n\n2022年4月2日今天就还是搞一下智能车吧，但是会在我把所有其他任务完成后哈。。。\n","slug":"17届智能车日志","date":"2022-01-06T08:17:07.000Z","categories_index":"比赛项目","tags_index":"智能车","author_index":"祥瑞"},{"id":"5edbb0bb0225a5f787cc77b6741890ba","title":"Linux命令","content":"文件与目录：$ ls         //查看里面有什么东西(浏览目录内容)  \n$ tree -L 2  //查看当前的前两层目录树\n$ tree /home //查看home目录下的子目录树 \n$ cd /　　　 //切换到系统根目录   cd (change directory)\n$ cd ~       //切换到当前用户目录\n$ pwd        //查看当前路径\n$ cd ..　　  //切换到上一层目录\n$ mkdir  hello  //创建目录\n$ rm hello  -rf    //删除目录(文件夹)\n$ cd hello      //切换到当前目录下的hello子目录\n$ ln -s /mnt/hgfs  ./  //建立软链接（类似快捷方式）\n//文件操作\n$ touch main.c //创建文件\n$ mv  main.c hello.c //更改文件名\n$ gedit main.c  //用图形编辑器编辑\n$ vi  main.c   //编辑文件\n$ cat main.c   //查看文件内容\n$ cp main.c aa //拷贝文件\n$ rm main.c    //删除文件\n//压缩解压\n$ tar -zcvf /tmp/etc.tar.gz /etc   //压缩\n$ tar -zxvf /tmp/etc.tar.gz        //解压\n\n系统操作：//权限设置\n$ sudo  su    //切换到root用户\n$ su ivan     //切换回普通的ivan用户\n$ chmod 777 main.c //设置权限为所有\n$ passwd  //修改当前用户的密码(会有输入更长密码的限制)\n$ sudo passwd yhai  //用root用户权限去修改 yhai用户的密码，就没有限制了，可以设为1\n//安装新命令\n$ sudo apt-get install tree //安装命令\n$ sudo apt-get remove tree  //卸载命令\n//搜索\n$ find . -name hello.c  //在当前目录下搜索文件(hello.c)\n//磁盘空间\n$ df -h  //查看各磁盘空间使用情况\n$ du -h yhai/  //查看文件夹占多大空间\n\nVI命令：嵌入式，基本编辑器，有三种模式\n$ vi main.c  //编辑文件，进入vi模式\n\n命令模式（默认启动进入）//切换到输入模式\ni  //进入插入状态（按下i ，并不会输入一个字符，而被当作一个命令insert）\n   //再输入字符，会插入在光标前\na  //进入追加状态(再输入字符，会追加在光标后)\no  //进入新一行输入状态(再输入字符，会在新一行输入)\n//移动光标\n     k 上 \nh 前       l 后 \n     j 下\nr  //取代光标处的字符\nx  //删除当前光标所在处的字符。\nctrl + f //下翻页\nctrl + b //上翻页 \ngg  //跳到第一行\nshift + g //跳到最后一行\ndd //删除一整行\n   //3dd: 删除3行\nyy //复制一行\nv + h/j/k/l  //选取字符串\ny //复制\np  //粘贴 \nu  //复原前一个动作\n   //再输入 Ctrl+r : 回退到修改前状态j\n: //切换到底行模式(即可在最底一行输入命令)    \n\n\n\n输入模式Esc //切换到命令模式\n\n低行模式:w  //写入 \n:q  //退出 \n:q! //不保存退出\n:set nu //显示行号    \n:set nu! //隐藏行号   \n:30   //光标跳到第30行\n/word  //搜索字符串 word\n       // n: 查找下一个  shift + n: 查找上一个  \nBackspace //取消底行字符后，自动切换到命令模式\n\n","slug":"linux命令","date":"2022-01-03T08:08:55.000Z","categories_index":"记录","tags_index":"linux","author_index":"祥瑞"},{"id":"0e9eaaf753227dae6c8b950fc994c974","title":"汇编刷题","content":"\n(简答题)从键盘输入两个 0-9 之间的数据求和并显示\n\nCODES SEGMENT\nASSUME CS:CODES\nSTART:\n\n    MOV AH,01H\t\n    INT 21H\t\t\t\t输入数字1\n    MOV BL,AL\n    \n    \t\n    MOV AH,01H\t\t\t输入数字2\n    INT 21H\n\n    \n \tADD AL,BL\t\t\t加上数值1和2\n \tMOV AH,0\n \tAAA\n \tADD AX,3030H\n \tPUSH AX\n \tMOV DL,AH\n \tMOV AH,02H\n \tINT 21H\n \t\n \tPOP AX\n \tMOV DL,AL\n \tMOV AH,02H\n \tINT 21H\n \t\n    MOV AH,4CH\n    INT 21H\nCODES ENDS\n    END START\n\n2.将按键输入的两个数字放入指定内存单元\nCODES SEGMENT\nASSUME CS:CODES\nSTART:\n\tMOV AX,0000\n\tMOV DS,AX\n\n    MOV AH,01H\n    INT 21H\n    MOV DS:[0],AL\n    \n    \n    MOV AH,01H\n    INT 21H\n    MOV DS:[1],AL\n\n    MOV AH,4CH\n    INT 21H\nCODES ENDS\n    END START\n\n\n(简答题)假如 ax 的每一位都接了一个 led 当某一位为 1 则对应的 灯亮,亮的 led 逐次递增当全部点亮时重新开始 \n我的答案：\n\n\nNEXT1:\nMOV AX,0\n\nNEXT2:\n\nADD AX,1\nCMP AX,15\nJZ NEXT1;如果相等，ZF为1，也就是AX为15（灯全亮），需要灭灯，重新开始\n\nJMP NEXT2\n\n​        参考答案：\nn2:mov ax,8000h\nn1:sar ax,1\njnc n1\njmp n2\n\n\n(简答题)编写程序实现 0+1+2+3+4-5+6-7+8\n\n (简答题)写出从 PC5 输出一负脉冲的程序片段 \n\n\n   ​    0000 1010B = 0AH        0000 1011B = 0BH\n   NEXT1:\nMOV DX,303H\nMOV AL,0AH\nOUT DX,AL\nNOP\nMOV DX,303H\nMOV AL,0BH\nOUT DX,AL\nNOP\nJMP NEXT1\n\n\n(简答题)找出 3000:0000 为首地址的 100 个字节中的第一个非 0 项,送 DL 寄存器中. \n我的代码：\n\n\ncode segment\nASSUME CS:CODE\nstart:\n\n  \t MOV AX,3000H\n\tMOV DS,AX\n\t\n\tMOV BX,0\n\tMOV CX,100\n\tNEXT1:\n\t\n\tCMP BYTE PTR DS:[BX], 0\n\tJZ NEXT2\n\tINC BX\n\tLOOP NEXT1\n\t\n\tNEXT2: MOV DL,[BX]\n    MOV AH,4CH\n    INT 21H\nCODE ENDS\n    END START\n\n参考代码\n解\t1:code segment\nassume cs:code\nstart: mov ax,3000h\nmov ds,ax\nmov dl,00h\nmov bx,00h\nmov cx,100\nnext2: cmp byte ptr[bx],00h\nmov dl,[bx]\njnz next1\ninc bx\nloop next2\nnext1: int 3\ncode ends\nend start\n解 2:code segment\nassume cs:code\nstart: mov ax,3000h\nmov ds,ax\nmov dl,00h\nmov bx,0ffffh\nmov cx,100\nnext2: inc bx\ncmp byte ptr[bx],00h\nloopz next2\nmov dl,[bx]\nnext1: int 3\ncode ends\nend start \n\n\n\n(简答题)将 20h 放入地址为[30000h]开始的 100 个单元\ncode segment\nassume cs:code\nstart:\n\tmov ax,3000h\n\tmov ds,ax\n\t\n\tmov ax,20h\n\tmov bx,0\n\t\n\tNEXT1:\n\tmov byte ptr ds:[bx],al\n\tINC BX\n\tCMP BX,100\t\t\t&#x2F;&#x2F;其实是0到99\n\tJNZ NEXT1\t\t\t&#x2F;&#x2F;不能将INC放到JNZ前面，因为ZF会受INC影响\n\tINT 3H\t\t\t\t&#x2F;&#x2F;中断\n\ncode ends\nend start\n\n(简答题)比较 al 和 bl 中的两个无符号数大小将大数放在 al \n\n\ncode segment\nassume cs:code\nstart:\n\tMOV AH,01H\n\tINT 21H\n\tMOV BL,AL\n\t\n\tMOV AH,01H\n\tINT 21H\n\t\n\tCMP AL,BL\n\tJNC N1\t;;跳转是CF为0，也就是AL比BL大\n\tMOV AL,BL\n\tN1: \n\t\n\tMOV DL,AL\n\tMOV AH,02H\n\tINT 21H\n\t\n\tINT 3H\n\ncode ends\nend start\n\n\n\n(简答题)输入 4 位 10 进制数转换成压缩 BCD 码存入内存变量 TMP 中 \n我的答案：\n\n\ndata segment\ntmp dw 0000\ndata ends\ncode segment\nassume cs:code,ds:data\nstart: mov ax,0000\nmov ds,ax\nmov cx,4\nmov tmp,0\nn1:\nmov ah,01h\nint 21h\nSUB al,30h\nMOV AH,0\npush ax\nloop n1\n\nmov cx,4\nn2:\npop ax\nadd TMP,ax\nROL TMP,1\nROL TMP,1\nROL TMP,1\nROL TMP,1\n\nloop n2\n\n\nint 3\ncode ends\nend start\n\n\n参考答案:\ndata segment\ntmp dw ?\ndata ends\ncode segment\nassume cs:code,ds:data\nstart: mov ax,data\nmov ds,ax\nmov cx,4\nmov tmp,0\nn1: mov ah,01h\nint 21h\npush ax\ndec cx\njnz n1\nmov ch,4\nn3: mov cl,4\npop ax\nn2: shr ax,1\nrcr tmp,1\ndec cl \njnz n2\ndec ch\njnz n3\nint 3\ncode ends\nend start\n\n\n(简答题)输入 10 个字符如果输入的是 10 进制数则存入[30000h] 开始的单元\n注意对单个ASCII码进行操作，存放的寄存器应该是8位的哈（AX），如果换成AX可能造成意外的错误，可能是以为AH高位部位0。\n\n\ncode segment \nassume cs:code\nstart:\nmov ax,3000h\nmov ds,ax\nmov cx,10\nmov bx,0\nn2:\nmov ah,01h\nint 21h\ncmp al,30h\njl m1\ncmp al,39h\njg m1\nmov [bx],al\ninc bx\nm1:\nloop n2\nint 3h\ncode ends\nend start\n\n\n\n(简答题)延时显示 0-9 每次延时部分由子程序完成\nDATAS SEGMENT\nDATAS ENDS\nSTACKS SEGMENT\nSTACKS ENDS\nCODES SEGMENT\n    ASSUME CS:CODES,DS:DATAS,SS:STACKS\nSTART:\n    MOV AX,3000H\t\t\n    MOV DS,AX\n\tmov AL,30H\nn1:\n\tCALL DELAY\n\n\tCMP AL,39H\n\t\n\tJNZ\tn2\n\tMOV AL,30H\n\tn2:\n\tINC AL\n\tMOV DL,AL\n\tMOV AH,02H\n\tINT\t21H\n\t\t\n\tJMP n1\t\t\t;循环显示\t\n\t\t\nDELAY PROC\t\t\t;延时函数\n\t\tPUSH CX\n\t\tPUSH DX\n\t\tMOV\t\tDX,\t0H\n\tD2:\tMOV \tCX,0FH\n\tD1: DEC\t\tCX\n\t\tJNZ\t\tD1\n\t\tDEC\t\tDX\n\t\tJNZ\t\tD2\n\t\tPOP\t\tDX\n\t\tPOP\t\tCX\n\t\tRET\nDELAY ENDP\n \nCODES ENDS\n    END START\n\n\n\n(简答题)对内存中以 BCD 码形式存放的两 4 位十进制数进行加法 运算 \n代做\n\n (简答题)将 al 中的数据与 1234h 相加结果放在 ax 中\n\n\ncode segment\nassume\tcs:code\nstart:\n\nmov ah,0h\n\nadd ax,1234h\n\nint 3h\ncode ends\nend start\n\n","slug":"汇编刷题","date":"2021-12-28T13:09:27.000Z","categories_index":"课程学习","tags_index":"汇编","author_index":"祥瑞"},{"id":"ccbdde2afef607425cf6ff28788fd53a","title":"导出学习通题目详细步骤","content":"1、用电脑浏览器打开题目网站\n2、按下键盘的 F12按下后网页右边出现窗口\n\n3、点击源代码\n4、找到的这个文件\n5、右键这个文件选择”另存为”\n6、将保存下来的文件改名（改成word格式也就是后缀doc）\n改成这样就可以了\n\n7、然后用word打开就是了，导pdf啥的，你应该会哦，office二级都过了的带佬。🤣","slug":"导出学习通题目详细步骤","date":"2021-12-23T07:50:02.000Z","categories_index":"记录","tags_index":"taking","author_index":"祥瑞"},{"id":"4fd5af4139838304dc8887e270cbaf0f","title":"被””双引号包含的字符串","content":"char *p = “hello world!”;（仅作本人记录）结论：C语言中的双引号用来表示字符串字面量，编译为对应的内存地址。\nchar p = “hello world!”; 在这个声明中，*”hello world!”被存储在静态数据区，而且是全局的**，p仅仅就是个指针，指向这个区域。C函数执行完之后对栈区进行清除操作，对静态数据区和堆则没有，所以有着和malloc一样的作用。可以在子函数里面定义变量，返回主函数后仍然可以继续使用。\n前言：这只是我自己玩玩，因为比较低级，所以可能会让大家觉得浪费社区环境资源，但我这更多是为了自己记录哈。\n原因是我在观看韦东山老师的嵌入式课程时，发现老师输入的这段代码\nchar* p= “string”；\n\n什么？居然有这种操作。作为小菜鸡的我得看看什么情况。我得了解一下，😋😋😋😋。\n正文（废话）：OK!!    CSDN启动，搜索关键词**”c双引号”**，点开一个浏览量比较高的BLOG，该博主介绍到：\n\n\n\nC语言中的双引号用来表示字符串字面量，编译为对应的内存地址\n\n\n\nok，我又不知道了，字符串字面量是啥？\nCSDN启动（梅开二度）\n\n\n\n在计算机科学中，字面量（literal）是用于表达源代码中一个固定值的表示法（notation）。 几乎所有计算机编程语言都具有对基本值的字面量表示，诸如：整数、浮点数以及字符串；\n\n\n\n好，原来字面量是这个意思，和汇编的立即数很像嘛。\n到这里我应该是懂了，原来字符串字面量加上”“（双引号）之后，程序会把这个字面量的内存地址带出来。\n#include&lt;stdio.h>\nint main()\n&#123;\n    char* p = \"hello 2022!\\n\";\n    puts(p);\n\treturn 0;\n&#125;\n\n结果：\n\n完美！\n但我又再想哦，那个如果在一个子函数里面使用了这种用法，是否能将字符串变量返回给函数名呢？\n一般情况下，当我们在子函数里面，定义变量，那么这个变量的生命周期会随着这次函数的结束，而被释放掉，如果函数返回了这个变量的地址，回到主函数后使用它的时候，程序会报错。\n比如下面的例子：\n#include&lt;stdio.h>\nchar* ccc()\n&#123;\n    char *p;\n    sprintf(p,\"hello 2022!\");\n   return p;\n&#125;\nint main()\n&#123;\n    puts(ccc());\n\treturn 0;\n&#125;\n\n结果：\n\n因为char数组创建在栈区，函数运行完后会被释放，你就访问不到了。\n意思是:分段故障，段错误就是指访问的内存超过了系统所给这个程序的内存空间。就是因为我们子函数已经结束，它里面定义的变量已经结束了它的生命周期，其分配的地址（内存），也就被释放了，所以程序找不到这个地址，报错了。\n如何避免这个问题呢？通常来说，我们会动态分配内存，保证子函数结束后，变量的地址（内存）不会被释放。\n比如下面的例子：\n#include&lt;stdio.h>\nchar* ccc()\n&#123;\n    char *p;\n    p = (char*)malloc(sizeof(char)*20);\n    sprintf(p,\"hello 2022!\");\n   return p;\n&#125;\nint main()\n&#123;   \n    puts(ccc());\n\treturn 0;\n&#125;\n\n显示\n\n回到我们的主题来：\n\n\n\nC语言中的双引号用来表示字符串字面量，编译为对应的内存地址\n\n\n\n所以如果双引号包含字符字面量赋值给子函数的自变量，会成功嘛？\n#include&lt;stdio.h>\nchar* ccc()\n&#123;\n   char*  p = \"hello 2022!\\n\";\n   return p;\n&#125;\nint main()\n&#123;\n    puts(ccc());\n\treturn 0;\n&#125;\n\n结果：\n\n好耶！！果然能继续使用，没有随着子函数的结束而释放掉这个字符型变量的地址（内存），说明使用双引号包含字符型字面量时，是程序动态分配了这个字符字面量的内存，并把内容放入其中了。有着和malloc一样的作用。\n","slug":"被””双引号包含的字符串","date":"2021-12-22T12:00:57.000Z","categories_index":"taking","tags_index":"c","author_index":"祥瑞"},{"id":"a62551fd56e2837b6f4afeba433d6170","title":"通信原理","content":"&lt;&lt;现代通信原理&gt;&gt;，是我在大三上学期学习的课程，因为想混git的小绿点，以及记录一下，所以把复习（学习）笔记，上传到blog上面来了。\n🙂🙂🙂🙂🙂🙂\n现代通信原理\n\n根据学习通上老师设置的章节，可分为\n绪论、通信系统中的信号信道和噪声、模拟调制系统、差错控制编码、数值信号的频带传输、数值基带传输系统、模拟信号的数字传输这七个部分。\n1、第一张 绪论通信系统的主要性能指标：有效性和可靠性两种一般是不可兼得的\n有效性：指传输一定信息量时所占用的信道资源（频带宽度和时间间隔），或者是传输的“速度”，信源编码可以提高信息的有效性\n可靠性：指接受信息的准确程度，也就是传输的“质量”问题，信道编码可以提高信息的可靠性\n\n\n\n\n有效性\n可靠性\n\n\n\n模拟信号系统\n带宽\n频带利用率\n\n\n数字信号系统\n输出信噪比\n误码率、无信率\n\n\n信息及其度量\n信息出现的概率越小，信息量越大\n\n信息量的大小和概率的关系为：$$I=LOGa(1/P(x))-（单位是由a来确定的，一般情况下我们让a = 2，单位为bit/s。）$$\n\n\n两个速率：码元速率、信息传输速率码元速率的公式：$$RB = 1/Tb——（RB代表码元速率，单位Baud，Tb代表码元宽度s）$$信息速率（信息传输速率）的公式：$$Rb = I/t—(I代表一段时间传输的信息量，t代表这段时间长度，Rb代表信息传输速率)$$Rb与RB的关系：\n","slug":"通信原理","date":"2021-12-20T12:19:42.000Z","categories_index":"课程学习","tags_index":"信号","author_index":"祥瑞"},{"id":"c7c7d3f34d67a88be91b6acae917b627","title":"微机原理与接口技术复习笔记","content":"OK，这是在大三上学期的期末时，写的复习笔记，现在距离考试还有10天左右的时间，我得在这十天内把这学期学习的课程知识全部过一遍，并练一些编程题目。\n先把沈老师分享的脑图，记录一下\n脑图大纲\n\n这图上面除了右边的具体知识，还有左上角的tips，怎么学？ \n这是一个很重要的问题，有些时候，虽然我也想认真听课，但是，就是不知道怎么回事就开始出神了，当老师突然把我惊得反应回来，蓦然回首,我是谁？，我在哪儿？我在干什么？，这是一方面，上课没有很认真地听课；然后我觉得可能还有一点，就是没有进行大量地读写程序，汇编语言还是有一些语句地，需要去练习记忆。这也就对应了沈老师在图地左上方写到的怎么学：“大量地读写程序”，当然这最好建立在“理解””记忆“一些地基础上，不然会有些吃力。\n\n如何进行改述和总结，用你自己的话，尽可能简短地来表述作者的意思。\n\n如何进行改述和总结，用你自己的话，尽可能简短地来表述作者的意思。\n\n使用图表来说明， 尽可能多地将信息转化成符号或者图表。\n\n为知识点创造记忆方法，试着为自己出试题 。\n好像可能会不会跟着做但是还是记录一下吧，终归还是要一个目标的。🙂\n\n\n我大致计划，每看玩一个知识章节，自己去总结到这篇博客上，并且做相关练习都贴到这里。\n程序标配：code segement\nassume cs:code\nstart: \n;;你写的代码\ncode ends\n\tend\tstart\n\n\n\n一、计算机基础知识1、数据表达式补码：[相关脑图](数值 - 百度脑图 (baidu.com))\n重点：负数的补码求法：（因为正数的补码反码都和原码一样，所以不用特别记忆）\n​            先将它化为二进制数，也就是求到它的原码，然后符号位不变，数值位全部取反，最后加上“1”，就得到的它的补码。\n例如：求-50的补码\n方法一：\n\n-50的原码是50的原码的基础上，符号位为“1”，也就是0011 0010，这里使用8位数的原因是“计算机中的内存单元，一个直接有8为二进制”，所以-50的原码为：1011 0010\n符号位不变，数值位取反得到：1100 1101\n在上面的基础上加一，得到最后的结果为：1100 1110\n\n方法二：\n​        得到原码后，找到为1的最低位，然后将这一位到符号位的所有位全部取反，就可以得到，负数的补码了。\n例如：-50的原码    1011 0010，去符号位到最低的为“1”的位中间的位全部取反后得到：1100 1110。\n着两种方法都是可行的，当然第二种方法好是要简单一点哈。\n常用编码：\n\n\n编码名称\n例子\n说明\n\n\n\nASCII码\n40代表0\n使数字和字符能够在计算机中存储\n\n\n8421BCD码\n0000代表0\n计算机把十进制数转换成二进制数就要用到一种转换码，BCD码就是其中的一种。\n\n\n进制转换：十进制小数转化为二进制\n\n\n\n方法\n作用\n用法\n\n\n\n乘2法\n十进制小数化二进制\n乘2取整，顺序排列\n\n\n除2发\n十进制整数化二进制\n整数部分 除以2取余，逆序排列。\n\n\n例如：13.2化为二进制小数\n先求小数部分：\n0.2*2 = 0.4----------0\n0.4*2 = 0.8----------0\n0.8*2 = 1.6----------1\n0.6*2 = 1.2----------1\n0.2*2 = 0.4----------0\n0.3*2 = 0.8----------0\n0.8*2 = 1.6----------1\n0.6*2 = 1.2----------1\n    直到小数部分为0，或者发现是循环数\n    所以小数部分为：0.0011.....\n\n整数部分：\n13/2 = 6余1\n6/2  = 3余0\n3/2  = 1余1\n1/2  = 0余1\n \t直达整数部分为0\n    所以整数部分为：1011，其实我更倾向于自己去比较2的几次方，得出来。。\n\n\n\n2、存储与寻址地址表示：\n\n\n物理地址\n对于一个存储单元来说，它的物理地址是唯一的\n\n\n\n逻辑地址\n对于一个存储单元开始，它的逻辑地址是无数组，不同段基址和对于的偏移地址可以形成同一个物理地址\n\n\n$$物理地址 = 段地址 *10H + 偏移地址$$\n段地址（段基址）的英文简称：DS\n偏移地址（有效地址,段内地址）的英文简称：EA\n寻址方式：\n段寄存器\n\n\n\n有无BP\n段寄存器\n\n\n\n有\nSS\n\n\n无\nDS\n\n\n\n寻址类型\n\n\n\n寻址方式（源）\n格式\n说明\n\n\n\n立即寻址\nMOV AX,100H\n直接是一个常数数值\n\n\n寄存器寻址\nMOV BX,AX\n指令所需要的操作数在寄存器中\n\n\n直接寻址\nMOV AX,[100H]\n有一个中括号，里面是常数的偏移地址\n\n\n寄存器间接寻址\nMOV BX,[AX]\n有一个中括号，里面是寄存器\n\n\n寄存器相对寻址\nMOV AX，100H[SI]\n在寄存器间接寻址的基础上，加了一个常数\n\n\n基址加变址寻址\nMOV AL，[BX][SI]\n有两个寄存器\n\n\n相对基址加变址寻址\nMOVAL,[BX][SI]100H\n基址加变址寻址,加上一个常数\n\n\n3、变址寄存器和基址寄存器\n\n\n\n变址寄存器\nSI          DI\n\n\n\n基址寄存器\nBX         BP\n\n\nPS(容易错的题):\nMOV AL,DS:[1000]的源操作数是直接寻址\nMOV AL,DS,的源操作数是寄存器寻址\nMOV DS:[BP],AL    的目的操作数是寄存器间接寻址\n每个段最多有64kb，CS是代码段寄存器，IP是指令指针用于指向将要执行的指令。 \n已知一逻辑地址为：3000：1000，其段起始地址为：30000H\n\n\n3、寄存器\n\n\nAX\n累加器\n\n\n\nBX\n基址寄存器\n\n\nCX\n计数寄存器\n\n\nDX\n数据寄存器\n\n\nCS\n代码段寄存器\n\n\nDS\n数据段寄存器\n\n\nSS\n堆栈段寄存器\n\n\nES\n附加段寄存器\n\n\n\n\n\nBP\n基址指针\n\n\n\nSP\n堆栈指针\n\n\nSI\n源  变址寄存器\n\n\nDI\n目的   变址寄存器\n\n\n\n\n\nIP\n指令指针\n\n\n\nFR\n标志寄存器\n\n\n二、汇编语言1、数据传送指令MOV1、立即数不能向段寄存器赋值；\n2、只有通用寄存器能对调用寄存器赋值，也就是存储里面的数不能向存储器里面的数赋值，段寄存器也不能向段寄存器赋值。\n3、cs不能作为目的操作数\n4、两个操作数，至少有一个确定类型，立即数和存储器的数据类型都是不确定的。比如需要把一个存储数传到另一个存储器中，这个情况下可以先把源操作数传给寄存器，然后再传给目的操作数；或者采用语句指明源操作数或者目的操作数是字类型还是字节类型。\n限定为字节类型：    byte PTR ds:[1006h],01H                byte（字节）读音[baɪt]，bit（二进制位）\n限定为字类型：    WORD PTR ds:[1006h],01H\nLEA将源操作数的偏移地址赋值给寄存器,所以目的操作数是16位寄存器。\nPOP  PUSHpush后SP-2,pop后SP+2。\n栈底是高位。\nXCHG交换两个寄存器里面的值。不影响寄存器。\n2、运算指令\n\n\n指令\n作用\n示例\n\n\n\nADD\n加法，不带进位\nADD AX,BX\n\n\nADC\n加法，带进位\nADC AX,CX\n\n\nINC\n加一，不影响CF\nINC AX\n\n\nSUB\n减法，不带借位\nSUB AX,BX\n\n\nSBB\n减法，带借位\nSBB AX,BX\n\n\nDEC\n减一，不影响CF\nDEC AX\n\n\nCMP\n比较\nCMP AX,BX\n\n\nNEG\n求补\nNEG AX\n\n\nDAA:压缩BCD码，个位数放入AL的低四位，十位数放入AL的高四位\nAAA:将两个加数从ASCII码还原为十进制，然后相加，得到的数，将其高位放入AH中，低位放入AL中。\n3、程序流程控制指令条件跳转指令\n\n\n名称\n作用\n\n\n\nJZ\nZF为’1’的时候跳转\n\n\nJNZ\nZF为’0’的时候跳转\n\n\nJC\nCF为’1’的时候跳转\n\n\nJNC\nCF为‘0’的时候跳转\n\n\nJMP\n无条件跳转\n\n\n\n\n\n无符号整数运算\n作用\n\n\n\nJA/JNBE\n大于跳转\n\n\nJAE/JNB\n大于或等于跳转\n\n\nJB/JNAE\n小于跳转\n\n\nJBE/JNA\n小于或等于跳转\n\n\n\n\n\n有符号整数运算\n作用\n\n\n\nJG/JNLE\n大于跳转\n\n\nJGE/JNL\n大于或等于跳转\n\n\nJL/JNGE\n小于跳转\n\n\nJLE/JNG\n小于或等于的关于跳转\n\n\n\n\n\n循环控制指令\n说明\n\n\n\nLOOP\nCX 不为‘0‘时，\n\n\n4、逻辑运算与位操作逻辑运算指令\n\n\n指令名称\n作用\n用法\n\n\n\nNOT\n取反\n\n\n\nAND\n与\n\n\n\nXOR\n异或\n\n\n\nNXOR\n同或\n\n\n\nTEST\n测试\n\n\n\nOR\n或\n\n\n\n运算指令后\nCF=OF=0,SF,ZF按一般规则影响\n\n\n\n移位指令\n\n\n指令名称\n作用\n\n\n\nSHL_SHR逻辑\n把‘0’移入，移出到CF\n\n\nSAL_SAR算术\n左移时，低位补0；右移时，高位补符号位\n\n\nROL_ROR不带进位循环\n移出的位要放入cf的同时，也要放入空位\n\n\nRCL_RCR带进位循环\n空位放入CF的值，CF放入移出的值。\n\n\n三、接口技术1、总线与时序\n\n\n时钟周期\nCPU执行的最小时间单位\n\n\n\n总线周期\n4倍时钟周期\n\n\n指令周期\nCPU执行一条指令所需要的时间，不同指令t不一样，同一条指令寻址方式不一样，时间也不一样\n\n\n2、8085-A1、A0：端口选择信号输入引脚\n\n\nA1\nA0\n操作\n\n\n\n0\n0\nA口读或写\n\n\n0\n1\nB口读或写\n\n\n1\n0\nC口读或写\n\n\n1\n1\n\n\n\n3、内部结构由EU（执行单元）和BIU（总线接口部件）组成。\n\n\n\nEU\n通用寄存器、SP,BP,SI,DI这四个与地址相关的寄存器以及ALU（运算逻辑单元）、标志寄存器。。\n\n\n\nBIU\n段寄存器、IP。。。\n\n\n8255控制字：8254控制字：错题集：\n计算机有运算器、控制器、存储器和输入、输出五部分组成。\n\nIP存放指令的偏移地址\n\n总线接口部件BIU\n\n(单选题)以下哪个地址不可能是段起始地址  • A. 10h • B. 1000h • C. 11111h • D. 21000h 正确答案: \n（段起始地址的低四位必须是‘0’）\n\n16位寄存器一个有14个\n\n8086 不能出现在指令中的寄存器有2个，是IP和FR（标志寄存器）\n\n8086 中用于存放偏移地址的寄存器有BX BP SI DI  ,  IP SP一共6个,但是能出现在[]中的只有前 4 个\n\n0的8位补码是0000  0000 B\n\n字长是作为一个整体计算机一次最多可传送或运算的二进制位数\n\n一个指令周期包括几个机器周期,一个机器周期包括几个时钟周期。\n\n8086 地址累加器的位数是20位\n\nCPU 中运算器的功能主要是算术运算和逻辑运算\n\n8086 CPU 寄存器中,能在 I/O 寻址时用作地址寄存器的 是DX\n\nMOV AX,3000H，数据从代码段里面取出\n\n假定(SS)=2000H,(SP)=0100H,(AX)=2107H,执行指令 PUSH AX 后,存放数据 21H 的物理地址是200FF。\n\n从 PC3 输出一低电平置位复位控制字是6h\n\n从 PC6 输出一高电平置位复位控制字是ODH\n\n8255 有2个8位并行输入/输出端口,分为2组\n\n如果 8254 的输入信号是 1MHZ，从计数器 2 输出是 20HZ 周期性负脉冲，端口地址为 300H-303H 控制字是0B4H\n\n按键控制指示灯程序工作方式字是90h未使用的端口都 设为输出\n\nFLAG是标志寄存器，里面存放的CF,AF,OF,ZF啥的，它不能出现在指令中。\n\n查表指令XLAT,将存储在DS:[BX+AL]的数赋值给AL，没有操作数\n\n一些传送指令会影响状态标志位！！！！\n\nCF 判断的是无符号数、OF 判断的是符号数。\n\nA口可工作于方式0、方式1和方式2中的任一种B口可工作于方式0和方式1，但不能工作于方式2C口只能工作于方式0\n\n向 8254A 芯片中写入的计数初值,是写入初值寄存器\n\nCS:IP是程序的起始地址\n\n\n","slug":"微机原理与接口技术复习笔记","date":"2021-12-19T08:15:17.000Z","categories_index":"课程学习","tags_index":"汇编","author_index":"祥瑞"},{"id":"5ff3ed1096e2d71cb98e6d4ddf0126cd","title":"C_answer","content":"1001这道题主要的问题是需要考虑到输入错误的时候，不能继续输出，而是直接退出。\n考察了scanf的返回值，以及while的判断规则，以及按位取反的操作\nscanf的返回值——-它返回已成功赋值的数据项数；出错时则返回EOF；\n​                            （注：EOF(End Of File)是一个预定义的常量，等于-1.）\n这是一个常见的判断输入正确时，才继续执行的循环判断语句，这个~不是直接在十进制数上加一个负号，而是先把十进制转化为为二进制补码后，然后取反，再转化为10进制。\n#include&lt;stdio.h>\nint main()\n&#123;\n    int a=0,b=0;\n    while(scanf(\"%d%d\", &amp;a, &amp;b) == 2)   //下面有关于~的解析\n    &#123;\n        printf(\"%d\\n\",a+b);\n    &#125;    \n    return 0;\n&#125;\n\n\n这道题主要考察了 scanf  的返回值，输入正确时返回输入数据的个数。\n1002这道题可用擂台算法，安排1v1，打两局\n\n#include&lt;stdio.h>\nint main()&#123;\n    int a,b,c,max;\n    scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c);\n    if(a>b)\n        max=a;\n    else\n        max=b;\n    if(c>max)\n        max=c;\n    printf(\"%d\\n\",max);\n    return 0;\n&#125;\n\n1003[编程入门]密码破译\n需要ASCII码的知识，它是最通用的信息交换标准，在计算机中，所有的数据在存储和运算时都要使用二进制数表示，例如，像a、b、c、d这样的52个字母也需要用二进制来表示。\n\n\n然后字符串的的长度函数 strlen（）可以直接得到字符串的长度，但是需要包含**#include&lt;string.h&gt;**\n#include&lt;stdio.h>\n#include&lt;string.h>\nint main()\n&#123;\n\tchar m[10];\n\tint len;\n\tgets(m);\n\tlen = strlen(m);\n\tfor(int i = 0 ; i&lt;len ;i++)\n\t&#123;\n\t    m[i]+=4;\n\t&#125; \n\tputs(m);\n\treturn 0;\n&#125;\n\n\n\n1004[递归]母牛的故事\n递归类型的题目需要找：\n1、重复的\n2、边界\n\n\n\n年份\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n母牛数量\n1\n2\n3\n4\n6\n9\n13\n19\n28\n\n\n以上我们可以看出当年份大于等于4时，等于其前一年的加上前三年的。\n# include&lt;stdio.h>\nint fun(int n)\t\t\n&#123;\tif(n&lt;=3) return n;\n    else return fun(n-1)+fun(n-3);\n&#125;\nint main()\n&#123;\tint m[100];\n\tint n[100];\n\tint h;\n    while(1)&#123;\n\tfor(int i = 0; 1; i++) &#123;\n\t\t\tscanf(\"%d\",&amp;m[i]);\n\t\t\tn[i]=fun(m[i]);\n\t\t\tif (m[i] == 0) &#123; \n\t\t\t\th = i;\n\t\t\t\tbreak; &#125;\n\t\t&#125;\n\tfor(int i = 0 ; i &lt; h ; i++)\n\t&#123;\n\t\tprintf(\"%d\\n\",n[i]);\n\t&#125;&#125;\n    return 0;&#125;\n\n1005温度转换\n#include&lt;stdio.h>\nint main()\n&#123;\n\tfloat F,C;\n\tscanf(\"%f\",&amp;F);\n\tC = 5*(F-32)/9;\n\tprintf(\"c=%.2f\",C);\n\treturn 0;\n&#125;\n\n\n\n10071009#include&lt;stdio.h>\n#include&lt;string.h>\nint main()\n&#123;\n\tchar a[10];\n\tint lenth;\n\tgets(a);\n\n\n\tlenth = strlen(a);\n\tprintf(\"%d\\n\",lenth);\n\t\n\tfor(int i = 0 ; i&lt;lenth ; i++)&#123;\n\t    printf(\"%c \",a[i]);\n\t&#125;\n\tprintf(\"\\n\");\n\tfor(int i = lenth - 1 ; i > -1 ; i--)&#123;\n\t    printf(\"%c\",a[i]);\n\t&#125;\n\t\n\treturn 0;\n&#125;\n\n1011#include&lt;stdio.h>\nint main()\n&#123;\n\tint a,b;\n\tint gys,gbs;\n\tscanf(\"%d%d\",&amp;a,&amp;b);\n\tint c;\n\tif(a&lt;b) &#123; c = a; a = b; b = c;&#125;\n\tfor(int i = b ; i>0 ; i--)\n\t&#123;\n\t    if(a%i==0 &amp;&amp; b%i==0)\n\t    &#123;\n\t        gys = i;\n\t        break;\n\t    &#125;\n\t&#125;\n\tgbs = a*b/gys;\n\tprintf(\"%d %d\",gys,gbs);\n\treturn 0;\n&#125;\n\n1012头文件：&lt;ctype.h&gt;\n函数：\n  （1）int isalpha(int ch);\n​      判断ch是否为字母，如果是返回非0，反之返回0；\n  （2）int isdigit(int ch);\n​      判断ch是否为数字，如果是返回非0，反之返回0；\n  （3）int islower(int ch);\n​      判断ch是否为小写字母，如果是返回非0，反之返回0；\n  （4）int isupper(int ch);\n​      判断ch是否为大写字母，如果是返回非0，反之返回0；\n#include&lt;stdio.h>\n#include&lt;ctype.h>\nint main()\n&#123;\n\tchar CC[200];\n\tint zm = 0,num = 0,kg = 0,qita = 0;\n\tgets(CC);\n\tfor(int i ; CC[i] != '\\0' ; i++)\n\t&#123;\n\t    if(isalpha(CC[i])) zm++;\n\t    else if(isdigit(CC[i])) num++;\n\t    else if(CC[i] == ' ') kg++;\n\t    else qita++;\n\t&#125;\n\tprintf(\"%d %d %d %d\",zm,num,kg,qita);\n\treturn 0;\n&#125;\n\n","slug":"C-answer","date":"2021-12-17T04:47:05.000Z","categories_index":"","tags_index":"","author_index":"祥瑞"},{"id":"67977ad6f38d74e3fc06a55d029d9a0b","title":"C++核心编程","content":"C++核心编程PS:转载于“黑马程序员”！！！！！！仅因为个人原因，想随时查看相关资料而上传到个人博客的的。😂🤣🥓🥩🍔👼👲吧🤴🌮🍗🍩🥣🍨🍙🍮🧊🍻🥂🍽🍸🥢🏺🍇👨‍🦱👨‍🦳🕵️‍♀️🌮🧀🧈🌮🍙🍥🥧本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。\n1 内存分区模型C++程序在执行时，将内存大方向划分为4个区域\n\n代码区：存放函数体的二进制代码，由操作系统进行管理的\n全局区：存放全局变量和静态变量以及常量\n栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等\n堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收\n\n内存四区意义：\n不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n1.1 程序运行前​    在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域\n​    代码区：\n​        存放 CPU 执行的机器指令\n​        代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n​        代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令\n​    全局区：\n​        全局变量和静态变量存放在此.\n​        全局区还包含了常量区, 字符串常量和其他常量也存放在此.\n​        ==该区域的数据在程序结束后由操作系统释放==.\n示例：\n&#x2F;&#x2F;全局变量\nint g_a &#x3D; 10;\nint g_b &#x3D; 10;\n\n&#x2F;&#x2F;全局常量\nconst int c_g_a &#x3D; 10;\nconst int c_g_b &#x3D; 10;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;局部变量\n\tint a &#x3D; 10;\n\tint b &#x3D; 10;\n\n\t&#x2F;&#x2F;打印地址\n\tcout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt;  (int)&amp;g_a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt;  (int)&amp;g_b &lt;&lt; endl;\n\n\t&#x2F;&#x2F;静态变量\n\tstatic int s_a &#x3D; 10;\n\tstatic int s_b &#x3D; 10;\n\n\tcout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;\n\n\tconst int c_l_a &#x3D; 10;\n\tconst int c_l_b &#x3D; 10;\n\tcout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n打印结果：\n\n总结：\n\nC++中在程序运行前分为全局区和代码区\n代码区特点是共享和只读\n全局区中存放全局变量、静态变量、常量\n常量区中存放 const修饰的全局常量  和 字符串常量\n\n1.2 程序运行后​    栈区：\n​        由编译器自动分配释放, 存放函数的参数值,局部变量等\n​        注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n示例：\nint * func()\n&#123;\n\tint a &#x3D; 10;\n\treturn &amp;a;\n&#125;\n\nint main() &#123;\n\n\tint *p &#x3D; func();\n\n\tcout &lt;&lt; *p &lt;&lt; endl;\n\tcout &lt;&lt; *p &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n​    堆区：\n​        由程序员分配释放,若程序员不释放,程序结束时由操作系统回收\n​        在C++中主要利用new在堆区开辟内存\n示例：\nint* func()\n&#123;\n\tint* a &#x3D; new int(10);\n\treturn a;\n&#125;\n\nint main() &#123;\n\n\tint *p &#x3D; func();\n\n\tcout &lt;&lt; *p &lt;&lt; endl;\n\tcout &lt;&lt; *p &lt;&lt; endl;\n    \n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n总结：\n堆区数据由程序员管理开辟和释放\n堆区数据利用new关键字进行开辟内存\n1.3 new操作符​    C++中利用==new==操作符在堆区开辟数据\n​    堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==\n​    语法： new 数据类型\n​    利用new创建的数据，会返回该数据对应的类型的指针\n示例1： 基本语法\nint* func()\n&#123;\n\tint* a &#x3D; new int(10);\n\treturn a;\n&#125;\n\nint main() &#123;\n\n\tint *p &#x3D; func();\n\n\tcout &lt;&lt; *p &lt;&lt; endl;\n\tcout &lt;&lt; *p &lt;&lt; endl;\n\n\t&#x2F;&#x2F;利用delete释放堆区数据\n\tdelete p;\n\n\t&#x2F;&#x2F;cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;报错，释放的空间不可访问\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n示例2：开辟数组\n&#x2F;&#x2F;堆区开辟数组\nint main() &#123;\n\n\tint* arr &#x3D; new int[10];\n\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tarr[i] &#x3D; i + 100;\n\t&#125;\n\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tcout &lt;&lt; arr[i] &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;释放数组 delete 后加 []\n\tdelete[] arr;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n2 引用2.1 引用的基本使用**作用： **给变量起别名\n语法： 数据类型 &amp;别名 = 原名\n示例：\nint main() &#123;\n\n\tint a &#x3D; 10;\n\tint &amp;b &#x3D; a;\n\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\n\tb &#x3D; 100;\n\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n2.2 引用注意事项\n引用必须初始化\n引用在初始化后，不可以改变\n\n示例：\nint main() &#123;\n\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\t&#x2F;&#x2F;int &amp;c; &#x2F;&#x2F;错误，引用必须初始化\n\tint &amp;c &#x3D; a; &#x2F;&#x2F;一旦初始化后，就不可以更改\n\tc &#x3D; b; &#x2F;&#x2F;这是赋值操作，不是更改引用\n\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\tcout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n2.3 引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参\n优点：可以简化指针修改实参\n示例：\n&#x2F;&#x2F;1. 值传递\nvoid mySwap01(int a, int b) &#123;\n\tint temp &#x3D; a;\n\ta &#x3D; b;\n\tb &#x3D; temp;\n&#125;\n\n&#x2F;&#x2F;2. 地址传递\nvoid mySwap02(int* a, int* b) &#123;\n\tint temp &#x3D; *a;\n\t*a &#x3D; *b;\n\t*b &#x3D; temp;\n&#125;\n\n&#x2F;&#x2F;3. 引用传递\nvoid mySwap03(int&amp; a, int&amp; b) &#123;\n\tint temp &#x3D; a;\n\ta &#x3D; b;\n\tb &#x3D; temp;\n&#125;\n\nint main() &#123;\n\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\n\tmySwap01(a, b);\n\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\n\tmySwap02(&amp;a, &amp;b);\n\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\n\tmySwap03(a, b);\n\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单\n2.4 引用做函数返回值作用：引用是可以作为函数的返回值存在的\n注意：不要返回局部变量引用\n用法：函数调用作为左值\n示例：\n&#x2F;&#x2F;返回局部变量引用\nint&amp; test01() &#123;\n\tint a &#x3D; 10; &#x2F;&#x2F;局部变量\n\treturn a;\n&#125;\n\n&#x2F;&#x2F;返回静态变量引用\nint&amp; test02() &#123;\n\tstatic int a &#x3D; 20;\n\treturn a;\n&#125;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;不能返回局部变量的引用\n\tint&amp; ref &#x3D; test01();\n\tcout &lt;&lt; &quot;ref &#x3D; &quot; &lt;&lt; ref &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref &#x3D; &quot; &lt;&lt; ref &lt;&lt; endl;\n\n\t&#x2F;&#x2F;如果函数做左值，那么必须返回引用\n\tint&amp; ref2 &#x3D; test02();\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\n\ttest02() &#x3D; 1000;\n\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n​    \n2.5 引用的本质本质：引用的本质在c++内部实现是一个指针常量.\n讲解示例：\n&#x2F;&#x2F;发现是引用，转换为 int* const ref &#x3D; &amp;a;\nvoid func(int&amp; ref)&#123;\n\tref &#x3D; 100; &#x2F;&#x2F; ref是引用，转换为*ref &#x3D; 100\n&#125;\nint main()&#123;\n\tint a &#x3D; 10;\n    \n    &#x2F;&#x2F;自动转换为 int* const ref &#x3D; &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改\n\tint&amp; ref &#x3D; a; \n\tref &#x3D; 20; &#x2F;&#x2F;内部发现ref是引用，自动帮我们转换为: *ref &#x3D; 20;\n    \n\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;\n    \n\tfunc(a);\n\treturn 0;\n&#125;\n\n结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\n2.6 常量引用作用：常量引用主要用来修饰形参，防止误操作\n在函数形参列表中，可以加==const修饰形参==，防止形参改变实参\n示例：\n&#x2F;&#x2F;引用使用的场景，通常用来修饰形参\nvoid showValue(const int&amp; v) &#123;\n\t&#x2F;&#x2F;v +&#x3D; 10;\n\tcout &lt;&lt; v &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;int&amp; ref &#x3D; 10;  引用本身需要一个合法的内存空间，因此这行错误\n\t&#x2F;&#x2F;加入const就可以了，编译器优化代码，int temp &#x3D; 10; const int&amp; ref &#x3D; temp;\n\tconst int&amp; ref &#x3D; 10;\n\n\t&#x2F;&#x2F;ref &#x3D; 100;  &#x2F;&#x2F;加入const后不可以修改变量\n\tcout &lt;&lt; ref &lt;&lt; endl;\n\n\t&#x2F;&#x2F;函数中利用常量引用防止误操作修改实参\n\tint a &#x3D; 10;\n\tshowValue(a);\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n3 函数提高3.1 函数默认参数在C++中，函数的形参列表中的形参是可以有默认值的。\n语法： 返回值类型  函数名 （参数= 默认值）&#123;&#125;\n示例：\nint func(int a, int b &#x3D; 10, int c &#x3D; 10) &#123;\n\treturn a + b + c;\n&#125;\n\n&#x2F;&#x2F;1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值\n&#x2F;&#x2F;2. 如果函数声明有默认值，函数实现的时候就不能有默认参数\nint func2(int a &#x3D; 10, int b &#x3D; 10);\nint func2(int a, int b) &#123;\n\treturn a + b;\n&#125;\n\nint main() &#123;\n\n\tcout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; func(100) &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n3.2 函数占位参数C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n语法： 返回值类型 函数名 (数据类型)&#123;&#125;\n在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术\n示例：\n&#x2F;&#x2F;函数占位参数 ，占位参数也可以有默认参数\nvoid func(int a, int) &#123;\n\tcout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\tfunc(10,10); &#x2F;&#x2F;占位参数必须填补\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n3.3 函数重载3.3.1 函数重载概述作用：函数名可以相同，提高复用性\n函数重载满足条件：\n\n同一个作用域下\n函数名称相同\n函数参数类型不同  或者 个数不同 或者 顺序不同\n\n注意:  函数的返回值不可以作为函数重载的条件\n示例：\n&#x2F;&#x2F;函数重载需要函数都在同一个作用域下\nvoid func()\n&#123;\n\tcout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl;\n&#125;\nvoid func(int a)\n&#123;\n\tcout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl;\n&#125;\nvoid func(double a)\n&#123;\n\tcout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl;\n&#125;\nvoid func(int a ,double b)\n&#123;\n\tcout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl;\n&#125;\nvoid func(double a ,int b)\n&#123;\n\tcout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;函数返回值不可以作为函数重载条件\n&#x2F;&#x2F;int func(double a, int b)\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;\tcout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;\n&#x2F;&#x2F;&#125;\n\n\nint main() &#123;\n\n\tfunc();\n\tfunc(10);\n\tfunc(3.14);\n\tfunc(10,3.14);\n\tfunc(3.14 , 10);\n\t\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.3.2 函数重载注意事项\n引用作为重载条件\n函数重载碰到函数默认参数\n\n示例：\n&#x2F;&#x2F;函数重载注意事项\n&#x2F;&#x2F;1、引用作为重载条件\n\nvoid func(int &amp;a)\n&#123;\n\tcout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl;\n&#125;\n\nvoid func(const int &amp;a)\n&#123;\n\tcout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl;\n&#125;\n\n\n&#x2F;&#x2F;2、函数重载碰到函数默认参数\n\nvoid func2(int a, int b &#x3D; 10)\n&#123;\n\tcout &lt;&lt; &quot;func2(int a, int b &#x3D; 10) 调用&quot; &lt;&lt; endl;\n&#125;\n\nvoid func2(int a)\n&#123;\n\tcout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\t\n\tint a &#x3D; 10;\n\tfunc(a); &#x2F;&#x2F;调用无const\n\tfunc(10);&#x2F;&#x2F;调用有const\n\n\n\t&#x2F;&#x2F;func2(10); &#x2F;&#x2F;碰到默认参数产生歧义，需要避免\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n4 类和对象C++面向对象的三大特性为：==封装、继承、多态==\nC++认为==万事万物都皆为对象==，对象上有其属性和行为\n例如：\n​    人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…\n​    车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…\n​    具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类\n4.1 封装4.1.1  封装的意义封装是C++面向对象三大特性之一\n封装的意义：\n\n将属性和行为作为一个整体，表现生活中的事物\n将属性和行为加以权限控制\n\n封装意义一：\n​    在设计类的时候，属性和行为写在一起，表现事物\n语法： class 类名&#123;   访问权限： 属性  / 行为  &#125;;\n示例1：设计一个圆类，求圆的周长\n示例代码：\n&#x2F;&#x2F;圆周率\nconst double PI &#x3D; 3.14;\n\n&#x2F;&#x2F;1、封装的意义\n&#x2F;&#x2F;将属性和行为作为一个整体，用来表现生活中的事物\n\n&#x2F;&#x2F;封装一个圆类，求圆的周长\n&#x2F;&#x2F;class代表设计一个类，后面跟着的是类名\nclass Circle\n&#123;\npublic:  &#x2F;&#x2F;访问权限  公共的权限\n\n\t&#x2F;&#x2F;属性\n\tint m_r;&#x2F;&#x2F;半径\n\n\t&#x2F;&#x2F;行为\n\t&#x2F;&#x2F;获取到圆的周长\n\tdouble calculateZC()\n\t&#123;\n\t\t&#x2F;&#x2F;2 * pi  * r\n\t\t&#x2F;&#x2F;获取圆的周长\n\t\treturn  2 * PI * m_r;\n\t&#125;\n&#125;;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;通过圆类，创建圆的对象\n\t&#x2F;&#x2F; c1就是一个具体的圆\n\tCircle c1;\n\tc1.m_r &#x3D; 10; &#x2F;&#x2F;给圆对象的半径 进行赋值操作\n\n\t&#x2F;&#x2F;2 * pi * 10 &#x3D; &#x3D; 62.8\n\tcout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号\n示例2代码：\n&#x2F;&#x2F;学生类\nclass Student &#123;\npublic:\n\tvoid setName(string name) &#123;\n\t\tm_name &#x3D; name;\n\t&#125;\n\tvoid setID(int id) &#123;\n\t\tm_id &#x3D; id;\n\t&#125;\n\n\tvoid showStudent() &#123;\n\t\tcout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;\n\t&#125;\npublic:\n\tstring m_name;\n\tint m_id;\n&#125;;\n\nint main() &#123;\n\n\tStudent stu;\n\tstu.setName(&quot;德玛西亚&quot;);\n\tstu.setID(250);\n\tstu.showStudent();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n封装意义二：\n类在设计时，可以把属性和行为放在不同的权限下，加以控制\n访问权限有三种：\n\npublic        公共权限  \nprotected 保护权限\nprivate      私有权限\n\n示例：\n&#x2F;&#x2F;三种权限\n&#x2F;&#x2F;公共权限  public     类内可以访问  类外可以访问\n&#x2F;&#x2F;保护权限  protected  类内可以访问  类外不可以访问\n&#x2F;&#x2F;私有权限  private    类内可以访问  类外不可以访问\n\nclass Person\n&#123;\n\t&#x2F;&#x2F;姓名  公共权限\npublic:\n\tstring m_Name;\n\n\t&#x2F;&#x2F;汽车  保护权限\nprotected:\n\tstring m_Car;\n\n\t&#x2F;&#x2F;银行卡密码  私有权限\nprivate:\n\tint m_Password;\n\npublic:\n\tvoid func()\n\t&#123;\n\t\tm_Name &#x3D; &quot;张三&quot;;\n\t\tm_Car &#x3D; &quot;拖拉机&quot;;\n\t\tm_Password &#x3D; 123456;\n\t&#125;\n&#125;;\n\nint main() &#123;\n\n\tPerson p;\n\tp.m_Name &#x3D; &quot;李四&quot;;\n\t&#x2F;&#x2F;p.m_Car &#x3D; &quot;奔驰&quot;;  &#x2F;&#x2F;保护权限类外访问不到\n\t&#x2F;&#x2F;p.m_Password &#x3D; 123; &#x2F;&#x2F;私有权限类外访问不到\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n4.1.2 struct和class区别在C++中 struct和class唯一的区别就在于 默认的访问权限不同\n区别：\n\nstruct 默认权限为公共\nclass   默认权限为私有\n\nclass C1\n&#123;\n\tint  m_A; &#x2F;&#x2F;默认是私有权限\n&#125;;\n\nstruct C2\n&#123;\n\tint m_A;  &#x2F;&#x2F;默认是公共权限\n&#125;;\n\nint main() &#123;\n\n\tC1 c1;\n\tc1.m_A &#x3D; 10; &#x2F;&#x2F;错误，访问权限是私有\n\n\tC2 c2;\n\tc2.m_A &#x3D; 10; &#x2F;&#x2F;正确，访问权限是公共\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.1.3 成员属性设置为私有优点1：将所有成员属性设置为私有，可以自己控制读写权限\n优点2：对于写权限，我们可以检测数据的有效性\n示例：\nclass Person &#123;\npublic:\n\n\t&#x2F;&#x2F;姓名设置可读可写\n\tvoid setName(string name) &#123;\n\t\tm_Name &#x3D; name;\n\t&#125;\n\tstring getName()\n\t&#123;\n\t\treturn m_Name;\n\t&#125;\n\n\n\t&#x2F;&#x2F;获取年龄 \n\tint getAge() &#123;\n\t\treturn m_Age;\n\t&#125;\n\t&#x2F;&#x2F;设置年龄\n\tvoid setAge(int age) &#123;\n\t\tif (age &lt; 0 || age &gt; 150) &#123;\n\t\t\tcout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;\n\t\t\treturn;\n\t\t&#125;\n\t\tm_Age &#x3D; age;\n\t&#125;\n\n\t&#x2F;&#x2F;情人设置为只写\n\tvoid setLover(string lover) &#123;\n\t\tm_Lover &#x3D; lover;\n\t&#125;\n\nprivate:\n\tstring m_Name; &#x2F;&#x2F;可读可写  姓名\n\t\n\tint m_Age; &#x2F;&#x2F;只读  年龄\n\n\tstring m_Lover; &#x2F;&#x2F;只写  情人\n&#125;;\n\n\nint main() &#123;\n\n\tPerson p;\n\t&#x2F;&#x2F;姓名设置\n\tp.setName(&quot;张三&quot;);\n\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;\n\n\t&#x2F;&#x2F;年龄设置\n\tp.setAge(50);\n\tcout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;\n\n\t&#x2F;&#x2F;情人设置\n\tp.setLover(&quot;苍井&quot;);\n\t&#x2F;&#x2F;cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  &#x2F;&#x2F;只写属性，不可以读取\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n练习案例1：设计立方体类\n设计立方体类(Cube)\n求出立方体的面积和体积\n分别用全局函数和成员函数判断两个立方体是否相等。\n\n练习案例2：点和圆的关系\n设计一个圆形类（Circle），和一个点类（Point），计算点和圆的关系。\n\n4.2 对象的初始化和清理\n 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全\n C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。\n\n4.2.1 构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题\n​    一个对象或者变量没有初始状态，对其使用后果是未知\n​    同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题\nc++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供\n编译器提供的构造函数和析构函数是空实现。\n\n构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。\n析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。\n\n构造函数语法：类名()&#123;&#125;\n\n构造函数，没有返回值也不写void\n函数名称与类名相同\n构造函数可以有参数，因此可以发生重载\n程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次\n\n析构函数语法： ~类名()&#123;&#125;\n\n析构函数，没有返回值也不写void\n函数名称与类名相同,在名称前加上符号  ~\n析构函数不可以有参数，因此不可以发生重载\n程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次\n\nclass Person\n&#123;\npublic:\n\t&#x2F;&#x2F;构造函数\n\tPerson()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;析构函数\n\t~Person()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n\nvoid test01()\n&#123;\n\tPerson p;\n&#125;\n\nint main() &#123;\n\t\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n4.2.2 构造函数的分类及调用两种分类方式：\n​    按参数分为： 有参构造和无参构造\n​    按类型分为： 普通构造和拷贝构造\n三种调用方式：\n​    括号法\n​    显示法\n​    隐式转换法\n示例：\n&#x2F;&#x2F;1、构造函数分类\n&#x2F;&#x2F; 按照参数分类分为 有参和无参构造   无参又称为默认构造函数\n&#x2F;&#x2F; 按照类型分类分为 普通构造和拷贝构造\n\nclass Person &#123;\npublic:\n\t&#x2F;&#x2F;无参（默认）构造函数\n\tPerson() &#123;\n\t\tcout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;有参构造函数\n\tPerson(int a) &#123;\n\t\tage &#x3D; a;\n\t\tcout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;拷贝构造函数\n\tPerson(const Person&amp; p) &#123;\n\t\tage &#x3D; p.age;\n\t\tcout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;析构函数\n\t~Person() &#123;\n\t\tcout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n\t&#125;\npublic:\n\tint age;\n&#125;;\n\n&#x2F;&#x2F;2、构造函数的调用\n&#x2F;&#x2F;调用无参构造函数\nvoid test01() &#123;\n\tPerson p; &#x2F;&#x2F;调用无参构造函数\n&#125;\n\n&#x2F;&#x2F;调用有参的构造函数\nvoid test02() &#123;\n\n\t&#x2F;&#x2F;2.1  括号法，常用\n\tPerson p1(10);\n\t&#x2F;&#x2F;注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n\t&#x2F;&#x2F;Person p2();\n\n\t&#x2F;&#x2F;2.2 显式法\n\tPerson p2 &#x3D; Person(10); \n\tPerson p3 &#x3D; Person(p2);\n\t&#x2F;&#x2F;Person(10)单独写就是匿名对象  当前行结束之后，马上析构\n\n\t&#x2F;&#x2F;2.3 隐式转换法\n\tPerson p4 &#x3D; 10; &#x2F;&#x2F; Person p4 &#x3D; Person(10); \n\tPerson p5 &#x3D; p4; &#x2F;&#x2F; Person p5 &#x3D; Person(p4); \n\n\t&#x2F;&#x2F;注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\n\t&#x2F;&#x2F;Person p5(p4);\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\t&#x2F;&#x2F;test02();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n4.2.3 拷贝构造函数调用时机C++中拷贝构造函数调用时机通常有三种情况\n\n使用一个已经创建完毕的对象来初始化一个新对象\n值传递的方式给函数参数传值\n以值方式返回局部对象\n\n示例：\nclass Person &#123;\npublic:\n\tPerson() &#123;\n\t\tcout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\n\t\tmAge &#x3D; 0;\n\t&#125;\n\tPerson(int age) &#123;\n\t\tcout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\n\t\tmAge &#x3D; age;\n\t&#125;\n\tPerson(const Person&amp; p) &#123;\n\t\tcout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n\t\tmAge &#x3D; p.mAge;\n\t&#125;\n\t&#x2F;&#x2F;析构函数在释放内存之前调用\n\t~Person() &#123;\n\t\tcout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n\t&#125;\npublic:\n\tint mAge;\n&#125;;\n\n&#x2F;&#x2F;1. 使用一个已经创建完毕的对象来初始化一个新对象\nvoid test01() &#123;\n\n\tPerson man(100); &#x2F;&#x2F;p对象已经创建完毕\n\tPerson newman(man); &#x2F;&#x2F;调用拷贝构造函数\n\tPerson newman2 &#x3D; man; &#x2F;&#x2F;拷贝构造\n\n\t&#x2F;&#x2F;Person newman3;\n\t&#x2F;&#x2F;newman3 &#x3D; man; &#x2F;&#x2F;不是调用拷贝构造函数，赋值操作\n&#125;\n\n&#x2F;&#x2F;2. 值传递的方式给函数参数传值\n&#x2F;&#x2F;相当于Person p1 &#x3D; p;\nvoid doWork(Person p1) &#123;&#125;\nvoid test02() &#123;\n\tPerson p; &#x2F;&#x2F;无参构造函数\n\tdoWork(p);\n&#125;\n\n&#x2F;&#x2F;3. 以值方式返回局部对象\nPerson doWork2()\n&#123;\n\tPerson p1;\n\tcout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;\n\treturn p1;\n&#125;\n\nvoid test03()\n&#123;\n\tPerson p &#x3D; doWork2();\n\tcout &lt;&lt; (int *)&amp;p &lt;&lt; endl;\n&#125;\n\n\nint main() &#123;\n\n\t&#x2F;&#x2F;test01();\n\t&#x2F;&#x2F;test02();\n\ttest03();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n4.2.4 构造函数调用规则默认情况下，c++编译器至少给一个类添加3个函数\n1．默认构造函数(无参，函数体为空)\n2．默认析构函数(无参，函数体为空)\n3．默认拷贝构造函数，对属性进行值拷贝\n构造函数调用规则如下：\n\n如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造\n\n\n如果用户定义拷贝构造函数，c++不会再提供其他构造函数\n\n示例：\nclass Person &#123;\npublic:\n\t&#x2F;&#x2F;无参（默认）构造函数\n\tPerson() &#123;\n\t\tcout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;有参构造函数\n\tPerson(int a) &#123;\n\t\tage &#x3D; a;\n\t\tcout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;拷贝构造函数\n\tPerson(const Person&amp; p) &#123;\n\t\tage &#x3D; p.age;\n\t\tcout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;析构函数\n\t~Person() &#123;\n\t\tcout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n\t&#125;\npublic:\n\tint age;\n&#125;;\n\nvoid test01()\n&#123;\n\tPerson p1(18);\n\t&#x2F;&#x2F;如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作\n\tPerson p2(p1);\n\n\tcout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;\n&#125;\n\nvoid test02()\n&#123;\n\t&#x2F;&#x2F;如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造\n\tPerson p1; &#x2F;&#x2F;此时如果用户自己没有提供默认构造，会出错\n\tPerson p2(10); &#x2F;&#x2F;用户提供的有参\n\tPerson p3(p2); &#x2F;&#x2F;此时如果用户没有提供拷贝构造，编译器会提供\n\n\t&#x2F;&#x2F;如果用户提供拷贝构造，编译器不会提供其他构造函数\n\tPerson p4; &#x2F;&#x2F;此时如果用户自己没有提供默认构造，会出错\n\tPerson p5(10); &#x2F;&#x2F;此时如果用户自己没有提供有参，会出错\n\tPerson p6(p5); &#x2F;&#x2F;用户自己提供拷贝构造\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n4.2.5 深拷贝与浅拷贝深浅拷贝是面试经典问题，也是常见的一个坑\n浅拷贝：简单的赋值拷贝操作\n深拷贝：在堆区重新申请空间，进行拷贝操作\n示例：\nclass Person &#123;\npublic:\n\t&#x2F;&#x2F;无参（默认）构造函数\n\tPerson() &#123;\n\t\tcout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;有参构造函数\n\tPerson(int age ,int height) &#123;\n\t\t\n\t\tcout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\n\n\t\tm_age &#x3D; age;\n\t\tm_height &#x3D; new int(height);\n\t\t\n\t&#125;\n\t&#x2F;&#x2F;拷贝构造函数  \n\tPerson(const Person&amp; p) &#123;\n\t\tcout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n\t\t&#x2F;&#x2F;如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\n\t\tm_age &#x3D; p.m_age;\n\t\tm_height &#x3D; new int(*p.m_height);\n\t\t\n\t&#125;\n\n\t&#x2F;&#x2F;析构函数\n\t~Person() &#123;\n\t\tcout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n\t\tif (m_height !&#x3D; NULL)\n\t\t&#123;\n\t\t\tdelete m_height;\n\t\t&#125;\n\t&#125;\npublic:\n\tint m_age;\n\tint* m_height;\n&#125;;\n\nvoid test01()\n&#123;\n\tPerson p1(18, 180);\n\n\tPerson p2(p1);\n\n\tcout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n4.2.6 初始化列表作用：\nC++提供了初始化列表语法，用来初始化属性\n语法：构造函数()：属性1(值1),属性2（值2）... &#123;&#125;\n示例：\nclass Person &#123;\npublic:\n\n\t&#x2F;&#x2F;&#x2F;&#x2F;传统方式初始化\n\t&#x2F;&#x2F;Person(int a, int b, int c) &#123;\n\t&#x2F;&#x2F;\tm_A &#x3D; a;\n\t&#x2F;&#x2F;\tm_B &#x3D; b;\n\t&#x2F;&#x2F;\tm_C &#x3D; c;\n\t&#x2F;&#x2F;&#125;\n\n\t&#x2F;&#x2F;初始化列表方式初始化\n\tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125;\n\tvoid PrintPerson() &#123;\n\t\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;\n\t\tcout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;\n\t\tcout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;\n\t&#125;\nprivate:\n\tint m_A;\n\tint m_B;\n\tint m_C;\n&#125;;\n\nint main() &#123;\n\n\tPerson p(1, 2, 3);\n\tp.PrintPerson();\n\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n4.2.7 类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员\n例如：\nclass A &#123;&#125;\nclass B\n&#123;\n    A a；\n&#125;\n\n\n\nB类中有对象A作为成员，A为对象成员\n那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？\n示例：\nclass Phone\n&#123;\npublic:\n\tPhone(string name)\n\t&#123;\n\t\tm_PhoneName &#x3D; name;\n\t\tcout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl;\n\t&#125;\n\n\t~Phone()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;\n\t&#125;\n\n\tstring m_PhoneName;\n\n&#125;;\n\n\nclass Person\n&#123;\npublic:\n\n\t&#x2F;&#x2F;初始化列表可以告诉编译器调用哪一个构造函数\n\tPerson(string name, string pName) :m_Name(name), m_Phone(pName)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;\n\t&#125;\n\n\t~Person()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;\n\t&#125;\n\n\tvoid playGame()\n\t&#123;\n\t\tcout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;\n\t&#125;\n\n\tstring m_Name;\n\tPhone m_Phone;\n\n&#125;;\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;当类中成员是其他类对象时，我们称该成员为 对象成员\n\t&#x2F;&#x2F;构造的顺序是 ：先调用对象成员的构造，再调用本类构造\n\t&#x2F;&#x2F;析构顺序与构造相反\n\tPerson p(&quot;张三&quot; , &quot;苹果X&quot;);\n\tp.playGame();\n\n&#125;\n\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n4.2.8 静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\n静态成员分为：\n\n静态成员变量\n 所有对象共享同一份数据\n 在编译阶段分配内存\n 类内声明，类外初始化\n\n\n静态成员函数\n 所有对象共享同一个函数\n 静态成员函数只能访问静态成员变量\n\n\n\n示例1 ：静态成员变量\nclass Person\n&#123;\n\t\npublic:\n\n\tstatic int m_A; &#x2F;&#x2F;静态成员变量\n\n\t&#x2F;&#x2F;静态成员变量特点：\n\t&#x2F;&#x2F;1 在编译阶段分配内存\n\t&#x2F;&#x2F;2 类内声明，类外初始化\n\t&#x2F;&#x2F;3 所有对象共享同一份数据\n\nprivate:\n\tstatic int m_B; &#x2F;&#x2F;静态成员变量也是有访问权限的\n&#125;;\nint Person::m_A &#x3D; 10;\nint Person::m_B &#x3D; 10;\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;静态成员变量两种访问方式\n\n\t&#x2F;&#x2F;1、通过对象\n\tPerson p1;\n\tp1.m_A &#x3D; 100;\n\tcout &lt;&lt; &quot;p1.m_A &#x3D; &quot; &lt;&lt; p1.m_A &lt;&lt; endl;\n\n\tPerson p2;\n\tp2.m_A &#x3D; 200;\n\tcout &lt;&lt; &quot;p1.m_A &#x3D; &quot; &lt;&lt; p1.m_A &lt;&lt; endl; &#x2F;&#x2F;共享同一份数据\n\tcout &lt;&lt; &quot;p2.m_A &#x3D; &quot; &lt;&lt; p2.m_A &lt;&lt; endl;\n\n\t&#x2F;&#x2F;2、通过类名\n\tcout &lt;&lt; &quot;m_A &#x3D; &quot; &lt;&lt; Person::m_A &lt;&lt; endl;\n\n\n\t&#x2F;&#x2F;cout &lt;&lt; &quot;m_B &#x3D; &quot; &lt;&lt; Person::m_B &lt;&lt; endl; &#x2F;&#x2F;私有权限访问不到\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n示例2：静态成员函数\nclass Person\n&#123;\n\npublic:\n\n\t&#x2F;&#x2F;静态成员函数特点：\n\t&#x2F;&#x2F;1 程序共享一个函数\n\t&#x2F;&#x2F;2 静态成员函数只能访问静态成员变量\n\t\n\tstatic void func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;\n\t\tm_A &#x3D; 100;\n\t\t&#x2F;&#x2F;m_B &#x3D; 100; &#x2F;&#x2F;错误，不可以访问非静态成员变量\n\t&#125;\n\n\tstatic int m_A; &#x2F;&#x2F;静态成员变量\n\tint m_B; &#x2F;&#x2F; \nprivate:\n\n\t&#x2F;&#x2F;静态成员函数也是有访问权限的\n\tstatic void func2()\n\t&#123;\n\t\tcout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\nint Person::m_A &#x3D; 10;\n\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;静态成员变量两种访问方式\n\n\t&#x2F;&#x2F;1、通过对象\n\tPerson p1;\n\tp1.func();\n\n\t&#x2F;&#x2F;2、通过类名\n\tPerson::func();\n\n\n\t&#x2F;&#x2F;Person::func2(); &#x2F;&#x2F;私有权限访问不到\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n4.3 C++对象模型和this指针4.3.1 成员变量和成员函数分开存储在C++中，类内的成员变量和成员函数分开存储\n只有非静态成员变量才属于类的对象上\nclass Person &#123;\npublic:\n\tPerson() &#123;\n\t\tmA &#x3D; 0;\n\t&#125;\n\t&#x2F;&#x2F;非静态成员变量占对象空间\n\tint mA;\n\t&#x2F;&#x2F;静态成员变量不占对象空间\n\tstatic int mB; \n\t&#x2F;&#x2F;函数也不占对象空间，所有函数共享一个函数实例\n\tvoid func() &#123;\n\t\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;静态成员函数也不占对象空间\n\tstatic void sfunc() &#123;\n\t&#125;\n&#125;;\n\nint main() &#123;\n\n\tcout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n4.3.2 this指针概念通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的\n每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码\n那么问题是：这一块代码是如何区分那个对象调用自己的呢？\nc++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象\nthis指针是隐含每一个非静态成员函数内的一种指针\nthis指针不需要定义，直接使用即可\nthis指针的用途：\n\n 当形参和成员变量同名时，可用this指针来区分\n 在类的非静态成员函数中返回对象本身，可使用return *this\n\nclass Person\n&#123;\npublic:\n\n\tPerson(int age)\n\t&#123;\n\t\t&#x2F;&#x2F;1、当形参和成员变量同名时，可用this指针来区分\n\t\tthis-&gt;age &#x3D; age;\n\t&#125;\n\n\tPerson&amp; PersonAddPerson(Person p)\n\t&#123;\n\t\tthis-&gt;age +&#x3D; p.age;\n\t\t&#x2F;&#x2F;返回对象本身\n\t\treturn *this;\n\t&#125;\n\n\tint age;\n&#125;;\n\nvoid test01()\n&#123;\n\tPerson p1(10);\n\tcout &lt;&lt; &quot;p1.age &#x3D; &quot; &lt;&lt; p1.age &lt;&lt; endl;\n\n\tPerson p2(10);\n\tp2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\n\tcout &lt;&lt; &quot;p2.age &#x3D; &quot; &lt;&lt; p2.age &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n4.3.3 空指针访问成员函数C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针\n如果用到this指针，需要加以判断保证代码的健壮性\n示例：\n&#x2F;&#x2F;空指针访问成员函数\nclass Person &#123;\npublic:\n\n\tvoid ShowClassName() &#123;\n\t\tcout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;\n\t&#125;\n\n\tvoid ShowPerson() &#123;\n\t\tif (this &#x3D;&#x3D; NULL) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\tcout &lt;&lt; mAge &lt;&lt; endl;\n\t&#125;\n\npublic:\n\tint mAge;\n&#125;;\n\nvoid test01()\n&#123;\n\tPerson * p &#x3D; NULL;\n\tp-&gt;ShowClassName(); &#x2F;&#x2F;空指针，可以调用成员函数\n\tp-&gt;ShowPerson();  &#x2F;&#x2F;但是如果成员函数中用到了this指针，就不可以了\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n4.3.4 const修饰成员函数常函数：\n\n成员函数后加const后我们称为这个函数为常函数\n常函数内不可以修改成员属性\n成员属性声明时加关键字mutable后，在常函数中依然可以修改\n\n常对象：\n\n声明对象前加const称该对象为常对象\n常对象只能调用常函数\n\n示例：\nclass Person &#123;\npublic:\n\tPerson() &#123;\n\t\tm_A &#x3D; 0;\n\t\tm_B &#x3D; 0;\n\t&#125;\n\n\t&#x2F;&#x2F;this指针的本质是一个指针常量，指针的指向不可修改\n\t&#x2F;&#x2F;如果想让指针指向的值也不可以修改，需要声明常函数\n\tvoid ShowPerson() const &#123;\n\t\t&#x2F;&#x2F;const Type* const pointer;\n\t\t&#x2F;&#x2F;this &#x3D; NULL; &#x2F;&#x2F;不能修改指针的指向 Person* const this;\n\t\t&#x2F;&#x2F;this-&gt;mA &#x3D; 100; &#x2F;&#x2F;但是this指针指向的对象的数据是可以修改的\n\n\t\t&#x2F;&#x2F;const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\n\t\tthis-&gt;m_B &#x3D; 100;\n\t&#125;\n\n\tvoid MyFunc() const &#123;\n\t\t&#x2F;&#x2F;mA &#x3D; 10000;\n\t&#125;\n\npublic:\n\tint m_A;\n\tmutable int m_B; &#x2F;&#x2F;可修改 可变的\n&#125;;\n\n\n&#x2F;&#x2F;const修饰对象  常对象\nvoid test01() &#123;\n\n\tconst Person person; &#x2F;&#x2F;常量对象  \n\tcout &lt;&lt; person.m_A &lt;&lt; endl;\n\t&#x2F;&#x2F;person.mA &#x3D; 100; &#x2F;&#x2F;常对象不能修改成员变量的值,但是可以访问\n\tperson.m_B &#x3D; 100; &#x2F;&#x2F;但是常对象可以修改mutable修饰成员变量\n\n\t&#x2F;&#x2F;常对象访问成员函数\n\tperson.MyFunc(); &#x2F;&#x2F;常对象不能调用const的函数\n\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n4.4 友元生活中你的家有客厅(Public)，有你的卧室(Private)\n客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去\n但是呢，你也可以允许你的好闺蜜好基友进去。\n在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术\n友元的目的就是让一个函数或者类 访问另一个类中私有成员\n友元的关键字为  ==friend==\n友元的三种实现\n\n全局函数做友元\n类做友元\n成员函数做友元\n\n4.4.1 全局函数做友元class Building\n&#123;\n\t&#x2F;&#x2F;告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容\n\tfriend void goodGay(Building * building);\n\npublic:\n\n\tBuilding()\n\t&#123;\n\t\tthis-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;\n\t\tthis-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;\n\t&#125;\n\n\npublic:\n\tstring m_SittingRoom; &#x2F;&#x2F;客厅\n\nprivate:\n\tstring m_BedRoom; &#x2F;&#x2F;卧室\n&#125;;\n\n\nvoid goodGay(Building * building)\n&#123;\n\tcout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\n\tcout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;\n&#125;\n\n\nvoid test01()\n&#123;\n\tBuilding b;\n\tgoodGay(&amp;b);\n&#125;\n\nint main()&#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\treturn 0;\n&#125;\n\n\n\n4.4.2 类做友元class Building;\nclass goodGay\n&#123;\npublic:\n\n\tgoodGay();\n\tvoid visit();\n\nprivate:\n\tBuilding *building;\n&#125;;\n\n\nclass Building\n&#123;\n\t&#x2F;&#x2F;告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容\n\tfriend class goodGay;\n\npublic:\n\tBuilding();\n\npublic:\n\tstring m_SittingRoom; &#x2F;&#x2F;客厅\nprivate:\n\tstring m_BedRoom;&#x2F;&#x2F;卧室\n&#125;;\n\nBuilding::Building()\n&#123;\n\tthis-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;\n\tthis-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;\n&#125;\n\ngoodGay::goodGay()\n&#123;\n\tbuilding &#x3D; new Building;\n&#125;\n\nvoid goodGay::visit()\n&#123;\n\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\n\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n\tgoodGay gg;\n\tgg.visit();\n\n&#125;\n\nint main()&#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\treturn 0;\n&#125;\n\n\n\n\n\n4.4.3 成员函数做友元class Building;\nclass goodGay\n&#123;\npublic:\n\n\tgoodGay();\n\tvoid visit(); &#x2F;&#x2F;只让visit函数作为Building的好朋友，可以发访问Building中私有内容\n\tvoid visit2(); \n\nprivate:\n\tBuilding *building;\n&#125;;\n\n\nclass Building\n&#123;\n\t&#x2F;&#x2F;告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容\n\tfriend void goodGay::visit();\n\npublic:\n\tBuilding();\n\npublic:\n\tstring m_SittingRoom; &#x2F;&#x2F;客厅\nprivate:\n\tstring m_BedRoom;&#x2F;&#x2F;卧室\n&#125;;\n\nBuilding::Building()\n&#123;\n\tthis-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;\n\tthis-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;\n&#125;\n\ngoodGay::goodGay()\n&#123;\n\tbuilding &#x3D; new Building;\n&#125;\n\nvoid goodGay::visit()\n&#123;\n\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\n\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;\n&#125;\n\nvoid goodGay::visit2()\n&#123;\n\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\n\t&#x2F;&#x2F;cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n\tgoodGay  gg;\n\tgg.visit();\n\n&#125;\n\nint main()&#123;\n    \n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n4.5 运算符重载运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n4.5.1 加号运算符重载作用：实现两个自定义数据类型相加的运算\nclass Person &#123;\npublic:\n\tPerson() &#123;&#125;;\n\tPerson(int a, int b)\n\t&#123;\n\t\tthis-&gt;m_A &#x3D; a;\n\t\tthis-&gt;m_B &#x3D; b;\n\t&#125;\n\t&#x2F;&#x2F;成员函数实现 + 号运算符重载\n\tPerson operator+(const Person&amp; p) &#123;\n\t\tPerson temp;\n\t\ttemp.m_A &#x3D; this-&gt;m_A + p.m_A;\n\t\ttemp.m_B &#x3D; this-&gt;m_B + p.m_B;\n\t\treturn temp;\n\t&#125;\n\n\npublic:\n\tint m_A;\n\tint m_B;\n&#125;;\n\n&#x2F;&#x2F;全局函数实现 + 号运算符重载\n&#x2F;&#x2F;Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;\n&#x2F;&#x2F;\tPerson temp(0, 0);\n&#x2F;&#x2F;\ttemp.m_A &#x3D; p1.m_A + p2.m_A;\n&#x2F;&#x2F;\ttemp.m_B &#x3D; p1.m_B + p2.m_B;\n&#x2F;&#x2F;\treturn temp;\n&#x2F;&#x2F;&#125;\n\n&#x2F;&#x2F;运算符重载 可以发生函数重载 \nPerson operator+(const Person&amp; p2, int val)  \n&#123;\n\tPerson temp;\n\ttemp.m_A &#x3D; p2.m_A + val;\n\ttemp.m_B &#x3D; p2.m_B + val;\n\treturn temp;\n&#125;\n\nvoid test() &#123;\n\n\tPerson p1(10, 10);\n\tPerson p2(20, 20);\n\n\t&#x2F;&#x2F;成员函数方式\n\tPerson p3 &#x3D; p2 + p1;  &#x2F;&#x2F;相当于 p2.operaor+(p1)\n\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;\n\n\n\tPerson p4 &#x3D; p3 + 10; &#x2F;&#x2F;相当于 operator+(p3,10)\n\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;\n\n&#125;\n\nint main() &#123;\n\n\ttest();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结1：对于内置的数据类型的表达式的的运算符是不可能改变的\n\n\n\n\n\n\n\n\n\n总结2：不要滥用运算符重载\n4.5.2 左移运算符重载作用：可以输出自定义数据类型\nclass Person &#123;\n\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);\n\npublic:\n\n\tPerson(int a, int b)\n\t&#123;\n\t\tthis-&gt;m_A &#x3D; a;\n\t\tthis-&gt;m_B &#x3D; b;\n\t&#125;\n\n\t&#x2F;&#x2F;成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果\n\t&#x2F;&#x2F;void operator&lt;&lt;(Person&amp; p)&#123;\n\t&#x2F;&#x2F;&#125;\n\nprivate:\n\tint m_A;\n\tint m_B;\n&#125;;\n\n&#x2F;&#x2F;全局函数实现左移重载\n&#x2F;&#x2F;ostream对象只能有一个\nostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;\n\tout &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;\n\treturn out;\n&#125;\n\nvoid test() &#123;\n\n\tPerson p1(10, 20);\n\n\tcout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; &#x2F;&#x2F;链式编程\n&#125;\n\nint main() &#123;\n\n\ttest();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结：重载左移运算符配合友元可以实现输出自定义数据类型\n4.5.3 递增运算符重载作用： 通过重载递增运算符，实现自己的整型数据\nclass MyInteger &#123;\n\n\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);\n\npublic:\n\tMyInteger() &#123;\n\t\tm_Num &#x3D; 0;\n\t&#125;\n\t&#x2F;&#x2F;前置++\n\tMyInteger&amp; operator++() &#123;\n\t\t&#x2F;&#x2F;先++\n\t\tm_Num++;\n\t\t&#x2F;&#x2F;再返回\n\t\treturn *this;\n\t&#125;\n\n\t&#x2F;&#x2F;后置++\n\tMyInteger operator++(int) &#123;\n\t\t&#x2F;&#x2F;先返回\n\t\tMyInteger temp &#x3D; *this; &#x2F;&#x2F;记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\n\t\tm_Num++;\n\t\treturn temp;\n\t&#125;\n\nprivate:\n\tint m_Num;\n&#125;;\n\n\nostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;\n\tout &lt;&lt; myint.m_Num;\n\treturn out;\n&#125;\n\n\n&#x2F;&#x2F;前置++ 先++ 再返回\nvoid test01() &#123;\n\tMyInteger myInt;\n\tcout &lt;&lt; ++myInt &lt;&lt; endl;\n\tcout &lt;&lt; myInt &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;后置++ 先返回 再++\nvoid test02() &#123;\n\n\tMyInteger myInt;\n\tcout &lt;&lt; myInt++ &lt;&lt; endl;\n\tcout &lt;&lt; myInt &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\t&#x2F;&#x2F;test02();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结： 前置递增返回引用，后置递增返回值\n4.5.4 赋值运算符重载c++编译器至少给一个类添加4个函数\n\n默认构造函数(无参，函数体为空)\n默认析构函数(无参，函数体为空)\n默认拷贝构造函数，对属性进行值拷贝\n赋值运算符 operator=, 对属性进行值拷贝\n\n如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题\n示例：\nclass Person\n&#123;\npublic:\n\n\tPerson(int age)\n\t&#123;\n\t\t&#x2F;&#x2F;将年龄数据开辟到堆区\n\t\tm_Age &#x3D; new int(age);\n\t&#125;\n\n\t&#x2F;&#x2F;重载赋值运算符 \n\tPerson&amp; operator&#x3D;(Person &amp;p)\n\t&#123;\n\t\tif (m_Age !&#x3D; NULL)\n\t\t&#123;\n\t\t\tdelete m_Age;\n\t\t\tm_Age &#x3D; NULL;\n\t\t&#125;\n\t\t&#x2F;&#x2F;编译器提供的代码是浅拷贝\n\t\t&#x2F;&#x2F;m_Age &#x3D; p.m_Age;\n\n\t\t&#x2F;&#x2F;提供深拷贝 解决浅拷贝的问题\n\t\tm_Age &#x3D; new int(*p.m_Age);\n\n\t\t&#x2F;&#x2F;返回自身\n\t\treturn *this;\n\t&#125;\n\n\n\t~Person()\n\t&#123;\n\t\tif (m_Age !&#x3D; NULL)\n\t\t&#123;\n\t\t\tdelete m_Age;\n\t\t\tm_Age &#x3D; NULL;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;年龄的指针\n\tint *m_Age;\n\n&#125;;\n\n\nvoid test01()\n&#123;\n\tPerson p1(18);\n\n\tPerson p2(20);\n\n\tPerson p3(30);\n\n\tp3 &#x3D; p2 &#x3D; p1; &#x2F;&#x2F;赋值操作\n\n\tcout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\t&#x2F;&#x2F;int a &#x3D; 10;\n\t&#x2F;&#x2F;int b &#x3D; 20;\n\t&#x2F;&#x2F;int c &#x3D; 30;\n\n\t&#x2F;&#x2F;c &#x3D; b &#x3D; a;\n\t&#x2F;&#x2F;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\t&#x2F;&#x2F;cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\t&#x2F;&#x2F;cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n4.5.5 关系运算符重载作用：重载关系运算符，可以让两个自定义类型对象进行对比操作\n示例：\nclass Person\n&#123;\npublic:\n\tPerson(string name, int age)\n\t&#123;\n\t\tthis-&gt;m_Name &#x3D; name;\n\t\tthis-&gt;m_Age &#x3D; age;\n\t&#125;;\n\n\tbool operator&#x3D;&#x3D;(Person &amp; p)\n\t&#123;\n\t\tif (this-&gt;m_Name &#x3D;&#x3D; p.m_Name &amp;&amp; this-&gt;m_Age &#x3D;&#x3D; p.m_Age)\n\t\t&#123;\n\t\t\treturn true;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn false;\n\t\t&#125;\n\t&#125;\n\n\tbool operator!&#x3D;(Person &amp; p)\n\t&#123;\n\t\tif (this-&gt;m_Name &#x3D;&#x3D; p.m_Name &amp;&amp; this-&gt;m_Age &#x3D;&#x3D; p.m_Age)\n\t\t&#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\n\tstring m_Name;\n\tint m_Age;\n&#125;;\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;int a &#x3D; 0;\n\t&#x2F;&#x2F;int b &#x3D; 0;\n\n\tPerson a(&quot;孙悟空&quot;, 18);\n\tPerson b(&quot;孙悟空&quot;, 18);\n\n\tif (a &#x3D;&#x3D; b)\n\t&#123;\n\t\tcout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n\t&#125;\n\n\tif (a !&#x3D; b)\n\t&#123;\n\t\tcout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n4.5.6 函数调用运算符重载\n函数调用运算符 ()  也可以重载\n由于重载后使用的方式非常像函数的调用，因此称为仿函数\n仿函数没有固定写法，非常灵活\n\n示例：\nclass MyPrint\n&#123;\npublic:\n\tvoid operator()(string text)\n\t&#123;\n\t\tcout &lt;&lt; text &lt;&lt; endl;\n\t&#125;\n\n&#125;;\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;重载的（）操作符 也称为仿函数\n\tMyPrint myFunc;\n\tmyFunc(&quot;hello world&quot;);\n&#125;\n\n\nclass MyAdd\n&#123;\npublic:\n\tint operator()(int v1, int v2)\n\t&#123;\n\t\treturn v1 + v2;\n\t&#125;\n&#125;;\n\nvoid test02()\n&#123;\n\tMyAdd add;\n\tint ret &#x3D; add(10, 10);\n\tcout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; ret &lt;&lt; endl;\n\n\t&#x2F;&#x2F;匿名对象调用  \n\tcout &lt;&lt; &quot;MyAdd()(100,100) &#x3D; &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\ttest02();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n4.6  继承继承是面向对象三大特性之一\n有些类与类之间存在特殊的关系，例如下图中：\n\n我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。\n这个时候我们就可以考虑利用继承的技术，减少重复代码\n4.6.1 继承的基本语法例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同\n接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处\n普通实现：\n&#x2F;&#x2F;Java页面\nclass Java \n&#123;\npublic:\n\tvoid header()\n\t&#123;\n\t\tcout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid footer()\n\t&#123;\n\t\tcout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid left()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid content()\n\t&#123;\n\t\tcout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n&#x2F;&#x2F;Python页面\nclass Python\n&#123;\npublic:\n\tvoid header()\n\t&#123;\n\t\tcout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid footer()\n\t&#123;\n\t\tcout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid left()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid content()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n&#x2F;&#x2F;C++页面\nclass CPP \n&#123;\npublic:\n\tvoid header()\n\t&#123;\n\t\tcout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid footer()\n\t&#123;\n\t\tcout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid left()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid content()\n\t&#123;\n\t\tcout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;Java页面\n\tcout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;\n\tJava ja;\n\tja.header();\n\tja.footer();\n\tja.left();\n\tja.content();\n\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n\t&#x2F;&#x2F;Python页面\n\tcout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\n\tPython py;\n\tpy.header();\n\tpy.footer();\n\tpy.left();\n\tpy.content();\n\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n\t&#x2F;&#x2F;C++页面\n\tcout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\n\tCPP cp;\n\tcp.header();\n\tcp.footer();\n\tcp.left();\n\tcp.content();\n\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n继承实现：\n&#x2F;&#x2F;公共页面\nclass BasePage\n&#123;\npublic:\n\tvoid header()\n\t&#123;\n\t\tcout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\n\t&#125;\n\n\tvoid footer()\n\t&#123;\n\t\tcout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid left()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n\n&#x2F;&#x2F;Java页面\nclass Java : public BasePage\n&#123;\npublic:\n\tvoid content()\n\t&#123;\n\t\tcout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n&#x2F;&#x2F;Python页面\nclass Python : public BasePage\n&#123;\npublic:\n\tvoid content()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n&#x2F;&#x2F;C++页面\nclass CPP : public BasePage\n&#123;\npublic:\n\tvoid content()\n\t&#123;\n\t\tcout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;Java页面\n\tcout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;\n\tJava ja;\n\tja.header();\n\tja.footer();\n\tja.left();\n\tja.content();\n\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n\t&#x2F;&#x2F;Python页面\n\tcout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\n\tPython py;\n\tpy.header();\n\tpy.footer();\n\tpy.left();\n\tpy.content();\n\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n\t&#x2F;&#x2F;C++页面\n\tcout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\n\tCPP cp;\n\tcp.header();\n\tcp.footer();\n\tcp.left();\n\tcp.content();\n\n\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n总结：\n继承的好处：==可以减少重复的代码==\nclass A : public B; \nA 类称为子类 或 派生类\nB 类称为父类 或 基类\n派生类中的成员，包含两大部分：\n一类是从基类继承过来的，一类是自己增加的成员。\n从基类继承过过来的表现其共性，而新增的成员体现了其个性。\n4.6.2 继承方式继承的语法：class 子类 : 继承方式  父类\n继承方式一共有三种：\n\n公共继承\n保护继承\n私有继承\n\n\n示例：\nclass Base1\n&#123;\npublic: \n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n&#125;;\n\n&#x2F;&#x2F;公共继承\nclass Son1 :public Base1\n&#123;\npublic:\n\tvoid func()\n\t&#123;\n\t\tm_A; &#x2F;&#x2F;可访问 public权限\n\t\tm_B; &#x2F;&#x2F;可访问 protected权限\n\t\t&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问\n\t&#125;\n&#125;;\n\nvoid myClass()\n&#123;\n\tSon1 s1;\n\ts1.m_A; &#x2F;&#x2F;其他类只能访问到公共权限\n&#125;\n\n&#x2F;&#x2F;保护继承\nclass Base2\n&#123;\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n&#125;;\nclass Son2:protected Base2\n&#123;\npublic:\n\tvoid func()\n\t&#123;\n\t\tm_A; &#x2F;&#x2F;可访问 protected权限\n\t\tm_B; &#x2F;&#x2F;可访问 protected权限\n\t\t&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问\n\t&#125;\n&#125;;\nvoid myClass2()\n&#123;\n\tSon2 s;\n\t&#x2F;&#x2F;s.m_A; &#x2F;&#x2F;不可访问\n&#125;\n\n&#x2F;&#x2F;私有继承\nclass Base3\n&#123;\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n&#125;;\nclass Son3:private Base3\n&#123;\npublic:\n\tvoid func()\n\t&#123;\n\t\tm_A; &#x2F;&#x2F;可访问 private权限\n\t\tm_B; &#x2F;&#x2F;可访问 private权限\n\t\t&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问\n\t&#125;\n&#125;;\nclass GrandSon3 :public Son3\n&#123;\npublic:\n\tvoid func()\n\t&#123;\n\t\t&#x2F;&#x2F;Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到\n\t\t&#x2F;&#x2F;m_A;\n\t\t&#x2F;&#x2F;m_B;\n\t\t&#x2F;&#x2F;m_C;\n\t&#125;\n&#125;;\n\n\n\n\n\n\n\n\n\n4.6.3 继承中的对象模型问题：从父类继承过来的成员，哪些属于子类对象中？\n示例：\nclass Base\n&#123;\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C; &#x2F;&#x2F;私有成员只是被隐藏了，但是还是会继承下去\n&#125;;\n\n&#x2F;&#x2F;公共继承\nclass Son :public Base\n&#123;\npublic:\n\tint m_D;\n&#125;;\n\nvoid test01()\n&#123;\n\tcout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n利用工具查看：\n\n打开工具窗口后，定位到当前CPP文件的盘符\n然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名\n效果如下图：\n\n\n\n\n\n\n\n\n\n\n结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到\n4.6.4 继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数\n问题：父类和子类的构造和析构顺序是谁先谁后？\n示例：\nclass Base \n&#123;\npublic:\n\tBase()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t~Base()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass Son : public Base\n&#123;\npublic:\n\tSon()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t~Son()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n\tSon s;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n4.6.5 继承同名成员处理方式问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？\n\n访问子类同名成员   直接访问即可\n访问父类同名成员   需要加作用域\n\n示例：\nclass Base &#123;\npublic:\n\tBase()\n\t&#123;\n\t\tm_A &#x3D; 100;\n\t&#125;\n\n\tvoid func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;\n\t&#125;\n\n\tvoid func(int a)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;\n\t&#125;\n\npublic:\n\tint m_A;\n&#125;;\n\n\nclass Son : public Base &#123;\npublic:\n\tSon()\n\t&#123;\n\t\tm_A &#x3D; 200;\n\t&#125;\n\n\t&#x2F;&#x2F;当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n\t&#x2F;&#x2F;如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\n\tvoid func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;\n\t&#125;\npublic:\n\tint m_A;\n&#125;;\n\nvoid test01()\n&#123;\n\tSon s;\n\n\tcout &lt;&lt; &quot;Son下的m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Base下的m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\n\n\ts.func();\n\ts.Base::func();\n\ts.Base::func(10);\n\n&#125;\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\treturn EXIT_SUCCESS;\n&#125;\n\n总结：\n\n子类对象可以直接访问到子类中同名成员\n子类对象加作用域可以访问到父类同名成员\n当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数\n\n4.6.6 继承同名静态成员处理方式问题：继承中同名的静态成员在子类对象上如何进行访问？\n静态成员和非静态成员出现同名，处理方式一致\n\n访问子类同名成员   直接访问即可\n访问父类同名成员   需要加作用域\n\n示例：\nclass Base &#123;\npublic:\n\tstatic void func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;\n\t&#125;\n\tstatic void func(int a)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl;\n\t&#125;\n\n\tstatic int m_A;\n&#125;;\n\nint Base::m_A &#x3D; 100;\n\nclass Son : public Base &#123;\npublic:\n\tstatic void func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;\n\t&#125;\n\tstatic int m_A;\n&#125;;\n\nint Son::m_A &#x3D; 200;\n\n&#x2F;&#x2F;同名成员属性\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;通过对象访问\n\tcout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;\n\tSon s;\n\tcout &lt;&lt; &quot;Son  下 m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\n\n\t&#x2F;&#x2F;通过类名访问\n\tcout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Son  下 m_A &#x3D; &quot; &lt;&lt; Son::m_A &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;同名成员函数\nvoid test02()\n&#123;\n\t&#x2F;&#x2F;通过对象访问\n\tcout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;\n\tSon s;\n\ts.func();\n\ts.Base::func();\n\n\tcout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\n\tSon::func();\n\tSon::Base::func();\n\t&#x2F;&#x2F;出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\n\tSon::Base::func(100);\n&#125;\nint main() &#123;\n\n\t&#x2F;&#x2F;test01();\n\ttest02();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）\n4.6.7 多继承语法C++允许一个类继承多个类\n语法： class 子类 ：继承方式 父类1 ， 继承方式 父类2...\n多继承可能会引发父类中有同名成员出现，需要加作用域区分\nC++实际开发中不建议用多继承\n示例：\nclass Base1 &#123;\npublic:\n\tBase1()\n\t&#123;\n\t\tm_A &#x3D; 100;\n\t&#125;\npublic:\n\tint m_A;\n&#125;;\n\nclass Base2 &#123;\npublic:\n\tBase2()\n\t&#123;\n\t\tm_A &#x3D; 200;  &#x2F;&#x2F;开始是m_B 不会出问题，但是改为mA就会出现不明确\n\t&#125;\npublic:\n\tint m_A;\n&#125;;\n\n&#x2F;&#x2F;语法：class 子类：继承方式 父类1 ，继承方式 父类2 \nclass Son : public Base2, public Base1 \n&#123;\npublic:\n\tSon()\n\t&#123;\n\t\tm_C &#x3D; 300;\n\t\tm_D &#x3D; 400;\n\t&#125;\npublic:\n\tint m_C;\n\tint m_D;\n&#125;;\n\n\n&#x2F;&#x2F;多继承容易产生成员同名的情况\n&#x2F;&#x2F;通过使用类名作用域可以区分调用哪一个基类的成员\nvoid test01()\n&#123;\n\tSon s;\n\tcout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(s) &lt;&lt; endl;\n\tcout &lt;&lt; s.Base1::m_A &lt;&lt; endl;\n\tcout &lt;&lt; s.Base2::m_A &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域\n4.6.8 菱形继承菱形继承概念：\n​    两个派生类继承同一个基类\n​    又有某个类同时继承者两个派生类\n​    这种继承被称为菱形继承，或者钻石继承\n典型的菱形继承案例：\n\n菱形继承问题：\n\n羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。\n\n\n草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。\n\n\n\n示例：\nclass Animal\n&#123;\npublic:\n\tint m_Age;\n&#125;;\n\n&#x2F;&#x2F;继承前加virtual关键字后，变为虚继承\n&#x2F;&#x2F;此时公共的父类Animal称为虚基类\nclass Sheep : virtual public Animal &#123;&#125;;\nclass Tuo   : virtual public Animal &#123;&#125;;\nclass SheepTuo : public Sheep, public Tuo &#123;&#125;;\n\nvoid test01()\n&#123;\n\tSheepTuo st;\n\tst.Sheep::m_Age &#x3D; 100;\n\tst.Tuo::m_Age &#x3D; 200;\n\n\tcout &lt;&lt; &quot;st.Sheep::m_Age &#x3D; &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;\n\tcout &lt;&lt; &quot;st.Tuo::m_Age &#x3D; &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;\n\tcout &lt;&lt; &quot;st.m_Age &#x3D; &quot; &lt;&lt; st.m_Age &lt;&lt; endl;\n&#125;\n\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n总结：\n\n菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义\n利用虚继承可以解决菱形继承问题\n\n4.7  多态4.7.1 多态的基本概念多态是C++面向对象三大特性之一\n多态分为两类\n\n静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名\n动态多态: 派生类和虚函数实现运行时多态\n\n静态多态和动态多态区别：\n\n静态多态的函数地址早绑定  -  编译阶段确定函数地址\n动态多态的函数地址晚绑定  -  运行阶段确定函数地址\n\n下面通过案例进行讲解多态\nclass Animal\n&#123;\npublic:\n\t&#x2F;&#x2F;Speak函数就是虚函数\n\t&#x2F;&#x2F;函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。\n\tvirtual void speak()\n\t&#123;\n\t\tcout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass Cat :public Animal\n&#123;\npublic:\n\tvoid speak()\n\t&#123;\n\t\tcout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass Dog :public Animal\n&#123;\npublic:\n\n\tvoid speak()\n\t&#123;\n\t\tcout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n&#x2F;&#x2F;我们希望传入什么对象，那么就调用什么对象的函数\n&#x2F;&#x2F;如果函数地址在编译阶段就能确定，那么静态联编\n&#x2F;&#x2F;如果函数地址在运行阶段才能确定，就是动态联编\n\nvoid DoSpeak(Animal &amp; animal)\n&#123;\n\tanimal.speak();\n&#125;\n&#x2F;&#x2F;\n&#x2F;&#x2F;多态满足条件： \n&#x2F;&#x2F;1、有继承关系\n&#x2F;&#x2F;2、子类重写父类中的虚函数\n&#x2F;&#x2F;多态使用：\n&#x2F;&#x2F;父类指针或引用指向子类对象\n\nvoid test01()\n&#123;\n\tCat cat;\n\tDoSpeak(cat);\n\n\n\tDog dog;\n\tDoSpeak(dog);\n&#125;\n\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n总结：\n多态满足条件\n\n有继承关系\n子类重写父类中的虚函数\n\n多态使用条件\n\n父类指针或引用指向子类对象\n\n重写：函数返回值类型  函数名 参数列表 完全一致称为重写\n4.7.2 多态案例一-计算器类案例描述：\n分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类\n多态的优点：\n\n代码组织结构清晰\n可读性强\n利于前期和后期的扩展以及维护\n\n示例：\n&#x2F;&#x2F;普通实现\nclass Calculator &#123;\npublic:\n\tint getResult(string oper)\n\t&#123;\n\t\tif (oper &#x3D;&#x3D; &quot;+&quot;) &#123;\n\t\t\treturn m_Num1 + m_Num2;\n\t\t&#125;\n\t\telse if (oper &#x3D;&#x3D; &quot;-&quot;) &#123;\n\t\t\treturn m_Num1 - m_Num2;\n\t\t&#125;\n\t\telse if (oper &#x3D;&#x3D; &quot;*&quot;) &#123;\n\t\t\treturn m_Num1 * m_Num2;\n\t\t&#125;\n\t\t&#x2F;&#x2F;如果要提供新的运算，需要修改源码\n\t&#125;\npublic:\n\tint m_Num1;\n\tint m_Num2;\n&#125;;\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;普通实现测试\n\tCalculator c;\n\tc.m_Num1 &#x3D; 10;\n\tc.m_Num2 &#x3D; 10;\n\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl;\n\n\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;\n\n\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;\n&#125;\n\n\n\n&#x2F;&#x2F;多态实现\n&#x2F;&#x2F;抽象计算器类\n&#x2F;&#x2F;多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护\nclass AbstractCalculator\n&#123;\npublic :\n\n\tvirtual int getResult()\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\n\tint m_Num1;\n\tint m_Num2;\n&#125;;\n\n&#x2F;&#x2F;加法计算器\nclass AddCalculator :public AbstractCalculator\n&#123;\npublic:\n\tint getResult()\n\t&#123;\n\t\treturn m_Num1 + m_Num2;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;减法计算器\nclass SubCalculator :public AbstractCalculator\n&#123;\npublic:\n\tint getResult()\n\t&#123;\n\t\treturn m_Num1 - m_Num2;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;乘法计算器\nclass MulCalculator :public AbstractCalculator\n&#123;\npublic:\n\tint getResult()\n\t&#123;\n\t\treturn m_Num1 * m_Num2;\n\t&#125;\n&#125;;\n\n\nvoid test02()\n&#123;\n\t&#x2F;&#x2F;创建加法计算器\n\tAbstractCalculator *abc &#x3D; new AddCalculator;\n\tabc-&gt;m_Num1 &#x3D; 10;\n\tabc-&gt;m_Num2 &#x3D; 10;\n\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\n\tdelete abc;  &#x2F;&#x2F;用完了记得销毁\n\n\t&#x2F;&#x2F;创建减法计算器\n\tabc &#x3D; new SubCalculator;\n\tabc-&gt;m_Num1 &#x3D; 10;\n\tabc-&gt;m_Num2 &#x3D; 10;\n\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\n\tdelete abc;  \n\n\t&#x2F;&#x2F;创建乘法计算器\n\tabc &#x3D; new MulCalculator;\n\tabc-&gt;m_Num1 &#x3D; 10;\n\tabc-&gt;m_Num2 &#x3D; 10;\n\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\n\tdelete abc;\n&#125;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;test01();\n\n\ttest02();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n总结：C++开发提倡利用多态设计程序架构，因为多态优点很多\n4.7.3 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容\n因此可以将虚函数改为纯虚函数\n纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;\n当类中有了纯虚函数，这个类也称为==抽象类==\n抽象类特点：\n\n无法实例化对象\n子类必须重写抽象类中的纯虚函数，否则也属于抽象类\n\n示例：\nclass Base\n&#123;\npublic:\n\t&#x2F;&#x2F;纯虚函数\n\t&#x2F;&#x2F;类中只要有一个纯虚函数就称为抽象类\n\t&#x2F;&#x2F;抽象类无法实例化对象\n\t&#x2F;&#x2F;子类必须重写父类中的纯虚函数，否则也属于抽象类\n\tvirtual void func() &#x3D; 0;\n&#125;;\n\nclass Son :public Base\n&#123;\npublic:\n\tvirtual void func() \n\t&#123;\n\t\tcout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;\n\t&#125;;\n&#125;;\n\nvoid test01()\n&#123;\n\tBase * base &#x3D; NULL;\n\t&#x2F;&#x2F;base &#x3D; new Base; &#x2F;&#x2F; 错误，抽象类无法实例化对象\n\tbase &#x3D; new Son;\n\tbase-&gt;func();\n\tdelete base;&#x2F;&#x2F;记得销毁\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.7.4 多态案例二-制作饮品案例描述：\n制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料\n利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶\n\n示例：\n&#x2F;&#x2F;抽象制作饮品\nclass AbstractDrinking &#123;\npublic:\n\t&#x2F;&#x2F;烧水\n\tvirtual void Boil() &#x3D; 0;\n\t&#x2F;&#x2F;冲泡\n\tvirtual void Brew() &#x3D; 0;\n\t&#x2F;&#x2F;倒入杯中\n\tvirtual void PourInCup() &#x3D; 0;\n\t&#x2F;&#x2F;加入辅料\n\tvirtual void PutSomething() &#x3D; 0;\n\t&#x2F;&#x2F;规定流程\n\tvoid MakeDrink() &#123;\n\t\tBoil();\n\t\tBrew();\n\t\tPourInCup();\n\t\tPutSomething();\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;制作咖啡\nclass Coffee : public AbstractDrinking &#123;\npublic:\n\t&#x2F;&#x2F;烧水\n\tvirtual void Boil() &#123;\n\t\tcout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;冲泡\n\tvirtual void Brew() &#123;\n\t\tcout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;倒入杯中\n\tvirtual void PourInCup() &#123;\n\t\tcout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;加入辅料\n\tvirtual void PutSomething() &#123;\n\t\tcout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;制作茶水\nclass Tea : public AbstractDrinking &#123;\npublic:\n\t&#x2F;&#x2F;烧水\n\tvirtual void Boil() &#123;\n\t\tcout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;冲泡\n\tvirtual void Brew() &#123;\n\t\tcout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;倒入杯中\n\tvirtual void PourInCup() &#123;\n\t\tcout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;加入辅料\n\tvirtual void PutSomething() &#123;\n\t\tcout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;业务函数\nvoid DoWork(AbstractDrinking* drink) &#123;\n\tdrink-&gt;MakeDrink();\n\tdelete drink;\n&#125;\n\nvoid test01() &#123;\n\tDoWork(new Coffee);\n\tcout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl;\n\tDoWork(new Tea);\n&#125;\n\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.7.5 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\n解决方式：将父类中的析构函数改为虚析构或者纯虚析构\n虚析构和纯虚析构共性：\n\n可以解决父类指针释放子类对象\n都需要有具体的函数实现\n\n虚析构和纯虚析构区别：\n\n如果是纯虚析构，该类属于抽象类，无法实例化对象\n\n虚析构语法：\nvirtual ~类名()&#123;&#125;\n纯虚析构语法：\n virtual ~类名() = 0;\n类名::~类名()&#123;&#125;\n示例：\nclass Animal &#123;\npublic:\n\n\tAnimal()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;\n\t&#125;\n\tvirtual void Speak() &#x3D; 0;\n\n\t&#x2F;&#x2F;析构函数加上virtual关键字，变成虚析构函数\n\t&#x2F;&#x2F;virtual ~Animal()\n\t&#x2F;&#x2F;&#123;\n\t&#x2F;&#x2F;\tcout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F;&#125;\n\n\n\tvirtual ~Animal() &#x3D; 0;\n&#125;;\n\nAnimal::~Animal()\n&#123;\n\tcout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。\n\nclass Cat : public Animal &#123;\npublic:\n\tCat(string name)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl;\n\t\tm_Name &#x3D; new string(name);\n\t&#125;\n\tvirtual void Speak()\n\t&#123;\n\t\tcout &lt;&lt; *m_Name &lt;&lt;  &quot;小猫在说话!&quot; &lt;&lt; endl;\n\t&#125;\n\t~Cat()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl;\n\t\tif (this-&gt;m_Name !&#x3D; NULL) &#123;\n\t\t\tdelete m_Name;\n\t\t\tm_Name &#x3D; NULL;\n\t\t&#125;\n\t&#125;\n\npublic:\n\tstring *m_Name;\n&#125;;\n\nvoid test01()\n&#123;\n\tAnimal *animal &#x3D; new Cat(&quot;Tom&quot;);\n\tanimal-&gt;Speak();\n\n\t&#x2F;&#x2F;通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\n\t&#x2F;&#x2F;怎么解决？给基类增加一个虚析构函数\n\t&#x2F;&#x2F;虚析构函数就是用来解决通过父类指针释放子类对象\n\tdelete animal;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n总结：\n​    1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象\n​    2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构\n​    3. 拥有纯虚析构函数的类也属于抽象类\n4.7.6 多态案例三-电脑组装案例描述：\n电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）\n将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商\n创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口\n测试时组装三台不同的电脑进行工作\n示例：\n#include&lt;iostream&gt;\nusing namespace std;\n\n&#x2F;&#x2F;抽象CPU类\nclass CPU\n&#123;\npublic:\n\t&#x2F;&#x2F;抽象的计算函数\n\tvirtual void calculate() &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F;抽象显卡类\nclass VideoCard\n&#123;\npublic:\n\t&#x2F;&#x2F;抽象的显示函数\n\tvirtual void display() &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F;抽象内存条类\nclass Memory\n&#123;\npublic:\n\t&#x2F;&#x2F;抽象的存储函数\n\tvirtual void storage() &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F;电脑类\nclass Computer\n&#123;\npublic:\n\tComputer(CPU * cpu, VideoCard * vc, Memory * mem)\n\t&#123;\n\t\tm_cpu &#x3D; cpu;\n\t\tm_vc &#x3D; vc;\n\t\tm_mem &#x3D; mem;\n\t&#125;\n\n\t&#x2F;&#x2F;提供工作的函数\n\tvoid work()\n\t&#123;\n\t\t&#x2F;&#x2F;让零件工作起来，调用接口\n\t\tm_cpu-&gt;calculate();\n\n\t\tm_vc-&gt;display();\n\n\t\tm_mem-&gt;storage();\n\t&#125;\n\n\t&#x2F;&#x2F;提供析构函数 释放3个电脑零件\n\t~Computer()\n\t&#123;\n\n\t\t&#x2F;&#x2F;释放CPU零件\n\t\tif (m_cpu !&#x3D; NULL)\n\t\t&#123;\n\t\t\tdelete m_cpu;\n\t\t\tm_cpu &#x3D; NULL;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F;释放显卡零件\n\t\tif (m_vc !&#x3D; NULL)\n\t\t&#123;\n\t\t\tdelete m_vc;\n\t\t\tm_vc &#x3D; NULL;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F;释放内存条零件\n\t\tif (m_mem !&#x3D; NULL)\n\t\t&#123;\n\t\t\tdelete m_mem;\n\t\t\tm_mem &#x3D; NULL;\n\t\t&#125;\n\t&#125;\n\nprivate:\n\n\tCPU * m_cpu; &#x2F;&#x2F;CPU的零件指针\n\tVideoCard * m_vc; &#x2F;&#x2F;显卡零件指针\n\tMemory * m_mem; &#x2F;&#x2F;内存条零件指针\n&#125;;\n\n&#x2F;&#x2F;具体厂商\n&#x2F;&#x2F;Intel厂商\nclass IntelCPU :public CPU\n&#123;\npublic:\n\tvirtual void calculate()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass IntelVideoCard :public VideoCard\n&#123;\npublic:\n\tvirtual void display()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass IntelMemory :public Memory\n&#123;\npublic:\n\tvirtual void storage()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;Lenovo厂商\nclass LenovoCPU :public CPU\n&#123;\npublic:\n\tvirtual void calculate()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass LenovoVideoCard :public VideoCard\n&#123;\npublic:\n\tvirtual void display()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass LenovoMemory :public Memory\n&#123;\npublic:\n\tvirtual void storage()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;第一台电脑零件\n\tCPU * intelCpu &#x3D; new IntelCPU;\n\tVideoCard * intelCard &#x3D; new IntelVideoCard;\n\tMemory * intelMem &#x3D; new IntelMemory;\n\n\tcout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F;创建第一台电脑\n\tComputer * computer1 &#x3D; new Computer(intelCpu, intelCard, intelMem);\n\tcomputer1-&gt;work();\n\tdelete computer1;\n\n\tcout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F;第二台电脑组装\n\tComputer * computer2 &#x3D; new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\n\tcomputer2-&gt;work();\n\tdelete computer2;\n\n\tcout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F;第三台电脑组装\n\tComputer * computer3 &#x3D; new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\n\tcomputer3-&gt;work();\n\tdelete computer3;\n\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n5 文件操作程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放\n通过文件可以将数据持久化\nC++中对文件操作需要包含头文件 ==&lt; fstream &gt;==\n文件类型分为两种：\n\n文本文件     -  文件以文本的ASCII码形式存储在计算机中\n二进制文件 -  文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们\n\n操作文件的三大类:\n\nofstream：写操作\nifstream： 读操作\nfstream ： 读写操作\n\n5.1文本文件5.1.1写文件   写文件步骤如下：\n\n包含头文件   \n#include &lt;fstream&gt;\n\n创建流对象  \nofstream ofs;\n\n打开文件\nofs.open(“文件路径”,打开方式);\n\n写数据\nofs &lt;&lt; “写入的数据”;\n\n关闭文件\nofs.close();\n\n\n文件打开方式：\n\n\n\n打开方式\n解释\n\n\n\nios::in\n为读文件而打开文件\n\n\nios::out\n为写文件而打开文件\n\n\nios::ate\n初始位置：文件尾\n\n\nios::app\n追加方式写文件\n\n\nios::trunc\n如果文件存在先删除，再创建\n\n\nios::binary\n二进制方式\n\n\n注意： 文件打开方式可以配合使用，利用|操作符\n例如：用二进制方式写文件 ios::binary |  ios:: out\n示例：\n#include &lt;fstream&gt;\n\nvoid test01()\n&#123;\n\tofstream ofs;\n\tofs.open(&quot;test.txt&quot;, ios::out);\n\n\tofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;\n\tofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;\n\tofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;\n\n\tofs.close();\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n总结：\n\n文件操作必须包含头文件 fstream\n读文件可以利用 ofstream  ，或者fstream类\n打开文件时候需要指定操作文件的路径，以及打开方式\n利用&lt;&lt;可以向文件中写数据\n操作完毕，要关闭文件\n\n5.1.2读文件读文件与写文件步骤相似，但是读取方式相对于比较多\n读文件步骤如下：\n\n包含头文件   \n#include &lt;fstream&gt;\n\n创建流对象  \nifstream ifs;\n\n打开文件并判断文件是否打开成功\nifs.open(“文件路径”,打开方式);\n\n读数据\n四种方式读取\n\n关闭文件\nifs.close();\n\n\n示例：\n#include &lt;fstream&gt;\n#include &lt;string&gt;\nvoid test01()\n&#123;\n\tifstream ifs;\n\tifs.open(&quot;test.txt&quot;, ios::in);\n\n\tif (!ifs.is_open())\n\t&#123;\n\t\tcout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;\n\t\treturn;\n\t&#125;\n\n\t&#x2F;&#x2F;第一种方式\n\t&#x2F;&#x2F;char buf[1024] &#x3D; &#123; 0 &#125;;\n\t&#x2F;&#x2F;while (ifs &gt;&gt; buf)\n\t&#x2F;&#x2F;&#123;\n\t&#x2F;&#x2F;\tcout &lt;&lt; buf &lt;&lt; endl;\n\t&#x2F;&#x2F;&#125;\n\n\t&#x2F;&#x2F;第二种\n\t&#x2F;&#x2F;char buf[1024] &#x3D; &#123; 0 &#125;;\n\t&#x2F;&#x2F;while (ifs.getline(buf,sizeof(buf)))\n\t&#x2F;&#x2F;&#123;\n\t&#x2F;&#x2F;\tcout &lt;&lt; buf &lt;&lt; endl;\n\t&#x2F;&#x2F;&#125;\n\n\t&#x2F;&#x2F;第三种\n\t&#x2F;&#x2F;string buf;\n\t&#x2F;&#x2F;while (getline(ifs, buf))\n\t&#x2F;&#x2F;&#123;\n\t&#x2F;&#x2F;\tcout &lt;&lt; buf &lt;&lt; endl;\n\t&#x2F;&#x2F;&#125;\n\n\tchar c;\n\twhile ((c &#x3D; ifs.get()) !&#x3D; EOF)\n\t&#123;\n\t\tcout &lt;&lt; c;\n\t&#125;\n\n\tifs.close();\n\n\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n总结：\n\n读文件可以利用 ifstream  ，或者fstream类\n利用is_open函数可以判断文件是否打开成功\nclose 关闭文件 \n\n5.2 二进制文件以二进制的方式对文件进行读写操作\n打开方式要指定为 ==ios::binary==\n5.2.1 写文件二进制方式写文件主要利用流对象调用成员函数write\n函数原型 ：ostream&amp; write(const char * buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n示例：\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n\nclass Person\n&#123;\npublic:\n\tchar m_Name[64];\n\tint m_Age;\n&#125;;\n\n&#x2F;&#x2F;二进制文件  写文件\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;1、包含头文件\n\n\t&#x2F;&#x2F;2、创建输出流对象\n\tofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary);\n\t\n\t&#x2F;&#x2F;3、打开文件\n\t&#x2F;&#x2F;ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);\n\n\tPerson p &#x3D; &#123;&quot;张三&quot;  , 18&#125;;\n\n\t&#x2F;&#x2F;4、写文件\n\tofs.write((const char *)&amp;p, sizeof(p));\n\n\t&#x2F;&#x2F;5、关闭文件\n\tofs.close();\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n总结：\n\n文件输出流对象 可以通过write函数，以二进制方式写数据\n\n5.2.2 读文件二进制方式读文件主要利用流对象调用成员函数read\n函数原型：istream&amp; read(char *buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n示例：\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n\nclass Person\n&#123;\npublic:\n\tchar m_Name[64];\n\tint m_Age;\n&#125;;\n\nvoid test01()\n&#123;\n\tifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary);\n\tif (!ifs.is_open())\n\t&#123;\n\t\tcout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;\n\t&#125;\n\n\tPerson p;\n\tifs.read((char *)&amp;p, sizeof(p));\n\n\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n文件输入流对象 可以通过read函数，以二进制方式读数据\n\n","slug":"C++核心编程","date":"2021-12-08T14:01:15.000Z","categories_index":"C++","tags_index":"记录","author_index":"祥瑞"},{"id":"e9d1803706b9032e2ca68eddf6b43194","title":"十一届蓝桥杯嵌入式省赛","content":"前言由于本人乃菜鸡，而且这个项目只是我拿来给自己练习的，所以并没有想过做教学使用，大家可以参考一下，如果各位大佬垂阅，可以给出一下建议，我将不甚感激。\n之前些32代码都是全部放到main.c里面，这次是第一次把主要的程序都放到其他.c中，然后调用，这样逻辑是会比较清晰的，而且以后和别人一起做项目，这样才能更好的分工和耦合，以及对接，但是我可能是因为第一次这样做吧，所以做的时候还是有点理不清，还需要进一步熟悉这种分模块的写法。\n题目\n分析这一年的主观题还是比较简单的，主要难点在于如何发出两个PWM波，由于规定了PWM的输出引脚，所以如果使用定时器来产生PWM波，不太好搞，生成不一样频率的PWM，然而如果使用软件模拟PWM的话，就比较简单了。\n\n代码1.主函数模块main.c\n#include \"stm32f10x.h\"\n#include \"lcd.h\"\n#include \"UI.h\"\n#include \"key.h\"\n#include \"stdio.h\"\nu32 TimingDelay = 0;\nvoid Delay_Ms(u32 nTime);\nextern int duty1,duty2;\nint main(void)\n&#123;\n\tSysTick_Config(SystemCoreClock/100000);\t//一次中断10us，1khz是1ms100个中断，2khz是200个中断\n\tKey_init();\n\tLed_init();\n\tLed_all_close();\n\tADC_Config();\n\tSTM3210B_LCD_Init();\n\tLCD_Clear(White);\n\tLCD_SetBackColor(White);\n\tLCD_SetTextColor(Black);\n\twhile(1)&#123;\n\tKey_Set();\t\t\t\t\t\t\t\t\t\t//按键控制PWM\n\tUUII();\t\t\t\t\t\t\t\t\t\t\t  //LCD显示\n    &#125;&#125;\nvoid Delay_Ms(u32 nTime)\n&#123;\n\tTimingDelay = nTime;\n\twhile(TimingDelay != 0);\t\n&#125;\n\n\n2.显示和adc配置模块adc.c\n#include \"lcd.h\"\n#include \"UI.h\"\n#include \"stdio.h\"\n#include \"stm32f10x.h\"\n#include \"key.h\"\nchar read[9];\nint ADC_Flag;\nextern int flag_key_1;\nextern int flag_key_4;\nint Mode;\nint UI_q;\t\t\t\t\t//切换数据显示或者参数显示\nint duty1,duty2;\n\nvoid UUII()&#123;\n\tif(flag_key_1%2 == 0)&#123;\n\t\tif((flag_key_4%2 ==0))&#123;\n\t\tLCD_DisplayStringLine(Line0,(unsigned char *)\"        Data\");\n\t\t\t\tsprintf((char*)read,\"      V: %.2fv\",Read_ADC()*3.3/100);\n\t\tLCD_DisplayStringLine(Line3,(unsigned char *)read);\n\t\tLCD_DisplayStringLine(Line6,(unsigned char *)\"      Mode: AUTO\");\n\t\t\n\t\tduty1=(int)Read_ADC();\n\t\tduty2=(int)Read_ADC();\t\t//现在的adc输出的是真实电压的10/3.3倍，所以可以可以直接赋值\n\t\t\t\n\t\t\t\n\t\t\t\tLed_all_close();\n\t\t\t\tGPIO_ResetBits(GPIOC,GPIO_Pin_8);\n\t\t\t\tGPIO_SetBits(GPIOD,GPIO_Pin_2);\n        GPIO_ResetBits(GPIOD,GPIO_Pin_2); \n\t\t&#125;\n\t\telse&#123;\n\t\tLCD_DisplayStringLine(Line0,(unsigned char *)\"        Data\");\n\t\tsprintf((char*)read,\"      V: %.2fv\",Read_ADC()*3.3/100);\n\t\tLCD_DisplayStringLine(Line3,(unsigned char *)read);\n\t\tLCD_DisplayStringLine(Line6,(unsigned char *)\"      Mode: MANU\");\n\t\t\t\n\t\t\t\tLed_all_close();\n\t\t\t\tGPIO_ResetBits(GPIOC,GPIO_Pin_9);\n\t\t\t\tGPIO_SetBits(GPIOD,GPIO_Pin_2);\n        GPIO_ResetBits(GPIOD,GPIO_Pin_2); \n\t\n\t\t\t\n\t\t&#125;\n\t\tUI_q=0;\n\t&#125;\n\telse&#123;\n\t\tif((flag_key_4%2 ==0))&#123;\t\t\t\t\t\t\t//自动模式\n\t\t\t\n\t\tduty1=(int)Read_ADC();\n\t\tduty2=(int)Read_ADC();\n\t\t\t\t\n\t\t&#125;\n\t\telse&#123;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//手动模式\n\t\tif(RB2 == KEY_ON)&#123;\n\t\tLCD_Clear(White);\n\t\tduty1=duty1+10;\n\t\tif(duty1>90)&#123;duty1=0;&#125;\n\t\t\t\n\t\n\t&#125;\t\n\t\tif(RB3 == KEY_ON)&#123;\n\t\tLCD_Clear(White);\n\t\tduty2=duty2+10;\n\t\t\tif(duty2>90)&#123;duty2=0;&#125;\n\t&#125;\t\n\t\t\n\t\t\t\n\t\t&#125;\n\t\tLCD_DisplayStringLine(Line0,(unsigned char *)\"        Para\");\n\t\tsprintf((char*)read,\"        PA6:%d   \",duty1);\n\t\tLCD_DisplayStringLine(Line3,(unsigned char *)read);\n\t\tsprintf((char*)read,\"        PA7:%d   \",duty2);\n\t\tLCD_DisplayStringLine(Line6,(unsigned char *)read);\n\t\tUI_q=1;&#125;\n\tif(UI_q == 0)&#123;\t\n\t\n\t&#125;\n\t\n\t\n&#125;\n\nfloat Read_ADC(void)\n&#123;\n\tfloat ADC_VALUE;\n\t\n\tADC_SoftwareStartConvCmd(ADC1,ENABLE);\n\tADC_VALUE = ADC_GetConversionValue(ADC1)*100/0xfff;\n\treturn ADC_VALUE;\n&#125;\n\n\nvoid ADC_Config(void)\n&#123;\n\tGPIO_InitTypeDef GPIO_InitStructure;\n\tADC_InitTypeDef ADC_InitStructure;\n\t\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);\n\t//PB0-ADC channel 8\n\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;\n\tGPIO_Init(GPIOB, &amp;GPIO_InitStructure);\n\t\n\t// ADC1 工作模式配置\n\tADC_InitStructure.ADC_Mode = ADC_Mode_Independent;  \n\tADC_InitStructure.ADC_ScanConvMode = DISABLE;\n\tADC_InitStructure.ADC_ContinuousConvMode = DISABLE;  //单次转换\n\tADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;\n\tADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;\n\tADC_InitStructure.ADC_NbrOfChannel = 1;\n\tADC_Init(ADC1, &amp;ADC_InitStructure);\n\n\tADC_RegularChannelConfig(ADC1, ADC_Channel_8, 1, ADC_SampleTime_13Cycles5);    \n\n\tADC_Cmd(ADC1, ENABLE);   \n\tADC_ResetCalibration(ADC1);\n\t/* Check the end of ADC1 reset calibration register */\n\twhile(ADC_GetResetCalibrationStatus(ADC1));\n\tADC_StartCalibration(ADC1);\n\t/* Check the end of ADC1 calibration */\n\twhile(ADC_GetCalibrationStatus(ADC1));\n&#125;\n\n3、按键&amp;LED配置#include \"key.h\"\n#include \"stm32f10x.h\"\n#include \"lcd.h\"\nint flag_key_1;\nint flag_key_4;\n\nuint16_t Channel2Pulse = 0, Channel3Pulse = 0;\n\nvoid Key_init()&#123;\n\tGPIO_InitTypeDef GPIO_InitStructure;\n\t\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\n  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\n\t\n\t\t//B1、B2按键引脚配置\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_8; // \n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;\n    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);\n    //B3、B4按键引脚配置\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;\n    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);\n\t\n\t\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; // \n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;\n    GPIO_Init(GPIOA, &amp;GPIO_InitStructure);\t\n&#125;\n\nuint16_t Key_Scan(GPIO_TypeDef* GPIOx,uint16_t GPIO_Pin)\n&#123;\n\tif(GPIO_ReadInputDataBit(GPIOx,GPIO_Pin) == KEY_ON)\n\t&#123;\n\t\twhile(GPIO_ReadInputDataBit(GPIOx,GPIO_Pin) == KEY_ON);\n\t\treturn KEY_ON;\n\t&#125;\n\telse\n\t\treturn KEY_OFF;\n&#125;\n\nvoid Key_Set(void)&#123;\n\tif(RB1 == KEY_ON)&#123;\n\tLCD_Clear(White);\n\tflag_key_1++;\n\t\n\t&#125;\n\t\n\tif(RB4 == KEY_ON)&#123;\n\tLCD_Clear(White);\n\tflag_key_4++;\n\t\n\t&#125;\n\t\n\n&#125;\nvoid Led_init(void)&#123;\n\t\tGPIO_InitTypeDef GPIO_InitStructure;\n\t\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);\n  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\n\t\n\t\t//LED引脚配置\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8| GPIO_Pin_9| GPIO_Pin_10| GPIO_Pin_11| GPIO_Pin_12| GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15; // \n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;\n    GPIO_Init(GPIOC, &amp;GPIO_InitStructure);\n    //锁存器引脚\n    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;\n    GPIO_Init(GPIOD, &amp;GPIO_InitStructure);\n\n&#125;\t\t\t\t\n\nvoid Led_all_close()&#123;\n\t   GPIO_SetBits(GPIOC,GPIO_Pin_8| GPIO_Pin_9| GPIO_Pin_10| GPIO_Pin_11| GPIO_Pin_12| GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15);\n\t   GPIO_SetBits(GPIOD,GPIO_Pin_2);\n        GPIO_ResetBits(GPIOD,GPIO_Pin_2); \n&#125;\n\n\n4、systick中断模拟PWM分频比首先设置systick中断函数多久发送的周期，这个函数的形参数，是分频比\nSysTick_Config(SystemCoreClock/100000);\n\n$$中断频率=主频率/分频比$$\n$$=SystemCoreClock      /     (SystemCoreClock/100000)\n=100000HZ\nT=10us$$\n这样题目需要的1KHZ，即周期为1ms的PWM，和走起为500us的PWM就都能得到了。\n中断函数#include \"stm32f10x_it.h\"\nint cnt1,cnt2;\nextern u32 TimingDelay;\n\textern int duty1,duty2;\nvoid SysTick_Handler(void)\n&#123;\tcnt1++;\n\tcnt2++;\n\tTimingDelay--;\n\tif(cnt1&lt;duty1)&#123;\n\t\tGPIO_SetBits(GPIOA,GPIO_Pin_6);\n\n&#125;\n\tif(cnt1>duty1)&#123;\n\t\tGPIO_ResetBits(GPIOA,GPIO_Pin_6);\n\n&#125;\n\tif(cnt1==100)&#123;\n\t\tcnt1=0;&#125;\n\t\n\tif(cnt2&lt;(duty2/2))&#123;\n\n\t\tGPIO_SetBits(GPIOA,GPIO_Pin_7);\n&#125;\n\tif(cnt2>(duty2/2))&#123;\n\n\t\tGPIO_ResetBits(GPIOA,GPIO_Pin_7);\n&#125;\n\tif(cnt2==50)&#123;\n\t\tcnt2=0;&#125;\n&#125;\n\n结果初始状态\n\n波形\n总结：这次的题目还是比较简单的，难点就在与如何产生两个不同频率的PWM，如果只想到定时器产生PWM的话，由于题目规定的两个PWM的引脚是同一个定时器的两个端口，所以要设置成不同频率还是有点难度的，但如果软件模拟PWM，还是比较简单的。除此之外，这道题几乎没有难度，个人需要提升的点在于：需要行一步熟悉各个模块的配置过程。因为在正式比赛的时候是没有例程给你使用的。\n","slug":"十一届蓝桥杯嵌入式省赛","date":"2021-12-04T07:49:03.000Z","categories_index":"比赛项目","tags_index":"stm32","author_index":"祥瑞"},{"id":"e025b4b43a23185465e9613af8a1c518","title":"数码管动态显示（VHDL）","content":"VHDL动态显示4位数码管电路我这里的实验室通过拨码开关计数，然后通过数码管来显示，并没有对按键进行消抖处理。\n\n\n一、动态数码管是什么？实际上很多两个以上的数码管都是动态数码管，设计成这样的真正目的是为了节约硬件资源，使用少量的引脚就可以点亮多个数码管。\n多位数码管的数据端口实际上只有8个口，所有数码管的数据口都是连接到一个口上面的，然后每个数码管还都会有一个片选端口，控制这位数码管的开关。\n所以说，所有数码管都只能显示相同的数字，或者不显示。\n多个数码管显示数字的时候，我们实际上是轮流点亮数码管（一个时刻内只有一个数码管是亮的），利用人眼的视觉暂留现象（也叫余辉效应），就可以做到看起来是所有数码管都同时亮了，这就是动态显示，也叫做动态扫描。\n\n\n\n\n二、VHDL实现代码1、实体部分clk，每个FPGA板子不同的时钟源，需要查找对应的技术手册，我这里的是25MHZ，还是比较小的哈，我看网上一般都是50MHZ。\nLIBRARY IEEE ;\nUSE IEEE.STD_LOGIC_1164.ALL ;\nUSE IEEE.STD_LOGIC_unsigned.ALL;--因为使用到了从Integer类型转换到STD_LOGIC_VECTER\nENTITY shumaguan4 is \n\tPORT  (\n\tsegcs  : out STD_LOGIC_vector (3 DOWNTO 0);\t\t--四个数码管的片选信号，如果为0就打开\n\tQ\t\t : BUFFER INTEGER RANGE 0 TO 9999;   \t\t--显示的数字\n\tseg \t : out STD_LOGIC_vector (7 DOWNTO 0);\t\t--具体某个数码管要显示的数字\n\tkey\t : in STD_LOGIC;\n\tclk\t : in STD_LOGIC);\t\t\t\t\t\t\t \t\t--25Mhz,用于提供数码管刷新频率\n\t\nEND;\n\nARCHITECTURE\tFH1\tOF\t\tshumaguan4 \tIS\n\t\t\n\tSIGNAL num :  INTEGER RANGE 0 TO 9;\n\tSIGNAL cnt_200Hz:  INTEGER RANGE 0 TO 249999;\n\tSIGNAL segcs_SIFNAL  :  STD_LOGIC_vector (3 DOWNTO 0);\t\n\tBEGIN\n\n2、信号线部分num是用来存放当前显示数码管的数字，cnt_200HZ是用来做200HZ的计数，segcs_SIFNAL是为了代替segcs定义的信号线（比较输出信号不能拿来做判断，只能拿来赋值）\nSIGNAL num :  INTEGER RANGE 0 TO 9;\nSIGNAL cnt_200Hz:  INTEGER RANGE 0 TO 249999;\nSIGNAL segcs_SIFNAL  :  STD_LOGIC_vector (3 DOWNTO 0);\t\n\n3、计数部分CNT:\tPROCESS(key)\n\t\tBEGIN\n\t\t\t\t\tIF key'EVENT AND key = '1' THEN\n\t\t\t\t\t\t IF Q&lt;=9999 THEN  Q&lt;=Q+1 ;\n\t\t\t\t\t\t ELSE Q&lt;=0;\n\t\t\t\t\t\t END IF;;\n\t\t\t\t\tEND IF;\n\t\tEND PROCESS\tCNT;\n\n4、显示部分因为我们切换显示数码管，这个切换的频率还是需要适当设置的，不能一直直接放到主循环里面一直高频率的执行，那样会浪费资源，但是频率\n太低的话，切换不过来，达不到人眼的暂留效应，显示会不是很流畅。所以我们这里选择了200hz为切换频率。\nFF:\tPROCESS(clk)\n\t\tBEGIN\n\t\t\t\t\tIF clk'EVENT AND clk = '1' THEN\n\t\t\t\t\t\t IF cnt_200Hz&lt;100000 THEN  cnt_200Hz&lt;=cnt_200Hz+1 ;\n\t\t\t\t\t\t ELSE cnt_200Hz&lt;=0;\n\t\t\t\t\t\t END IF;\n\t\t\t\t\t\t \n\t\t\t\t\t\t IF\t\t(cnt_200Hz&lt;=25000)\t\t\t\tTHEN\tsegcs_SIFNAL &lt;= \"1110\";\n\t\t\t\t\t\t ELSIF \t((25000&lt;cnt_200Hz)AND(cnt_200Hz&lt;=50000))\t\tTHEN\tsegcs_SIFNAL &lt;= \"1101\";\n\t\t\t\t\t\t ELSIF\t((50000&lt;cnt_200Hz)AND(cnt_200Hz&lt;=75000))\t\tTHEN\tsegcs_SIFNAL &lt;= \"1011\";\n\t\t\t\t\t\t ELSE \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsegcs_SIFNAL &lt;= \"0111\";\n\t\t\t\t\t\t END IF;\n\t\t\t\t\t\t \n\t\t\t\t\tEND IF;\n\t\t\t\t\t\n\t\tEND PROCESS\tFF;\n\n我是废物，这个只是为了给自己一个总结哈，我还只是一个小菜鸡儿。\n","slug":"数码管动态显示(VHDL)","date":"2021-12-01T13:35:17.000Z","categories_index":"课程学习","tags_index":"FPGA","author_index":"祥瑞"},{"id":"3aa30f86d5e7a5fe52d49f283f39878f","title":"EDA课程学习","content":"EDA课程学习这个篇博客主要是我在完成我的EDA课程在学习通上面的章节练习时，做的笔记。\n(这个脑图是老师提高的哈，非常耐撕！)\n\n\n记忆宫殿\n\n\n\n英文\n中文\n\n\n\nISP\n在系统编程\n\n\nLUT（Look-Up-Table）\n查找表\n\n\nLAB\n逻辑阵列块\n\n\nFPGA\n现场可编程逻辑门阵列\n\n\nOTP\n一次性编程\n\n\nPLD\n可编程逻辑器件\n\n\nPROM\n只读存储器\n\n\nPLL\n锁相环\n\n\nASIC\n专用集成电路\n\n\n\n\n\nMC\n宏单元\n\n\n\ngenerate\n生成语句\n\n\nHDL\n硬件描述语言\n\n\nIP\n知识产权核\n\n\nSRAM\n静态随机存储器\n\n\nRTL\n寄存器传输级\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n记忆点：\n\nSTANDARD是默认打开的程序包\nCPLD 的基本功能模块    MC逻辑宏功单元\n在 VHDL 中,信号的数据传输是立即发生的\nCPLD通过可编程乘积项逻辑实现，基于与或阵列可编程\n综合的结果是不唯一的\n设计流程为:原理图/HDL 文本输入→功能仿真→综合→适配→时序仿真→编程下载→硬件测试。\n软 IP    提供用 VHDL 等硬件描述语言描述的功能块,但不涉及实现该功能块\n固 IP    以可执行文件的形式提交用户,完成了综合的功能块\n硬 IP     提供设计的最终产品掩膜\n仿真延时分为固有延时和仿真延时\nLUT 是存储在SRAM\n约束分别速度约束、面积约束、设计规则约束三种首先应满足速度约束\n适配器的功能是布局布线\nVHDL 的函数分为函数首和函数体两部分\n使用 LPM_ROM 实现一个 4 位乘法器（15×15）至少需要16*16个存储单元。 \n\n\n\n\n\n\n\n\n\nPAL/GAL\n与阵列可编程，或阵列固定（1，0）\n\n\nPLA\n与阵列可编程或阵列可编程（1，1）\n\n\nPROM\n与阵列固定或阵列可编程（0，1）\n\n\n硬件结构与基本概念固有延时固有延时也是惯性延时，是任何电子器件都存在的一种延时特性，主要物理机制是分布电容效应。固有延时需要考虑信号持续的时间，如果小于固有延迟，那么信号不会输出。\n传输延时传输延时：与固有延时相比，其不同之处在于传输延时时表达的是输入与输出之间的一种绝对延时关系。传输延时并不考虑信号持续的时间，它仅表示信号传输推迟或延迟了一个时间段，这个时间段即为传输延时。\nCPLD的可编程是什么结构可编程的与阵列和固定的或阵列组成，即与或阵列可编程\nFPGA使用了一种可编程逻辑的形成方法，即可编程的查找表结构。\n优化\n\n\n\n\n\n\n\n\n\n速度优化\n流水线设计\n寄存器配平\n关键路径法\n\n\n面积/资源优化\n串行化\n逻辑优化\n资源共享\n\n\n\nEDA软件开发流程\n综合-&gt;适配-&gt;配置（或者编程）\n\n\n\n综合\n产生网表文件\n\n\n\n适配\n将网表文件适配指定器件，产生最终的下载文件\n\n\n配置（编程）\n将适配参数的下载文件，下载到目标器件，CPLD叫编程，FPGA叫做配置\n\n\n仿真\n利用综合适配后产生的下载文件进行仿真\n\n\nbuffer：缓冲端口。它只允许内部回读输出的信号，即反馈。它的回读的信号是由内部产生、向外部输出的信号。\n语句:顺序语句必须放到进程里面（PROCESS）\nIF：（顺序）if rising_edge(Clock) THEN\n\t\t\tClk&lt;=NOT Clk;\n\t\tend if\n\n\n\ncase when：（顺序）case\t(key)\tis\n\twhen\t'1'\t=>\tled&lt;='1';\n\twhen\tother =>led&lt;='0';\n\n\n\nwhen else：（并行）A&lt;=\"111\" WHEN I(7)='1' ElSE\n\t   \"110\" WHEN I(6)='1' ElSE\n\t   \"101\" WHEN I(5)='1' ElSE\n\t   \"100\" WHEN I(4)='1' ElSE\n\t   \"011\" WHEN I(3)='1' ElSE\n\t   \"010\" WHEN I(2)='1' ElSE\n\t   \"001\" WHEN I(1)='1' ElSE\n\t   \"000\" WHEN I(0)='1' ElSE\n\t   \"111\";\n\n状态机：\n\n\nMoore摩尔\n输出取决于现态\n\n\n\nMealy米利\n输出取决于现态和输入\n\n\n","slug":"EDA课程学习","date":"2021-11-29T10:31:08.000Z","categories_index":"课程学习","tags_index":"FPGA","author_index":"祥瑞"},{"id":"459ae5c9f8e23040bef82e2e21f20699","title":"十二届蓝桥杯嵌入式省赛","content":"停车计费系统前言最近开始了22十二届蓝桥杯的培训，星期三的时候学弟陈给我说一起去试试一下去年的省题，但是我当时还是比较急的，前段时间的电赛，然后被隔离，回到正常的课程里面后，因为大三的课程还是比较多的，然后补了很多多作业，一直没有开始做，最后在星期五的下午，我看见学弟在做了，也就按耐不住做了起来哈哈😂🤣😅，然后我就从星期五下午6点到晚上2点实现了全部功能，抛去做其他事情的时间，一共花了我接近6个小时，正式比赛的时候应该是5个小时，虽然到时候是沉寂式5个小时，但因为比赛时封闭的，可能倒是，因为后面还有其他项目做，所以比较急的。平时其实不会这么肝哈就😁。\n关于题目这个题目是对我来说，难度是那种能做出来，但是还是有点费力的，主要的难点在于如何将将接收到的串口返回数组拆分成几个参量，去进行做分析处理。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n主要功能展示\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n改价格界面\n\n\n\n加钱\n\n\n\n减钱\n\n\n\n\n\n\n\n总体思路这道题是实际生活中，我们经常遇到的，假设一个停车场有10个车位，我是先给定义了一个结构体数组，每个数组即代表一个车位，车位的信息就包括，对应车位上车子的信息，有车牌号、车型，入库时间三个成员。同时设置了相同结构体“虚拟车”，也是具有这三个成员的。\n一旦串口发送信息过来，设置程序将串口接受数值，拆分为几个小数组，便于后边的计算，然后将这几个数组赋值给“虚拟车”的各个结构体变量。这样操作后，我们的当串口发送信息时，我们的“虚拟车”就会实时刷新得到便于处理的信息。然后时处理信息的部分，我们每次处理信息必须在接受串口数组完成后执行，而且只能进行一次。所以我们应该处理函数写道，串口接受完成后，触发的函数中。处理函数的话，主要的思想就是，先遍历着比较这10个车位中是否有何虚拟车一样的信息，（1）如果有那么就执行出库操作，计算时间价格，同时清空这个车位信息。（2）如果没有相同的车位信息，那么就执行入库操作，遍历这10个车位，如果遍历到这个车位时空的话，跳出遍历，同时将虚拟车的信息全部赋值给这个车位，完成入库操作。\n关键代码设计出入库的算法void panduanjinchu()&#123;\n    if(RXOVER)&#123; //这里做了一下限制，实现一点的报错功能\n\tif((USART_RXBUF[1]=='N')&amp;&amp;(USART_RXBUF[2]=='B')&amp;&amp;(USART_RXBUF[3]=='R')&amp;&amp;(USART_RXBUF[4]==':')&amp;&amp;(USART_RXBUF[9]==':'))&#123;\n\t\tUSART_SendString(\"\\n\");\n\t\tUSART_SendString(USART_RXBUF);\n\t\tUSART_SendString(\"\\n\");\n\t\tRXOVER = 0;\n\t\tiii++;//接受串口的次数，这里的1s是防抖,完成一次后执行的程序，不过后面好像没用了。。😂\n\t\t//判断出库,顺便计算价钱\n        //注意这里的panduan()函数就可以用来判断对应车位信息是否和虚拟车位相等。\n\t\tif((panduan(1)==1)||(panduan(2)==1)||(panduan(3)==1)||(panduan(4)==1)||(panduan(5)==1)||(panduan(6)==1)||(panduan(7)==1)||(panduan(8)==1))&#123;\tfor(i=1;i&lt;9;i++)&#123;\n            \tif((panduan(i)==1))&#123;//具体哪一位车出去\n\t\t\t\tcccc[i]=0;\t\t  //这个数组代表8个车位，对应车位空\n\t\t\t\tfor(j=0;j&lt;2;j++)&#123;\n\t\t\t\ttim_s1[j]=CHAR.cartime[j+8];\t\n\t\t\t\ttim_s2[j]=char1[i].cartime[j+8];//分别得到秒钟部分\n\t\t\t\t&#125;\t\t\t\t\t\t\t\n\t\t\t\ttime1=atoi(tim_s1);\n\t\t\t\ttime2=atoi(tim_s2);//将数组转化为数据，，便于计算\n\t\t\t\tfor(j=0;j&lt;2;j++)&#123;\n                  tim_s1[j]=CHAR.cartime[j+6];\n                  tim_s2[j]=char1[i].cartime[j+6]；\n                            \t&#125;\n\t\t\t\ttime1=time1+atoi(tim_s1)*60;\n\t\t\t\ttime2=time2+atoi(tim_s2)*60;//算上分钟的秒\n\t\t\t\t\t\t\t\n\t\t\t\tfor(j=0;j&lt;2;j++)&#123;\n\t\t\t\ttim_s1[j]=CHAR.cartime[j+4];\n\t\t\t\ttim_s2[j]=char1[i].cartime[j+4];\n\t\t\t\t&#125;\n\t\t\t\ttime1=time1+atoi(tim_s1)*3600;\n\t\t\t\ttime2=time2+atoi(tim_s2)*3600;//算上时钟的秒\n\t\t\t\tfor(j=0;j&lt;2;j++)&#123;\n\t\t\t\ttim_s1[j]=CHAR.cartime[j+2];\t\n\t\t\t\ttim_s2[j]=char1[i].cartime[j+2];\t\n\t\t\t\t&#125;\n\t\t\t\ttime1=time1+atoi(tim_s1)*3600*24;\n\t\t\t\ttime2=time2+atoi(tim_s2)*3600*24;//算上一天的秒\n\t\t\t\ttime=-time2+time1;\t\t\t//计算使用时间\n\t\t\t\ttime=time/3600+1;\t\t\t\t//这里的time代表小时，因为是按小时收费，所以未满1小时还是加了1\n\t\t\t\t//返回数据到串口\n\t\t\t\tsprintf(charge, \" %d\" , time);\n\t\t\t\tif(char1[i].carx=='C')&#123;\t\n\t\t\t\t\t\t\t\t\tUSART_SendString(\"C\");\n\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tUSART_SendString(\"V\");\t\t\n\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\tUSART_SendString(\"NBR\");\t\n\t\t\t\t\t\t\t\tUSART_SendString(\":\");\n\t\t\t\t\t\t\t\tUSART_SendString(CHAR.car1);\n\t\t\t\t\t\t\t\tUSART_SendString(\":\");\t\t\t\n\t\t\t\t\t\t\t\tUSART_SendString(charge);\n                              if(char1[i].carx=='C')&#123;\n\t\t\t\t\t\t\tsprintf(charge, \" %.2f\" , (time)*FCNBR);\n\t\t\t\t\t\t\tCNBR--;\n\t\t\t\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\telse if(char1[i].carx=='V')\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tVNBR--;\n\t\t\t\t\t\t\tsprintf(charge, \" %.2f\" , (time)*FVNBR);\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\tUSART_SendString(\":\");\n\t\t\t\t\t\t\tUSART_SendString(charge);\n                            \tqinglin(i);\t\n\t\t\t\t&#125;&#125;&#125;\n\t\telse&#123;//这里是判断入库，要先判断不是出库\t\n\tfor(i = 1;i&lt;10;i++)&#123;\n\t\tif(cccc[i]==0)&#123;//代表空车位\n\t\t\t\t\tif((CHAR.carx=='C'))&#123;\n\t\t\t\t\tCNBR++;\n\t\t\t\t\t&#125;\n\t\t\t\t\telse if((CHAR.carx=='V'))\n\t\t\t\t\t&#123;\n\t\t\t\t\tVNBR++;\n\t\t\t\t\t&#125;\t\t\t\t\t\t\n\t\t\t\t\telse&#123;\n\t\t\t\t\tUSART_SendString(\"EER\");\n\t\t\t\t\t&#125;\n\t\tcccc[i]=1;//1代表有车占了车位\n\t\tcharu(i);\t\n\t\ti=9;\t\n\t\t&#125;&#125;&#125;&#125;\n\telse&#123;\n\t\t\tRXOVER = 0;\n\t\t\tUSART_SendString(\"\\n\");\n\t\t\tUSART_SendString(\"err\");\n\t\t\tUSART_SendString(\"\\n\");\n\t\t&#125;&#125;\n    USART_ITConfig(USART2,USART_IT_RXNE,ENABLE);\n&#125;\n\n串口中断void USART2_IRQHandler(void)\n&#123;\n\t\n\tuint8_t temp;\n\t\n\tif(USART_GetITStatus(USART2,USART_IT_RXNE) != RESET)&#123;\n\t\tUSART_ClearITPendingBit(USART2,USART_IT_RXNE);\t\t\n\t\ttemp = USART_ReceiveData(USART2);\n\t\tUSART_RXBUF[RXCUNT] = temp;\n\t\tRXCUNT++;\t\t\t\t\t//这样会保证每次中断标志位都加一\n\t\tif((temp == 'x')||(RXCUNT==22) )&#123;\t\t\t\t\t\n\t\t\tRXCUNT = 0;\n\t\t\tRXOVER = 1;  //接收完成标志位置位\n\t\t\tUSART_ITConfig(USART2,USART_IT_RXNE,DISABLE);\n\t\t\t\t\t\t\t\t\t\t&#125;&#125;&#125;\n\n\n\n拆分串口接受数组void date()&#123;\n\tCHAR.carx=USART_RXBUF[0];\n\t\tfor(i=5;i&lt;9;i++)&#123;\n\t\tCHAR.car1[i-5]=USART_RXBUF[i];\n\t\t\t\t\t\t&#125;\n\t\tfor(i=10;i&lt;22;i++)&#123;\n\t\tCHAR.cartime[i-10]=USART_RXBUF[i];\n\t\t\t\t\t\t&#125;&#125;\n\n\n\n归纳总结这个训练项目，主要难度对于我，主要在设计出入库的算法上和对串口接受到的数据进行处理分析，对现在我的是一次不错的锻炼。\n","slug":"十二届蓝桥杯嵌入式省赛","date":"2021-11-21T08:05:29.000Z","categories_index":"比赛项目","tags_index":"stm32","author_index":"祥瑞"},{"id":"81d693b10474421070e94aab75f243ef","title":"16届智能车比赛","content":"引言现在是2021年10月29日，距离16届智能车比赛已经过去了2个多月了，马上17届智能车也要开始了，一直没有做总结是有原因的，因为当时真的真的真的很惨，甚至没有取得成绩（当时的规则是跑完一圈就可以拿优秀奖），对不起一直陪在我们身边的徐老师，更对自己没有努力而难过。其实很刚结束比赛的时候，就像给自己一个总结的，但当给总结失败原因的时候，那种感觉，我真的很讨厌，就像是在为自己找借口一样，像是又一次重复了一次失败的过程，而且当时觉得自己应该没什么总结的东西，彻底摆烂！！！但是我知道。或许可能没有得到很多的经验，但我也想认真总结一次，分析失败原因，同时记录下这次失败，我想这会是一个很棒的“伤疤！”记得当时是2021年的6月份，我报名参加了电赛，所以终于把电脑搬到了实验室，逃离了寝室，那段时间在实验室就是日常学习和看一些东西，没有什么事做，电赛还有很久才开始。所以当教我们c++的徐文老师就叫找几个人来参加今年的智能车比赛，我们立马就答应了。\n伤疤展示\n \n\n问题：时间观念、态度：由于只有3人参赛，且只有两个月的时间，要做很多事，比如购买配件大多数的电阻电容是可以在一个店里面买的，但是还有很多是要综合考虑后去购买的，还有一些元件需要分别在几个店铺购买。当时大大小小的订单加起来应该有50多件，因为第一次购买采购，数量个种类有些出入，而这一届赛道又发生了变化，铺赛道，铺电磁线，因为赛道在过道始终回被人踩脏，灯光昏暗导致误判，而且还有日常课程，电赛等等等等，这些事情逐渐扰乱了我们这个三人小队对时间的概念，消耗了我们的耐心。后来发现其实两个月很短，所以这次我们要充分准备，把战线拉长，在赛题一出就开始准备，稳扎稳打！！\n技术贫瘠：本来是要叫一个学长带队的，结果没有一个学长愿意（毕竟他们马上大四了很忙😂），就造成了我们去参加西部赛区的同学全是大二的，并没有什么参加大型比赛的经历，本身的知识和工程经验也没有完全入门，而且只有两个月的时间就比赛了。因为西部赛需要自己做PCB，我们第一时间就是想参照厂商的板子做，但因为上面的元件都是贴片的，并且我们没有为单片机设计母版的经历，所以我们去问了教我们PCB课程的老师。但老师说并且我们现在的知识量来说要做出来很难😂😂就说不好搞不好搞，然后我们就没有去问他了😂😂。最后我们是去咸鱼买了别人的PCB资源直接去打板😂😂。虽然是别人做好的PCB哈，但是要自己做出成品来，运行还是要一定心思的。时间还剩2个月，我开始是觉得两个月时间应该能搞吧，但我们高估我们自己了，因为参加的西部赛，赛车的PCB和硬件结构都要我们自己搭，就算当时有买别人的例程改，也要一些时间去看懂，而且因为没接触过这种编译环境，也需要时间去熟悉。焊接问题，前面说了没有焊接过贴片的PCB，所以第一个母版出来的时候，有一根线是虚焊的地方，好在后面的板子都撑到了结束。这个问题的解决方法只有自己学习提高了，我相信现在的我能比之前做的更好了。\n缺乏请教对象：由于疫情（可恶的疫情👿😈😈），15届我们学校没有参赛，而且16届的我们只有1只队伍参赛，都是大二的同学，相当于重0开始,就算请教老师和学长也不是法子，有些问题是要做才能了解的，现在想来我们应该多加网上的交流群，与一同参赛的同学们请教。\n团队交流问题：个人意见！！这是最大的问题，我和队友没有随时的相互交流，我们进行了分工后，我负责硬件方面的，另外一个是软件调试的。在硬件方面，因为有参考，不会有很多的变数，我需要将车模搭好，pcb焊接上，组装好，后面有软件调试实在不行的地方，或者说车模发生了损坏我在去调整车模。而在将车模组装好后，事情就开始不对劲起来了，我们软件的同学就开始一个人默默的调试，不太说话，每次都是我要去问他，他才说他做了那些东西，经常是隔1天我去问他，他才浅浅地说几句，不能好好交流，而且因为调试缓慢，硬件部分运行正常，这导致我不得不自己去进行软件调试去跟进，然而我们两的调试又没有完全一样，最终还是会舍弃一个人的方案，会被舍弃的那个人的积极性被消耗。没有将团队的优势发挥出来，并且没有什么指导的学长和老师与之交流。所以在选择组队的时候一定要和乐于与人交流的同学组队，虽然又分工但是做的同时要和队友说明自己这样做的原因的什么，只有队友都了解全貌后，大家才能亲密无间的合作啊❤❤，发挥出团队的优势。切记不要有“我干完了这件事我就没事做了”的思想，分工是分担工作，不是单打独斗！\n","slug":"智能车比赛","date":"2021-10-29T05:25:21.000Z","categories_index":"","tags_index":"智能车","author_index":"祥瑞"},{"id":"5ff84a8c355f6485d89b09014ee560cf","title":"C井定时器","content":"使用c#编写定时器程序这是我第一个C#程序，是在B站跟着杜洋学习的，他的视频风格是比较愉快的，而且很生动仔细，一教一学的方式，感觉很好，希望我玩的开心！\n创建工程\n\n为窗口添加窗体部件\n\n为窗口内部添加逻辑\n\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel;\nusing System.Data;\nusing System.Drawing;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\n\nnamespace WindowsFormsApp1\n&#123;\n    public partial class Form1 : Form\n    &#123;\n        int count;//当前时间\n        int time;//设置的定时间\n        public Form1()\n        &#123;\n            InitializeComponent();\n        &#125;\n\n        private void Form1_Load(object sender, EventArgs e)//在启动exe程序后，显示窗口之前，执行的语句\n        &#123;\n            int i;\n            for (i = 1; i &lt; 50; i++)\n            &#123;\n                comboBox1.Items.Add(i.ToString() + &quot; 秒&quot;);//为下拉输入的box添加选项\n            &#125;\n            \n            label3.Text = &quot;0秒&quot;;                         //为label（标签），添加文字\n\n\n        &#125;\n\n        private void Timer1_Tick(object sender, EventArgs e)//相当于单片机中的定时器中断函数，这里的是1000ms，即1s作为一个周期，1s运行一次该程序\n        &#123;\n            count++;                                            //每秒钟加一，相当于现在时间的秒数\n            label3.Text = (time -count).ToString() + &quot;秒&quot;;      //计算剩余秒数（时间），并且显示到标签\n            progressBar1.Value = count;                         //将时间数设为进度条的进度量，每秒发生一次改变，效果为进度条逐渐上升\n\n            if (count == time)\n            &#123;\n                timer1.Stop();\n                System.Media.SystemSounds.Asterisk.Play();\n                MessageBox.Show(&quot;时间到了！&quot;, &quot;提示&quot;);\n                //结束这一次的计时\n                //为下一次计时做准备\n                progressBar1.Value = 0;//初始化进度条最大容量\n                button1.Text = &quot;开始计时&quot;;//初始化按钮显示内容1\n                count = 0;\n                time = 0;\n            &#125;\n\n        &#125;\n\n        private void Button1_Click(object sender, EventArgs e)//单击按下按钮后，需要执行的程序\n        &#123;\n                if (button1.Text == &quot;开始计时&quot;)\n                &#123;\n                                \n                    time = Convert.ToInt16(comboBox1.Text.Substring(0, 2));//转化成10进制\n\n                    progressBar1.Maximum = time;//进度条开始的数值，即进度条最大数值\n\n                timer1.Start();//开始计时\n                    button1.Text = &quot;停止计时&quot;;\n                &#125;\n                else\n                &#123;\n\n                    button1.Text = &quot;开始计时&quot;;\n                    timer1.Stop();//停止计时\n\n                &#125;\n        &#125;\n\n        private void Label3_Click(object sender, EventArgs e)\n        &#123;\n\n        &#125;\n\n        private void ComboBox1_SelectedIndexChanged(object sender, EventArgs e)\n        &#123;\n\n        &#125;\n\n    &#125;\n&#125;\n\n生成exe文件","slug":"C井定时器","date":"2021-10-21T03:24:21.000Z","categories_index":"上位机","tags_index":"c#","author_index":"祥瑞"},{"id":"cdd0ed69b5efeea0c1519efc87c7f99f","title":"MD常用语句","content":"图片1,使用html方法引入\n&lt;img src=\"https://alexcld.com/images/pengyuyan.jpg\" width=256 height=256 />\n\n&lt;img src=\"https://alexcld.com/images/pengyuyan.jpg\" width=\"50%\" height=\"50%\" />可以使用百分比\n固定图片大小：width=256,height=256设置的是显示图像的尺寸，src后面接的就是图像的链接，还可以使用百分比的方式来给width,height传参\n图片在线生成链接的三种方法\n1.使用图床\n很多网站为了节省自身的内存空间，提高图片的访问速度，会使用一些第三方的平台进行上传图片。这样的平台便叫作图床。\n\n参考链接https://zhuanlan.zhihu.com/p/81713842\n2.上传到一些平台上面，然后右键图片，选择复制图片的链接，比如CSDN，或者QQ等。\nhttps://blog.csdn.net/zhouhangzooo/article/details/90234581)\n超链接参考网站[ppt](https://space.bilibili.com/20259914/dynamic?spm_id_from=444.41.0.0)\n效果：稚辉君的b站主页\n代码块作用：使代码显示到网页上，并且不运行，作展示用方法：空一行，换行后，按一下‘TAB’键，缩一下近，然后跟上你要显示到网页上的代码examplel:\n这是需要展示的代码\n```key\n这也是需要展示的代码\n```\n\n\n\n播放视频（B站）&lt;div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\">&lt;iframe \nsrc=\"//player.bilibili.com/player.html?bvid=BV1EL4y187Hd&amp;cid=164144278&amp;page=1\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> &lt;/iframe>&lt;/div>\n\n只需要修改对应bv好就行了。\n","slug":"MD常用语句","date":"2021-10-18T08:25:35.000Z","categories_index":"hexo编辑","tags_index":"记录","author_index":"祥瑞"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"This is my first blog Test  这是我第一次建站，折腾了3天终于把网站弄好了，翻遍了B站hexo相关视频，查错误代码，期间还重装了一次系统（可后面发现白重装了，真的蚌埠住了😭😭😔😔），但感觉输入网址打开网站的一瞬间，我感觉有一种新世界的大门打开的感觉，所以希望自己能在这里玩的开心。\n  今后我会在这里分享自己的一些小项目、学习心得、以及摆龙门阵ヾ(≧▽≦*)o。\n","slug":"Hello-World","date":"2021-10-10T05:44:25.000Z","categories_index":"taking","tags_index":"Hello World","author_index":"祥瑞"}]