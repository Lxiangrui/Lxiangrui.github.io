{"title":"ARMV8_汇编","uid":"1b233e39e81d8746e996add6970c9f45","slug":"ARMV8-汇编","date":"2022-04-08T05:37:48.000Z","updated":"2022-04-09T09:52:59.649Z","comments":true,"path":"api/articles/ARMV8-汇编.json","keywords":null,"cover":"https://s1.ax1x.com/2022/04/09/Li1OZq.jpg","content":"<p>指令集手册      <a href=\"https://developer.arm.com/documentation/ddi0596/2021-09/Base-Instructions\">https://developer.arm.com/documentation/ddi0596/2021-09/Base-Instructions</a></p>\n<h2 id=\"ARMV8发明的原因：\"><a href=\"#ARMV8发明的原因：\" class=\"headerlink\" title=\"ARMV8发明的原因：\"></a>ARMV8发明的原因：</h2><ol>\n<li><p>三大动因 //应对<strong>大内存</strong> <strong>虚拟化</strong>和安全的需求        //大内存(Large Memory): 突破32位机的4G空间限制  -&gt; 硬件越来越强，软件越来越复杂         //虚拟化(Virtualization): 隔离 高效  -&gt; 虚拟机               //安全(Security):  物理隔离  -&gt; 交易支付，隐私数据安全 </p>\n<p>还有pc端的涉足，比如新款的苹果笔记本都是arm架构</p>\n</li>\n<li><p>三大创新  //执行状态,异常级别，和安全模式 </p>\n</li>\n<li><p>执行状态  //AArch64 和 AArch32 两种可切换           //AArch64: 新增A64(ARM 64bit)指令集 -&gt; 大内存(突破4G限制)         //AArch32: 可用以前A32(ARM 32bit)指令集和 T32(Thumb 32bit)指令集 -&gt; 向前兼容 </p>\n</li>\n<li><p>异常级别  //EL0(应用) &lt; EL1(OS) &lt; EL2(虚拟化) &lt; EL3(安全固件) -&gt; 替代啰嗦的工作模式 </p>\n</li>\n<li><p>安全模式  //分为正常世界 和 安全世界  -&gt; 真正的安全(物理隔离,如支付场景)   </p>\n</li>\n</ol>\n<h3 id=\"多核处理器Z\"><a href=\"#多核处理器Z\" class=\"headerlink\" title=\"多核处理器Z\"></a>多核处理器Z</h3><p><img src=\"https://i.niupic.com/images/2022/03/21/9WQN.png\"></p>\n<h3 id=\"内存管理单元MMU\"><a href=\"#内存管理单元MMU\" class=\"headerlink\" title=\"内存管理单元MMU\"></a>内存管理单元MMU</h3><p><img src=\"https://i.niupic.com/images/2022/03/21/9WQQ.png\"></p>\n<p>内存管理单元使得上层应用用的内存空间映射到物理空间。</p>\n<h2 id=\"ARMv8寄存器框架\"><a href=\"#ARMv8寄存器框架\" class=\"headerlink\" title=\"ARMv8寄存器框架\"></a>ARMv8寄存器框架</h2><p><img src=\"https://i.niupic.com/images/2022/03/21/9WQR.png\"></p>\n<p>现在的v8是32位的所以寄存器是64bit</p>\n<h3 id=\"31个通用寄存器\"><a href=\"#31个通用寄存器\" class=\"headerlink\" title=\"31个通用寄存器\"></a>31个通用寄存器</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">X<span class=\"token operator\">/</span>W  <span class=\"token comment\">//X是64位  W是低32位 ARMv7 中使用Bank来减少异常的延迟 //然而使用的寄存器都不到一半</span>\n\nAArch64 执行状态\t具有 <span class=\"token number\">31</span> × <span class=\"token number\">64</span> 位通用寄存器 <span class=\"token comment\">//可在所有时间和所有异常级别访问\t</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"特殊寄存器\"><a href=\"#特殊寄存器\" class=\"headerlink\" title=\"特殊寄存器\"></a>特殊寄存器</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">XZR     <span class=\"token comment\">//零寄存器: 用作源寄存器时读为零，用作目标寄存器时丢弃结果\t</span>\nSP      <span class=\"token comment\">//堆栈指针 (每个异常级别，独有一个副本SP_ELn)</span>\nPC      <span class=\"token comment\">//程序计数器</span>\nSPSR    <span class=\"token comment\">//发生异常时，存储处理器状态(类似于 ARMv7 中的 CPSR)</span>\nELR_EL  <span class=\"token comment\">//异常链接寄存器\t保存导致异常的指令的地址\t</span>\n\nPSTATE   <span class=\"token comment\">//可独立访问的处理器状态的寄存器组 (取代 CPSR的状态字段)</span>\nNZCV  <span class=\"token comment\">//条件标志</span>\n      <span class=\"token comment\">//bit[31:29]: N Z C V  </span>\n      <span class=\"token comment\">//源头：搜索NZCV 在https://developer.arm.com/documentation/ddi0595/2021-09/AArch64-Registers</span>\n      <span class=\"token comment\">//mrs X0, NZCV      </span>\nDAIF  <span class=\"token comment\">//中断屏蔽位(为1时屏蔽)</span>\n      <span class=\"token comment\">//bit[9:6]: D A I F  D(断点观察点)   A:SError  I(IRQ)  F(FIQ)</span>\nCurrentEL <span class=\"token comment\">//当前的异常级别  </span>\n          <span class=\"token comment\">//bit[3:2]: 00(EL0)  01(EL1) 10(EL2) 11(EL3)      </span>\n          <span class=\"token comment\">// mrs x1, CurrentEL   可独立访问          </span>\nSPSel <span class=\"token comment\">//选择堆栈指针的异常级别 </span>\n      <span class=\"token comment\">//bit[0]:   0(都用SP_EL0)   1(用对应的SP_ELx) </span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"系统寄存器\"><a href=\"#系统寄存器\" class=\"headerlink\" title=\"系统寄存器\"></a>系统寄存器</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">寄存器手册 <span class=\"token comment\">// https://developer.arm.com/documentation/ddi0595/2021-09?lang=en</span>\nSCTLR  <span class=\"token comment\">//系统控制机器： 如MMU、缓存和对齐检查\t</span>\nTTBR0_EL1 <span class=\"token comment\">//转换表基址寄存器0  -> 物理空间 映射 应用空间 </span>\nTTBR1_EL1 <span class=\"token comment\">//转换表基址寄存器1  -> 物理空间 映射 内核空间</span>\nMPIDR        <span class=\"token comment\">//多处理器关联寄存器</span>\nICC_SRE_EL3  <span class=\"token comment\">//中断控制寄存器</span>\nESR_EL      <span class=\"token comment\">//异常综合症寄存器: 包括有关异常原因的信息</span>\nHCR_EL      <span class=\"token comment\">//管理程序配置寄存器： 控制虚拟化设置和捕获 EL2 的异常     </span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"向前兼容\"><a href=\"#向前兼容\" class=\"headerlink\" title=\"向前兼容\"></a>向前兼容</h3><p>64位机可以兼容32位机</p>\n<p><img src=\"https://i.niupic.com/images/2022/03/21/9WR9.png\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">在 AArch32 中执行时，无法访问 AArch64 寄存器的高 32 位 &#x2F;&#x2F;它使用 32 位 W 寄存器(相当于32 位 ARMv7 寄存器)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<h3 id=\"ARMV8异常级别\"><a href=\"#ARMV8异常级别\" class=\"headerlink\" title=\"ARMV8异常级别\"></a>ARMV8异常级别</h3><p>减少了异常模式，现在只有4个级别的异常，分别是应用、系统、虚拟化、底层</p>\n<p>多了两个安全级别，运行一些厂商给库，一般不要去改这些东西</p>\n<p><img src=\"https://i.niupic.com/images/2022/03/21/9WRh.png\"></p>\n<h2 id=\"环境搭建-用qemu-gdb-vscode-》实现特权寄存器的访问\"><a href=\"#环境搭建-用qemu-gdb-vscode-》实现特权寄存器的访问\" class=\"headerlink\" title=\"环境搭建: 用qemu+ gdb + vscode -》实现特权寄存器的访问\"></a>环境搭建: 用qemu+ gdb + vscode -》实现特权寄存器的访问</h2><p>目的是实现模拟ARMv8的寄存器调试，之前是使用的keil但是，keil不支持armv8所以使用了新的平台来调试。</p>\n<p><img src=\"https://i.niupic.com/images/2022/03/21/9WRl.png\"></p>\n<h3 id=\"qemu：\"><a href=\"#qemu：\" class=\"headerlink\" title=\"qemu：\"></a>qemu：</h3><p>是一个虚拟机模拟器，原因是直接在应用层调试机器的寄存器，会报错，所以模拟了一个虚拟机来调试。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">直接在应用层运行u<span class=\"token operator\">-</span>boot和内核不行 <span class=\"token comment\">//因是不同地址空间</span>\n但可以用模拟器在应用空间模拟调试 \n\n\n用qemu原因 <span class=\"token comment\">//不能用$ gdb vmlinux调试内核，因在应用空间，不能运行内核空间的程序</span>\n\t   <span class=\"token comment\">//故用模拟器qemu来做，在应用空间模拟一个完整的系统。</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h4 id=\"ssh登录后-gdb调试-c-c-程序：\"><a href=\"#ssh登录后-gdb调试-c-c-程序：\" class=\"headerlink\" title=\"ssh登录后 gdb调试 c/c++程序：\"></a>ssh登录后 gdb调试 c/c++程序：</h4><h5 id=\"创建工程：\"><a href=\"#创建工程：\" class=\"headerlink\" title=\"创建工程：\"></a>创建工程：</h5><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">新开远程窗口   <span class=\"token comment\">//点远程电脑图标 ->  点192.168.10.237 旁的加号 </span>\n打开工作目录   <span class=\"token comment\">//点 打开文件夹 -> 选工作目录(如 /home/yhbd/bsp)</span>\n新建项目文件夹 <span class=\"token comment\">//点 +号图标（新建文件夹）-> 输入文件夹名（如hello)  </span>\n新建程序文件   <span class=\"token comment\">// 点hello -> 点 +号图标（新建文件）-> 输入文件名（如main.c)   </span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"直接安装qemu\"><a href=\"#直接安装qemu\" class=\"headerlink\" title=\"直接安装qemu\"></a>直接安装qemu</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">sudo apt<span class=\"token operator\">-</span>get instal qemu<span class=\"token operator\">-</span>system<span class=\"token operator\">-</span>arm\t\n$ qemu<span class=\"token operator\">-</span>system<span class=\"token operator\">-</span>aarch64 <span class=\"token operator\">-</span>h <span class=\"token comment\">// 查看全部帮助信息</span>\n$ qemu<span class=\"token operator\">-</span>system<span class=\"token operator\">-</span>aarch64 <span class=\"token operator\">--</span>version\n QEMU emulator version <span class=\"token number\">2.11</span><span class=\"token number\">.1</span><span class=\"token punctuation\">(</span>Debian <span class=\"token number\">1</span><span class=\"token operator\">:</span><span class=\"token number\">2.11</span><span class=\"token operator\">+</span>dfsg<span class=\"token operator\">-</span><span class=\"token number\">1u</span>buntu7<span class=\"token punctuation\">.</span><span class=\"token number\">38</span><span class=\"token punctuation\">)</span>\n <span class=\"token function\">Copyright</span> <span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token number\">2003</span><span class=\"token operator\">-</span><span class=\"token number\">2017</span> Fabrice Bellard and the QEMU Project developers\n\t \t\n$ qemu<span class=\"token operator\">-</span>system<span class=\"token operator\">-</span>aarch64 <span class=\"token operator\">-</span>machine help <span class=\"token comment\">//查看支持的machine</span>\n$ qemu<span class=\"token operator\">-</span>system<span class=\"token operator\">-</span>aarch64 <span class=\"token operator\">-</span>cpu help <span class=\"token comment\">//查看machine支持的cpu类型</span>\nWhen using <span class=\"token operator\">-</span>nographic<span class=\"token punctuation\">,</span> press <span class=\"token string\">'ctrl-a h'</span> to get some help\n\n版本太老  <span class=\"token comment\">/*不支持A57 需源码编译\n\t 启动内核时会报错\n\trom: requested regions overlap (rom bootloader. free=0x000000004238ea00, \n         addr=0x0000000040000000)\n\tqemu-system-aarch64: rom check and register reset failed\n\t大概率是qemu版本问题。可考虑下载qemu源码，本地编译qemu二进制。   \n     */</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"源码编译qemu\"><a href=\"#源码编译qemu\" class=\"headerlink\" title=\"源码编译qemu\"></a>源码编译qemu</h3><p>因为ubuntu这个版本系统安装的qemu版本太低了，所以我们需要在官站上下载稳定版</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">https<span class=\"token operator\">:</span><span class=\"token comment\">//www.qemu.org/download/ 下载最新的稳定版本 qemu-6.2.0-rc2.tar.xz</span>\n\t        <span class=\"token comment\">//注：翻墙下载，用在板子上直接下载太慢了 wget https://download.qemu.org/qemu-6.2.0-rc2.tar.xz</span>\n<span class=\"token operator\">></span> scp qemu<span class=\"token operator\">-</span><span class=\"token number\">6.2</span><span class=\"token number\">.0</span><span class=\"token operator\">-</span>rc2<span class=\"token punctuation\">.</span>tar<span class=\"token punctuation\">.</span>xz yhbd@<span class=\"token number\">192.168</span><span class=\"token number\">.10</span><span class=\"token number\">.237</span><span class=\"token operator\">:</span><span class=\"token operator\">/</span>home<span class=\"token operator\">/</span>yhbd<span class=\"token operator\">/</span>bsp\n$ cd <span class=\"token operator\">~</span><span class=\"token operator\">/</span>bsp\n$ tar <span class=\"token operator\">-</span>xvf qemu<span class=\"token operator\">-</span><span class=\"token number\">6.2</span><span class=\"token number\">.0</span><span class=\"token operator\">-</span>rc2<span class=\"token punctuation\">.</span>tar<span class=\"token punctuation\">.</span>xz\n$ cd qemu<span class=\"token operator\">-</span><span class=\"token number\">6.2</span><span class=\"token number\">.0</span><span class=\"token operator\">-</span>rc2\n\n$ <span class=\"token punctuation\">.</span><span class=\"token operator\">/</span>configure  <span class=\"token comment\">/* 配置，报错解决如下\n   报错：ERROR: Cannot find Ninja\n   解决：sudo apt-get install ninja-build\n   \n   重运行./configure 还是会报很多错。\n      ERROR: Dependency \"pixman-1\" not found, tried pkgconfig\n   都是因为缺少软件，建议安装下面的\n  $ sudo apt-get install build-essential zlib1g-dev pkg-config libglib2.0-dev \n  $ sudo apt-get install binutils-dev libboost-all-dev autoconf libtool libssl-dev \n  $ sudo apt-get install libpixman-1-dev libpython-dev python-pip python-capstone virtualenv   \n\n   看到下面的信息表示成功了\n    Subprojects\n    libvhost-user                : YES\n\n\t\tFound ninja-1.8.2 at /usr/bin/ninja\n  \n   */</span>\n$ make <span class=\"token operator\">-</span>j4  <span class=\"token comment\">//4核并发编译，利用多核CPU并发能力</span>\n           <span class=\"token comment\">//最好用串口运行，因编译时间太长，而vscode ssh登录运行，容易超时退出。</span>\n           <span class=\"token comment\">//而且用串口运行，vscode 可以做别的事，相互不干扰</span>\n$ sudo make install\n\n<span class=\"token comment\">//查看版本，源码编译的，qemu它支持不同的硬件平台的虚拟，不仅是ARM</span>\n$ qemu<span class=\"token operator\">-</span>arm <span class=\"token operator\">--</span>version\n   qemu<span class=\"token operator\">-</span>arm version <span class=\"token number\">6.2</span><span class=\"token number\">.92</span>\n   <span class=\"token function\">Copyright</span> <span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token number\">2003</span><span class=\"token operator\">-</span><span class=\"token number\">2021</span> Fabrice Bellard and the QEMU Project developers\n$ qemu<span class=\"token operator\">-</span>riscv64 <span class=\"token operator\">--</span>version\n   qemu<span class=\"token operator\">-</span>riscv64 version <span class=\"token number\">6.2</span><span class=\"token number\">.92</span>\n   <span class=\"token function\">Copyright</span> <span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token number\">2003</span><span class=\"token operator\">-</span><span class=\"token number\">2021</span> Fabrice Bellard and the QEMU Project developers\t\n\n$ qemu<span class=\"token operator\">-</span>system<span class=\"token operator\">-</span>aarch64 <span class=\"token operator\">-</span>cpu help <span class=\"token comment\">//查看machine支持的cpu类型，发现支持A57</span>\n  cortex<span class=\"token operator\">-</span>a53\n  cortex<span class=\"token operator\">-</span>a57\n  cortex<span class=\"token operator\">-</span>a72<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"最简单\"><a href=\"#最简单\" class=\"headerlink\" title=\"最简单\"></a>最简单</h3><h4 id=\"start-s\"><a href=\"#start-s\" class=\"headerlink\" title=\"start.s\"></a>start.s</h4><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">.globl\t_start\n_start:\n    mov x0, #1\n    ldr w1, &#x3D;0x778899\n    add x0, x0, x1\n    mrs x3, CurrentEL\nreset_end:\n    b reset_end<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h4 id=\"makefile\"><a href=\"#makefile\" class=\"headerlink\" title=\"makefile\"></a>makefile</h4><pre class=\"line-numbers language-malefile\" data-language=\"malefile\"><code class=\"language-malefile\">CC &#x3D; aarch64-linux-gnu-gcc\nLD &#x3D; aarch64-linux-gnu-ld\n\nCFLAGS &#x3D; -g -O0 -nostdlib -nodefaultlibs\n\nstart: start.o\n\t$(LD) -o $@ $^\n\n%.o: %.S\n\t$(CC) $(CFLAGS) -c $&lt; -o $@\n\n.PHONY: clean\n\nclean:\n\t-rm start.o\n\t-rm start\t<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<h2 id=\"ARMv8-汇编指令\"><a href=\"#ARMv8-汇编指令\" class=\"headerlink\" title=\"ARMv8 汇编指令\"></a>ARMv8 汇编指令</h2><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">b.ne    label    &#x2F;&#x2F;不等时跳转\ncbz\tw10, 1f\t &#x2F;&#x2F;w10值等于0的适合，跳转导1f\t\nret              &#x2F;&#x2F;子程序返回指令，返回地址默认保存在LR（X30），代替了mov pc,lr\n\nldr \tx0,&#x3D;__main　 &#x2F;&#x2F;大范围的地址读取：把标号__main（地址）读入x0\nadr     x0,vector    &#x2F;&#x2F;小范围的地址读取：把标号vector（地址）读入x0,标号距当前指令PC的偏移小于1M\nstp\tx29, x30, [sp, #-16]!   \n    &#x2F;&#x2F;入栈：把x29, x30 存储到sp-16指向的空间后,sp自减16 (因寄存器是8字节，栈是向下生长故是 -16）                              \n    &#x2F;&#x2F;类似前索引： *(sp-16) &#x3D; x29,x30   sp&#x3D;sp-16 （!使得sp能自更新）  把 x29,x30看成整体              \n    &#x2F;&#x2F;stp只支持2个寄存器，代替了复杂的stmfd  (64位汇编，取消了批量操作指令)     \nldp \tx29, x30, [sp],#16   &#x2F;&#x2F;出栈: 把sp指向的空间内容载入到x29, x30后，sp加16\n                             &#x2F;&#x2F;类似后索引: x29,x30&#x3D;*sp  sp&#x3D;sp+16   \n\nmrs\tx0, sctlr_el1   &#x2F;&#x2F;读sctlr_el1内容到x0  (注：系统寄存器，都通过mrs msr来操作)\nmsr  \tsctlr_el1, x0   &#x2F;&#x2F;写x0内容到 sctlr_el1\nsvc     #2\t    &#x2F;&#x2F;系统调用指令(触发一个同步异常,cpu则会陷入EL1)\n\n.global  _start     &#x2F;&#x2F;声明_start 为全局符号(让链接脚本能看到)\n.quad  0x3FA0       &#x2F;&#x2F;在存储器中分配8个字节，初值设为0x3FA0\n.align  4           &#x2F;&#x2F;2^4 &#x3D;16 字节对齐 ， 预留空间\n.macro  myAdd, x,y  &#x2F;&#x2F;宏函数， 类似 myAdd(x, y) \n    add \\x,\\x,\\y\n.endm    \nmyAdd  x0,x2<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">b.ne \tlable\t &#x2F;&#x2F;不等时跳转到标号，相对于咱v7的，多了一个点，n代表ni，e代表相等\ncbz\tw10, 1f\t \t &#x2F;&#x2F;w10值等于0的适合，跳转导1f\t\t\t1f函数是代表函数名为“1”，我们在调用的时候，只需要写‘1’就好了\t\nret              &#x2F;&#x2F;子程序返回指令，返回地址默认保存在LR（X30），代替了mov pc,lr\t，返回到函数调用的地方<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"例-延时函数\"><a href=\"#例-延时函数\" class=\"headerlink\" title=\"例: 延时函数\"></a>例: 延时函数</h3><p>是一个软件延迟，而且延迟时间很少</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">.globl\t_start\t\t\t\t\n_start:\n    mov x0,#3\n    bl  delay\n\nreset_end:\n    b reset_end\n\ndelay:\t\n    ldr\t x4,&#x3D;0x03\nloop_delay:\n    sub     x4,x4,#1\n    cmp     x4,#0\n    cbz     x4,delay_end        \n    b.ne    loop_delay\ndelay_end:      \n    ret   <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"宏函数\"><a href=\"#宏函数\" class=\"headerlink\" title=\"宏函数\"></a>宏函数</h3><p>注意在函数中使用，形式参数的时候，需要在它前面打一个” / “ </p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">.macro  myAdd, x,y      &#x2F;&#x2F;宏函数， 类似 myAdd(x, y) \t\n        add \t\\x,\\x,\\y\n.endm    \nmyAdd  x0,x2\t<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"ARMv8-异常处理\"><a href=\"#ARMv8-异常处理\" class=\"headerlink\" title=\"ARMv8 异常处理\"></a>ARMv8 异常处理</h2><h3 id=\"异常类型\"><a href=\"#异常类型\" class=\"headerlink\" title=\"异常类型\"></a>异常类型</h3><ol>\n<li>SError //系统错误           //最常见的是异步数据中止（例如，由于脏数据从缓存行写回外部存储器而触发中止） </li>\n<li>FIQ  //快速中断     //group 0 or secure interrupts </li>\n<li>IRQ  //正常优先级中断       //group 1 (normal) interrupts </li>\n<li>同步异常 //是由于指令流的执行或尝试执行而产生的，并且返回地址提供了导致它的指令的详细信息，         //如未定义指令，从内存读取数据异常</li>\n</ol>\n<h3 id=\"异常向量表\"><a href=\"#异常向量表\" class=\"headerlink\" title=\"异常向量表\"></a>异常向量表</h3><p><img src=\"ARMV8%E2%80%94-64bit-%E6%B1%87%E7%BC%96.assets/image-20220406095202475.png\" alt=\"image-20220406095202475\"></p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">adr\tx0, vectors    &#x2F;&#x2F;读取异常向量表的首地址\t\nmsr     vbar_el1,x0    &#x2F;&#x2F;设置异常表的基地址\nsvc     #2             &#x2F;&#x2F;系统调用(触发同步异常陷入， sp_el不同  陷入  不同异常) 具体怎么对应的，不太清楚<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"异常向量表的设置与跳转\"><a href=\"#异常向量表的设置与跳转\" class=\"headerlink\" title=\"异常向量表的设置与跳转\"></a>异常向量表的设置与跳转</h2><p>现在V8的异常向量表没有放在起始地址，所以我们需要多一步设置，异常向量表的起始地址，异常类型，每个异常类型里面有4种异常 ，每个异常32条指令        16* *32 *4=2048 </p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">.globl\t_start\n_start:\n    mrs   x1,SPSel\n    mrs   x2,CurrentEL\n    mov   x0,#0\n    msr   SPSel,x0\n    mov   x0, #0x5\n    adr   x0,vectors\n    msr   vbar_el1,x0\n    svc   #0x02  &#x2F;&#x2F;系统调用 ，\nreset_end:\n    b  reset_end\n\ndo_bad_sync:\n   mov   x2,#1\n   b    reset_end\n\ndo_bad_irq:\n   mov   x2,#2\n   b    reset_end\n\n\t.align\t11  &#x2F;&#x2F;2^11&#x3D;2048  整个异常向量表 2K对齐  -&gt; 通过对齐，实现向量表空间的预留\n\t            &#x2F;&#x2F;16个异常 ，每个异常32条指令    16*32*4&#x3D;2048 \n                &#x2F;&#x2F;16个异常，这里使用前8个\nvectors:\n    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;sp0&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    &#x2F;&#x2F;---同步异常\n    .align  7  &#x2F;&#x2F;2^7     1000 0000 &#x3D;0x80   字节对齐  \n    mov  x0,#1\n    b    do_bad_sync\n    &#x2F;&#x2F;---irq异常\n    .align  7  &#x2F;&#x2F;2^7     1000 0000 &#x3D;0x80\n    mov  x0,#1\n    b    do_bad_irq\n    &#x2F;&#x2F;---fiq异常\n    .align  7  \n    mov  x0,#1\n    b    reset_end\n    &#x2F;&#x2F;---SError异常\n    .align  7  \n    mov  x0,#1\n    b    reset_end\n    &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;sp_elx&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n    &#x2F;&#x2F;---同步异常\n    .align  7  &#x2F;&#x2F;2^7     1000 0000 &#x3D;0x80   字节对齐\n    mov  x0,#1\n    b    do_bad_sync\n    &#x2F;&#x2F;---irq异常\n    .align  7  &#x2F;&#x2F;2^7     1000 0000 &#x3D;0x80\n    mov  x0,#1\n    b    do_bad_irq\n    &#x2F;&#x2F;---fiq异常\n    .align  7  \n    mov  x0,#1\n    b    reset_end\n    &#x2F;&#x2F;---SError异常\n    .align  7  \n    mov  x0,#1\n    b    reset_end\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","feature":false,"text":"指令集手册 https://developer.arm.com/documentation/ddi0596/2021-09/Base-Instructions ARMV8发明的原因： 三大动因 //应对大内存 虚拟化和安全的需求 //大内存(Large Memory): 突破32...","link":"","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[{"name":"ARM开发","slug":"ARM开发","count":2,"path":"api/categories/ARM开发.json"}],"tags":[{"name":"记录","slug":"记录","count":3,"path":"api/tags/记录.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ARMV8%E5%8F%91%E6%98%8E%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A\"><span class=\"toc-text\">ARMV8发明的原因：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%A0%B8%E5%A4%84%E7%90%86%E5%99%A8Z\"><span class=\"toc-text\">多核处理器Z</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83MMU\"><span class=\"toc-text\">内存管理单元MMU</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ARMv8%E5%AF%84%E5%AD%98%E5%99%A8%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">ARMv8寄存器框架</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#31%E4%B8%AA%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">31个通用寄存器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%B9%E6%AE%8A%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">特殊寄存器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%B3%BB%E7%BB%9F%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">系统寄存器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%91%E5%89%8D%E5%85%BC%E5%AE%B9\"><span class=\"toc-text\">向前兼容</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ARMV8%E5%BC%82%E5%B8%B8%E7%BA%A7%E5%88%AB\"><span class=\"toc-text\">ARMV8异常级别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-%E7%94%A8qemu-gdb-vscode-%E3%80%8B%E5%AE%9E%E7%8E%B0%E7%89%B9%E6%9D%83%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">环境搭建: 用qemu+ gdb + vscode -》实现特权寄存器的访问</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#qemu%EF%BC%9A\"><span class=\"toc-text\">qemu：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ssh%E7%99%BB%E5%BD%95%E5%90%8E-gdb%E8%B0%83%E8%AF%95-c-c-%E7%A8%8B%E5%BA%8F%EF%BC%9A\"><span class=\"toc-text\">ssh登录后 gdb调试 c&#x2F;c++程序：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B%EF%BC%9A\"><span class=\"toc-text\">创建工程：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%AE%89%E8%A3%85qemu\"><span class=\"toc-text\">直接安装qemu</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91qemu\"><span class=\"toc-text\">源码编译qemu</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%AE%80%E5%8D%95\"><span class=\"toc-text\">最简单</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#start-s\"><span class=\"toc-text\">start.s</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#makefile\"><span class=\"toc-text\">makefile</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ARMv8-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">ARMv8 汇编指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%8B-%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">例: 延时函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%8F%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">宏函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ARMv8-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">ARMv8 异常处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">异常类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%E8%A1%A8\"><span class=\"toc-text\">异常向量表</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%E8%A1%A8%E7%9A%84%E8%AE%BE%E7%BD%AE%E4%B8%8E%E8%B7%B3%E8%BD%AC\"><span class=\"toc-text\">异常向量表的设置与跳转</span></a></li></ol>","author":{"name":"祥瑞","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/04/08/L9tIA0.jpg","link":"/","description":"励志成为野生钢铁侠-稚晖君的小弟 <br /> @ <b>B站：电工渣</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"硬件控制-arm-linux","uid":"a66f27aecf2233b9864ca3ce3962950b","slug":"硬件控制-arm-linux","date":"2022-04-09T03:53:52.000Z","updated":"2022-04-09T15:18:58.748Z","comments":true,"path":"api/articles/硬件控制-arm-linux.json","keywords":null,"cover":"https://s1.ax1x.com/2022/04/09/Li1OZq.jpg","text":"环境搭建实现链路 嵌入式交叉编译开发环境 uart串口调试 jtag口 //隐藏在金手指核心板的背部，未引出到扩展板的管脚上，不好调试 uart调试口 //在SD卡底部，横着一排(2G板子时在摄像头 排线的旁边) ​ //GND: usb转串口的黑线接板子的 TXD: 接白线 R...","link":"","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"arm_linux","slug":"arm-linux","count":1,"path":"api/tags/arm-linux.json"}],"author":{"name":"祥瑞","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/04/08/L9tIA0.jpg","link":"/","description":"励志成为野生钢铁侠-稚晖君的小弟 <br /> @ <b>B站：电工渣</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"汇编初级-arm","uid":"03ecb7b485f5674611d4371bbdb21945","slug":"汇编指令初级-arm","date":"2022-03-02T22:49:40.000Z","updated":"2022-04-09T09:47:28.255Z","comments":true,"path":"api/articles/汇编指令初级-arm.json","keywords":null,"cover":"https://s1.ax1x.com/2022/04/09/LiQyFO.jpg","text":"ARMv7-A (32bit)源头ARM Cortex-A 系列 ARMv7-A 程序员指南 // https://developer.arm.com/documentation/den0013/d Armv7 和更早的 Arm 架构参考指南的指令集汇编指南 //https://...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[{"name":"ARM开发","slug":"ARM开发","count":2,"path":"api/categories/ARM开发.json"}],"tags":[{"name":"笔记","slug":"笔记","count":1,"path":"api/tags/笔记.json"}],"author":{"name":"祥瑞","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/04/08/L9tIA0.jpg","link":"/","description":"励志成为野生钢铁侠-稚晖君的小弟 <br /> @ <b>B站：电工渣</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}