{"title":"汇编初级-arm","uid":"03ecb7b485f5674611d4371bbdb21945","slug":"汇编指令初级-arm","date":"2022-03-02T22:49:40.000Z","updated":"2022-04-09T09:47:28.255Z","comments":true,"path":"api/articles/汇编指令初级-arm.json","keywords":null,"cover":"https://s1.ax1x.com/2022/04/09/LiQyFO.jpg","content":"<h1 id=\"ARMv7-A-32bit\"><a href=\"#ARMv7-A-32bit\" class=\"headerlink\" title=\"ARMv7-A (32bit)\"></a>ARMv7-A (32bit)</h1><h1 id=\"源头\"><a href=\"#源头\" class=\"headerlink\" title=\"源头\"></a>源头</h1><p>ARM Cortex-A 系列 ARMv7-A 程序员指南  // <a href=\"https://developer.arm.com/documentation/den0013/d\">https://developer.arm.com/documentation/den0013/d</a>    </p>\n<p> Armv7 和更早的 Arm 架构参考指南的指令集汇编指南 //<a href=\"https://developer.arm.com/documentation/100076/0200/a32-t32-instruction-set-reference/a32-and-t32-instructions\">https://developer.arm.com/documentation/100076/0200/a32-t32-instruction-set-reference/a32-and-t32-instructions</a>     </p>\n<p>基本汇编语言程序设计  //<a href=\"https://developer.arm.com/documentation/dui0040/d/Basic-Assembly-Language-Programming\">https://developer.arm.com/documentation/dui0040/d/Basic-Assembly-Language-Programming</a>     </p>\n<h1 id=\"ARM工作模式以及寄存器框图\"><a href=\"#ARM工作模式以及寄存器框图\" class=\"headerlink\" title=\"ARM工作模式以及寄存器框图\"></a>ARM工作模式以及寄存器框图</h1><p><img src=\"https://s4.ax1x.com/2022/03/01/bMXPDe.png\" alt=\"bMXPDe.png\"></p>\n<p>三角形代表这个模式下独有的寄存器。</p>\n<p>其他模式相对与User模式，r13和r14都发生了变化，原因是：    User模式下的r13和r14是SP寄存器和LR寄存器，而SP堆栈与函数调用等挂钩，最好不要用，但还是可以用，而r14连接寄存器，它和语句执行有关，一般不去主动使用它，所以其他模式相对与User模式，r13和r14都发生了变化。</p>\n<p>FIQ特有的寄存器比较多，r8_fiq到r14_fiq，原因是：    可以空间换时间</p>\n<p>例如User模式下，寄存器有值，然后中断触发，CPU切换到FIQ模式，保持User模式下的寄存器的值到FIQ模式下的特有的寄存器（r8_fiq到r14_fiq），这样当其他模式下，就可以使用r0到r12等寄存器，而当中断执行完后，r8_fiq到r14_fiq等寄存器可以返回到r0到r12等寄存器中。</p>\n<p>话说使空间换时间，是那cpu里面的寄存器空间换了什么时间哦？换了时间就是说速度变快了，也就是说还有一种方法，只是时间比较慢，哪种方法是什么哦？</p>\n<p>问：FIQ模式特有的寄存器(r8_fiq到r14_fiq)是切换到其他模式时用来保存当前寄存器（r0到r12）下的值，而设计的哈？这种模式可以空间换时间，空间是寄存器多了，换了时间就是说速度变快了，也就是说还有一种方法，只是时间比较慢，这另外一种方法就是只把通用寄存器的值写入内存单元（应该是内存哈）里面，然后中断完成后，再从内存里面取出来，这种就速度比较慢哦。</p>\n<p>简化一下就是说：<strong>FIQ模式特有的寄存器设计出来是为了加快速度，如果没有设计这玩意，我猜在切换cpu模式时，当前寄存器的值就要写入内存单元里面，然后模式切换回来后，再把值从内存移动到寄存器里面，这种方式就要比寄存器到寄存器要慢哦，所以是空间换时间哦？</strong></p>\n<p>答：是的</p>\n<p><img src=\"https://s4.ax1x.com/2022/03/01/bMXe8P.png\" alt=\"bMXe8P.png\"></p>\n<p><img src=\"https://s1.ax1x.com/2022/03/07/brLVtH.png\" alt=\"brLVtH.png\"></p>\n<h3 id=\"CPSR寄存器\"><a href=\"#CPSR寄存器\" class=\"headerlink\" title=\"CPSR寄存器\"></a>CPSR寄存器</h3><p><img src=\"https://s4.ax1x.com/2022/03/04/bNVGD0.png\" alt=\"bNVGD0.png\"></p>\n<h3 id=\"一个简单的汇编程序\"><a href=\"#一个简单的汇编程序\" class=\"headerlink\" title=\"一个简单的汇编程序\"></a>一个简单的汇编程序</h3><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">\t.text\t\t@代码段的开始\n\tb   main \t@调用 main函数\n\tnop\t\t\t@占位置用的，没有特殊含义\n\tb\tback\n\tnop\n\tnop\n\tnop\n\tnop\nmain: \t\t\t@main函数的内容\n    mov r0,#2\t @对寄存器r0赋值为2，其中的#，可使将源操作数看作立即数，而不是地址\nback:\n\tmov r1,#2\n\t\n\tend:\n\tb\tend\t\t@自己调自己，构成了一个循环，可使程序不会执行到其他位置\n\t\t\n\t.end\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>通过CPSR寄存器切换arm工作模式    中断模式-&gt;user模式-&gt;中断模式</p>\n<p>CPSR寄存器的传送指令和普通寄存器不一样，普通寄存器的是mov，CPSR传入通用寄存器是msr，传出通用寄存器是mrs。</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">\t.text\n\tb   main \n\tnop\t\n\tb\tc_mode\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\nmain: \n    mov r0,#2\n\tmrs r2,cpsr\t\nc_mode:\n\tmsr cpsr,#0x10\t@#代表数字，与其他字符区分，0x10对应处理器模式为是USER中断模式\n@\tmsr cpsr,#0x12   @想使用cpsr寄存器将处理器模式切换为SVC模式，但是编译报错，原因是没有这个权限（supervisor）\n\tswi 3 \t@以中断的方式，进入的SVC模式\n\tend:\n\tb\tend\n\t\t\n\t.end<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p><a href=\"https://imgtu.com/i/bH7PiQ\"><img src=\"https://s1.ax1x.com/2022/03/12/bH7PiQ.png\" alt=\"bH7PiQ.png\"></a></p>\n<p>答：</p>\n<ol>\n<li>USER模式，非特权模式，大部分任务执行在这个模式；</li>\n<li>ARM一共有37个寄存器；</li>\n<li>PC（r15）      LR(r14)；</li>\n<li>r13 (SP)          他们是三个特殊的寄存器，中文名称是 程序计数器、连接寄存器、堆栈寄存器</li>\n<li>Thumb是16位的，ARM是32位的，前者是后者的压缩，可以省空间。</li>\n<li>低5位</li>\n</ol>\n<h3 id=\"关于Thumb和ARM指令：\"><a href=\"#关于Thumb和ARM指令：\" class=\"headerlink\" title=\"关于Thumb和ARM指令：\"></a>关于Thumb和ARM指令：</h3><p>Thumb指令可以看做是ARM指令压缩形式的子集，是针对代码密度【1】的问题而提出的，它具有16为的代码密度。Thumb不是一个完整的体系结构，不能指望处理程序只执行Thumb指令而不支持ARM指令集。因此，Thumb指令只需要支持通用功能，必要时，可借助完善的ARM指令集，例如：所有异常自动进入ARM状态。</p>\n<h3 id=\"为什么Supervisor模式又被称为SVC模\"><a href=\"#为什么Supervisor模式又被称为SVC模\" class=\"headerlink\" title=\"为什么Supervisor模式又被称为SVC模\"></a>为什么Supervisor模式又被称为SVC模</h3><p>ARM SVC（Supervisor Calls）</p>\n<p><a href=\"https://imgtu.com/i/bHqpdK\"><img src=\"https://s1.ax1x.com/2022/03/12/bHqpdK.png\" alt=\"bHqpdK.png\"></a></p>\n<p>PC的值，是程序准备执行（下一条）的指令的地址</p>\n<h1 id=\"汇编初级指令\"><a href=\"#汇编初级指令\" class=\"headerlink\" title=\"汇编初级指令\"></a>汇编初级指令</h1><h2 id=\"搬移指令（传送指令）\"><a href=\"#搬移指令（传送指令）\" class=\"headerlink\" title=\"搬移指令（传送指令）\"></a>搬移指令（传送指令）</h2><table>\n<thead>\n<tr>\n<th>不报错</th>\n<th>报错</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>orr r0,#99</td>\n<td>orr r0,#999</td>\n</tr>\n<tr>\n<td>orr r0,#0xba</td>\n<td>orr r0,#0x1ba</td>\n</tr>\n</tbody></table>\n<p>感觉只要超过2位（不管什么进制），好像都会报错。</p>\n<p>报错信息为：“start.s(20): error: invalid constant (1ba) after fixup“ 无效产量</p>\n<p>规定立即数不能超过两位，咱也不知道为啥。</p>\n<p>LSL逻辑左移    LSR逻辑右移</p>\n<h4 id=\"指令是如何存储、解析的？\"><a href=\"#指令是如何存储、解析的？\" class=\"headerlink\" title=\"指令是如何存储、解析的？\"></a>指令是如何存储、解析的？</h4><p>机器码会存储在FLASH中，通过总线和cpu（寄存器，运算单元，控制器），再到内存。</p>\n<h4 id=\"指令的机器码\"><a href=\"#指令的机器码\" class=\"headerlink\" title=\"指令的机器码\"></a>指令的机器码</h4><p>32位机一条指令是32位（二进制）</p>\n<p>（所以就是这可能就是立即数不能太大的原因哦？）（这也说明了为什么两条相邻的语句内存地址相差了4，因为4*8=32，8bit代表一个字节）</p>\n<table>\n<thead>\n<tr>\n<th>机器码</th>\n<th>指令</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0x01A03001</td>\n<td>moveq r3,r1</td>\n</tr>\n<tr>\n<td>0xE1A03001</td>\n<td>mov r3,r1</td>\n</tr>\n<tr>\n<td>0xE0832001</td>\n<td>add r2,r3,r1</td>\n</tr>\n</tbody></table>\n<p>24位到21位是    操作数    例如    moveq就是“1101”</p>\n<p><a href=\"https://imgtu.com/i/bLP7B8\"><img src=\"https://s1.ax1x.com/2022/03/13/bLP7B8.png\" alt=\"bLP7B8.png\"></a></p>\n<h2 id=\"伪指令-ldr\"><a href=\"#伪指令-ldr\" class=\"headerlink\" title=\"伪指令    ldr\"></a>伪指令    ldr</h2><p>ldr r4,0x3FFFF</p>\n<p>可以将比较大的立即数转移到寄存器中</p>\n<h2 id=\"跳转指令\"><a href=\"#跳转指令\" class=\"headerlink\" title=\"跳转指令\"></a>跳转指令</h2><p>b指令，值得注意的是跳转指令和函数位置，必须在+-32M内部。</p>\n<p>具体原因是：adhsuafahf</p>\n<p>b    3main    跳转到标号为main地代码出（只能短跳转32M）</p>\n<p>bl    func    跳转函数func，并保存下一条要执行的指令位置到l寄存器，当跳转代码结束后，用mov pc,lr</p>\n<p>beq    addr    相等时，跳转到地址addr处，相等（指CPSR寄存器中的Z条件码置位时，即为“1”时）</p>\n<p>bne    addr    不相等时</p>\n<h4 id=\"用汇编-实现C语言功能\"><a href=\"#用汇编-实现C语言功能\" class=\"headerlink\" title=\"用汇编 实现C语言功能\"></a>用汇编 实现C语言功能</h4><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">int</span> ret<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    ret<span class=\"token operator\">=</span><span class=\"token function\">func1</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   \n    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\t\n<span class=\"token punctuation\">&#125;</span>\t\n<span class=\"token keyword\">int</span>  <span class=\"token function\">func1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">==</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">func2</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">func3</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">int</span>  <span class=\"token function\">func2</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span> \n<span class=\"token punctuation\">&#123;</span>    \n    <span class=\"token keyword\">return</span> a<span class=\"token operator\">+</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span> \n<span class=\"token keyword\">int</span> <span class=\"token function\">func3</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>    \n    <span class=\"token keyword\">return</span> a<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span> <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">\t.text\n\tb   main \n\tnop\t\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\nmain: \n\tmov r0,#0\t@r0~ret\t\n\tmov r1,#2\t@r1~a\n\tbl func1\n\t\nend_main:\n\tb\tend_main\n\t\nfunc1:\n\t\tmov r12,lr\n\t\tcmp r1,#2\t\n\t\tbleq func2\n\t\tblne func3\nend_func1:\n\t\tmov pc,r12\n\nfunc2:\n\tadd r1,#3\nend_func2:\n\tmov pc,lr\n\t\nfunc3:\n\tsub r1,#1\nend_func3:\n\tmov\tpc,lr\n\t\n\t.end\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"逻辑指令\"><a href=\"#逻辑指令\" class=\"headerlink\" title=\"逻辑指令\"></a>逻辑指令</h2><p>and    r0,r1,r2    r1和r2相与，然后把结果放入r0</p>\n<p>orr    类似</p>\n<p>bic    r0,r0,#0x0B    清除r0中的位 0、1、和 3   </p>\n<p>tst    r0,#0x20       测试第6位是否为0 ，为0则Z标志置1  </p>\n<p>cmp    r1,r0          将寄存器R1的值与寄存器R0的值相减，                      并根据结果设置CPSR的标志位</p>\n<h4 id=\"1-判断当前工作状态是否是ARM状态，是则切换到user-工作模式？\"><a href=\"#1-判断当前工作状态是否是ARM状态，是则切换到user-工作模式？\" class=\"headerlink\" title=\"1.判断当前工作状态是否是ARM状态，是则切换到user 工作模式？\"></a>1.判断当前工作状态是否是ARM状态，是则切换到user 工作模式？</h4><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">\t.text\n\tb   main \n\tnop\t\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\nmain: \n\tmrs\tr0,cpsr\n\ttst r0,#0x6\n\tmoveq r6,#0xAA\n\t\n\tbic\tr0,#0x3\n\tmsr\tcpsr,r0\n\t\n\tmrs\tr0,cpsr\n\ttst r0,#0x6\n\tmoveq r6,#0xAA\n\t\nend_main:\n\tb\tend_main\n\t\t\n\t.end\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h4 id=\"2-使能中断和快速中断？\"><a href=\"#2-使能中断和快速中断？\" class=\"headerlink\" title=\"2.使能中断和快速中断？\"></a>2.使能中断和快速中断？</h4><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">mrs\tr0,cpsr\nbic\tr0,#0xc0\t@1100 0000\nmsr\tcpsr,ro<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h2 id=\"算术指令\"><a href=\"#算术指令\" class=\"headerlink\" title=\"算术指令\"></a>算术指令</h2><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">add     r0,r1,r2       默认是不影响CPSR的标志位的\nadd     r0,#1\n\nsub     r0,r1,#3      类似  r0&#x3D; r1 - 3\nsub     r0,#1\n\nsub     r0,r1,r2,LSL#1    @先把r2里面的值，算术左移1位后，和r1相减，然后放入r0<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>例如</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">mov\tr0,#0x11\t@0001 0001\t-&gt;\t0010 0010\nmov r1,#0x22\t\nadd r2,r1,r0,lsl#0x1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n\n\n\n\n<h1 id=\"汇编指令高级\"><a href=\"#汇编指令高级\" class=\"headerlink\" title=\"汇编指令高级\"></a>汇编指令高级</h1><h3 id=\"Load-Store架构\"><a href=\"#Load-Store架构\" class=\"headerlink\" title=\"Load/Store架构\"></a>Load/Store架构</h3><p><a href=\"https://imgtu.com/i/bXhNCQ\"><img src=\"https://s1.ax1x.com/2022/03/14/bXhNCQ.png\" alt=\"bXhNCQ.png\"></a></p>\n<p>ldr（ld代表load，r代表寄存器）    是将存储器里面的数据载入寄存器</p>\n<p>str（st代表存储器，r代表寄存器）是将寄存器里面的值写入到存储器中</p>\n<h4 id=\"最简示例\"><a href=\"#最简示例\" class=\"headerlink\" title=\"最简示例\"></a>最简示例</h4><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">\t.text\n\tb   main \n\tnop\t\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\nmain: \n\tldr r0,&#x3D;buf\t\t\t@保存源存储器的地址\n\tldr r1,&#x3D;destBuf\t\t@保存目的存储器的地址\n\tldr r3,[r0]\t\t\t@将源存储器的数载入到寄存器\n\tstr r3,[r1]\t\t\t@将寄存器里面的数写入到存储器\nend_main:\n\tb\tend_main\n\t\n\t.data\nbuf:\n\t.byte 0x00,0xAA,0xBB,0xcc\n\t\t\t\t\t\t@定义了4个字节的数据，分别是这些\ndestBuf:\t\n\t.space 4\t\t\t@分配了4个字节的空间\n\t\n\t.end<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>就是先把目的和源的地址确定，然后把源存储器中的数据传入到寄存器，然后把寄存器的数据写入到存储器中。这样就实现了数据的转移。</p>\n<p>ldr r9，_irq    表示将_irq的机器码放入目的寄存器            （irq代表标号）</p>\n<p>ldr r9,=irq    表示伪指令，会将irq的地址传入目的寄存器</p>\n<p>例如：</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">\t.text\n\tb   main \n\tnop\t\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\nmain: \n\tldr r0,end_main\t\t\t\n\tldr r1,&#x3D;end_main\t\t\n\nend_main:\n\tb\tend_main\n\t\n\t.data\nbuf:\n\t.byte 0x00,0xAA,0xBB,0xcc\ndestBuf:\t\n\t.space 4\t\t\t@分配了4个字节的空间\n\t\n\t.end\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"前后索引\"><a href=\"#前后索引\" class=\"headerlink\" title=\"前后索引\"></a>前后索引</h4><p>前索引是        ldr    r0,[r1,#8]    先加地址，后放入值</p>\n<p>后索引是        ldr    r0,[r1],#8    先放入值，在加地址</p>\n<p>概念是会了，当时老师所说的应用情况还是不太清楚。</p>\n<h4 id=\"load-store实现数据拷贝\"><a href=\"#load-store实现数据拷贝\" class=\"headerlink\" title=\"load_store实现数据拷贝\"></a>load_store实现数据拷贝</h4><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\"><span class=\"token comment\">//用汇编实现C内容</span>\n<span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">const</span>  <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">=</span><span class=\"token punctuation\">&#123;</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">char</span> destBuf<span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">&#123;</span>\n\t\tdestBuf<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> buf<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">\t.text\n\tb   main \n\tnop\t\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\nmain: \n\tmov\tr0,#0\t@r0~i\n\tldr\tr1,&#x3D;buf\n\tldr\tr2,&#x3D;destbuf\n\t\nloop:\n\tcmp\tr0,#7\n\tbeq end_main\n\tldrb r3,[r1],#1\n\tstrb r3,[r2],#1\n\tadd r0,#1\n\t\n\tb\tloop\n\nend_main:\n\tb\tend_main\nbuf:\n\t.byte 5,2,0,1,3,1,4\t\t\t@使用byte的原因是char类型的元素，大小为一个字节，值得一提的是这里的strb指令只能操作1个字\t\t\t\t\t\t\t\t   @节，strb，或者2个字节，strh，或者4个字节str。\n\t\n\t.data\ndestbuf:\n\t.space 8\n\t\n\t.end\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"GNU汇编伪指令\"><a href=\"#GNU汇编伪指令\" class=\"headerlink\" title=\"GNU汇编伪指令\"></a>GNU汇编伪指令</h3><p>设计目的，汇编语言将帮助我们去实现一些功能，帮助我们理解。</p>\n<p>相当于调用了系统的汇编函数，虽然看起来就只有一句指令，但实际上使用了多条语句。</p>\n<p>看起来是一条指令，但编译成机器码后，可能会有多条机器码。</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">.section\t\t\t\t\t\t\t&#x2F;&#x2F;定义内存段\n.text\t\t\t\t\t\t\t\t&#x2F;&#x2F;定义符开始的代码编译到代码段\t\t\n.data\t\t\t\t\t\t\t\t&#x2F;&#x2F;数据段\n.if\t.else .endif\t\t\t\t\t &#x2F;&#x2F;条件编译\n.end \t\t\t\t\t\t\t\t&#x2F;&#x2F;文件结束\n.byte\t0x11,&#39;a&#39;,0\t\t\t\t\t &#x2F;&#x2F;定义char类型的数组（.byte 就是一个字节）\n.word\t0x12,0x121\t\t\t\t\t &#x2F;&#x2F;定义int类型的数组（.word 是4个字节）\n.quad\t0x3FA0\t\t\t\t\t\t&#x2F;&#x2F;定义8字节的空间（.quad 代表8个字节）\n.string\t&quot;DASDAS\\0&quot;\t\t\t\t\t &#x2F;&#x2F;定义字符串\n.align 4\t\t\t\t\t\t\t&#x2F;&#x2F;4&#x3D;2^2\t字节对齐\n\nldr\tr0,&#x3D;0xE00221\t\t\t\t\t &#x2F;&#x2F;载入最大常数到寄存器中，如果是一般的汇编代码，一条指令对应一条机器码，而一条机器码是不能存放很大的数据的。\n.equ\tGPGASD,0X1212\t\t\t\t &#x2F;&#x2F;定义宏\n.global\t_start\t\t\t\t\t\t&#x2F;&#x2F;声名_start为全局符号<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"批量操作指令\"><a href=\"#批量操作指令\" class=\"headerlink\" title=\"批量操作指令\"></a>批量操作指令</h4><p>之前做过，数据转移的操作，但是之前那个只是把存储器里面的数据只能放在一个寄存器里面，需要反复使用一个寄存器，不太方便，而这个指令可以同时使用多个寄存器批量操作。</p>\n<h4 id=\"堆栈操作指令\"><a href=\"#堆栈操作指令\" class=\"headerlink\" title=\"堆栈操作指令\"></a>堆栈操作指令</h4><p>stmfd    sp!,{r0-r12,lr}</p>\n<p>ldmfd    sp!,{r0-r12,pc}^</p>\n<h4 id=\"软中断指令\"><a href=\"#软中断指令\" class=\"headerlink\" title=\"软中断指令\"></a>软中断指令</h4><p><img src=\"E:\\Blog\\source_posts\\image-20220319211106285.png\" alt=\"image-20220319211106285\"></p>\n<p>swi 0x22</p>\n<p>产生软中断，调用操作系统编号为02的系统例程</p>\n<p>异常向量表用的地址是从0开始的一段</p>\n<h1 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h1><h2 id=\"异常向量表\"><a href=\"#异常向量表\" class=\"headerlink\" title=\"异常向量表\"></a>异常向量表</h2><p><a href=\"https://imgtu.com/i/qEKAKO\"><img src=\"https://s1.ax1x.com/2022/03/19/qEKAKO.png\" alt=\"qEKAKO.png\"></a></p>\n<p>如果要切换到，USER System模式下，是通过CPSR寄存器修改而边的。</p>\n<h5 id=\"异常向量表和ARM处理器的工作模式是对应的\"><a href=\"#异常向量表和ARM处理器的工作模式是对应的\" class=\"headerlink\" title=\"异常向量表和ARM处理器的工作模式是对应的\"></a>异常向量表和ARM处理器的工作模式是对应的</h5><p>进入那一个异常，就会进入这种工作模式。</p>\n<h2 id=\"软中断最简\"><a href=\"#软中断最简\" class=\"headerlink\" title=\"软中断最简\"></a>软中断最简</h2><pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">\t.text\t\t\t\t\t\t\t\t\t@定义代码段\n\tb   main  \t@0x00 reset\n\tnop       \t@0x04 undef         \n\tb hander_swi\t@0x08 soft irq\n\tnop       \t@0x0c prefecth abort\n\tnop\t      \t@0x10 data abort\n\tnop\t\t@0x14 reserved\n\tnop\t\t@0x18 irq\n\tnop\t\t@0x1C fiq\n\t\t\t\t\t\t\t\t\t\t\t@异常向量表\nhander_swi:\n\tstmfd sp!,&#123;r0-r12,lr&#125;\t\t\t\t\t  @栈保存现场，包括了通用寄存器，和lr寄存器（存放了如果没有发生中断时，该执行的代码地址）\n\tldr r0 ,&#x3D;0x520\t\t\t\t\t\t\t @模拟寄存器变化，破坏现场\n\t\nhander_swi_end:\t\t\t\t\t\t\t\t \n\tldmfd sp!,&#123;r0-r12,pc&#125;\t\t\t\t\t @还原现场，包括通用寄存器和pc寄存器（下一页代码执行的地址）\n\t\n\t\nmain: \n\tldr sp,&#x3D;stack_top\t\t\t\t\t\t@给一个地址，作为栈顶\n\tmov r0 , #1\n\tmov r1 , #1\n\tmov r2 , #1\t\t\t\t\t\t\t    @构成现场\n\tswi 0x1;\t\t\t\t\t\t\t   @软中断\n\tmov r3 , #1\t\t\t\t\t\t\t\t\n\t\n\t\nend_main:\n\tb\tend_main\n\t\n\t.data\t\t\t\t\t\t\t\t@代码段\n\t\n\t.space 15*4\nstack_top:\t\t\t\t\t\t\t\t@因为栈是有着栈顶不变，元素线下生长的规定，所以将栈顶放到了高位的地址位\n\t\n\t.end\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"现在的疑问：\"><a href=\"#现在的疑问：\" class=\"headerlink\" title=\"现在的疑问：\"></a>现在的疑问：</h4><p>​    那么同等级的中断，比如我有两个软中断，我该如何设计呢？因为异常向量表只能方一个跳转指令。</p>\n<h4 id=\"猜测：\"><a href=\"#猜测：\" class=\"headerlink\" title=\"猜测：\"></a>猜测：</h4><p>​    SWI  0x1和SWI  0x2，它们有一个标量的不同，所以我猜是，异常向量表中还是只放了一个跳转指令，当时跳转后没有直接执行目标函数，而是先执行通过标号判断是那个标号的中断触发，在去执行中断函数。</p>\n<h2 id=\"软中断完整\"><a href=\"#软中断完整\" class=\"headerlink\" title=\"软中断完整\"></a>软中断完整</h2><p>​    跟我猜想的差不多，实际运行原理是：</p>\n<p>​        中断标号其实是存在，SWI指令编译成的机器码中的，其中中断标号是低24位，所以我们只要找到这个指令的地址，然后用LDR指令将，指令地址上的机器码传入寄存器中,然后再将高8位置0,然后通过cmp，beq指令就可以判断要执行的标号具体哪一个了。</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">\t.text\n\tb   main \n\tnop\t\t\t\n\tnop\t\t\t\n\tb hander_swi\t\t@SWI\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\t\nhander_swi:\n\tstmfd sp!,&#123;r0-r12,lr&#125;\t\n\tldr r0 , [lr,#-4]\t\t\t\t@lr是在执行中断时，将原本不发生中断时，要执行的指令的地址，然后将它减\n\t\t\t\t\t\t\t\t   @4这样就可以得到，软中断指令的地址，再将它的机器码传入寄存器，就可以得\t\t\t\t\t\t\t\t\t   @到，SWI中断标号得信息了\n\tbic r0 ,#0xFF000000\t\t\t\t @将高8位置0，因为swi指令的低24位才是标号的信息，高八位置操作码\n\tcmp r0,#0x1\t\t\t\t\t\t@判断是否为SWI 0x1\n\tbeq swi_1\n\tcmp r0,#0x2\t\t\t\t\t\t@判断是否为SWI 0x2\n\tbeq swi_2\nhander_swi_end:\n\tldmfd sp!,&#123;r0-r12,pc&#125;\n\t\nswi_1:\n\t\tldr r0,&#x3D;0x520\nswi_1_end:\n\tb hander_swi_end\n\t\t\nswi_2:\n\t\tldr r0,&#x3D;0x1314\nswi_2_end:\t\t\n\tb hander_swi_end\n\t\n\t\nmain: \n\tldr sp,&#x3D;stack_top\n\tmov r0 , #1\n\tmov r1 , #1\n\tmov r2 , #1\n\tswi 0x1;\n\tmov r3 , #1\n\tswi 0x2;\n\t\nend_main:\n\tb\tend_main\n\t\n\t.data\n\t\n\t.space 16*4\nstack_top:\n\t\n\t.end\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"contex-a-或者-contex-8的异常中断向量表\"><a href=\"#contex-a-或者-contex-8的异常中断向量表\" class=\"headerlink\" title=\"contex-a 或者 contex-8的异常中断向量表\"></a>contex-a 或者 contex-8的异常中断向量表</h4><p><a href=\"https://imgtu.com/i/qVMDGn\"><img src=\"https://s1.ax1x.com/2022/03/19/qVMDGn.png\" alt=\"qVMDGn.png\"></a></p>\n<p>contex-a 或者 contex-8的异常中断向量表和ARM-7的好不太一样</p>\n<p>1、异常向量表的跳转没有用 “b”指令，而是使用的伪指令的ldr pc,“对应跳转的地址”（或者名称），这样就可以突破32M的范围（32M的原因是？）</p>\n","text":"ARMv7-A (32bit)源头ARM Cortex-A 系列 ARMv7-A 程序员指南 // https://developer.arm.com/documentation/den0013/d Armv7 和更早的 Arm 架构参考指南的指令集汇编指南 //https://...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[{"name":"ARM开发","slug":"ARM开发","count":2,"path":"api/categories/ARM开发.json"}],"tags":[{"name":"笔记","slug":"笔记","count":1,"path":"api/tags/笔记.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ARMv7-A-32bit\"><span class=\"toc-text\">ARMv7-A (32bit)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%BA%90%E5%A4%B4\"><span class=\"toc-text\">源头</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#ARM%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%AF%84%E5%AD%98%E5%99%A8%E6%A1%86%E5%9B%BE\"><span class=\"toc-text\">ARM工作模式以及寄存器框图</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CPSR%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">CPSR寄存器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F\"><span class=\"toc-text\">一个简单的汇编程序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8EThumb%E5%92%8CARM%E6%8C%87%E4%BB%A4%EF%BC%9A\"><span class=\"toc-text\">关于Thumb和ARM指令：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88Supervisor%E6%A8%A1%E5%BC%8F%E5%8F%88%E8%A2%AB%E7%A7%B0%E4%B8%BASVC%E6%A8%A1\"><span class=\"toc-text\">为什么Supervisor模式又被称为SVC模</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B1%87%E7%BC%96%E5%88%9D%E7%BA%A7%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">汇编初级指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%90%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%EF%BC%88%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4%EF%BC%89\"><span class=\"toc-text\">搬移指令（传送指令）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E3%80%81%E8%A7%A3%E6%9E%90%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">指令是如何存储、解析的？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%BA%E5%99%A8%E7%A0%81\"><span class=\"toc-text\">指令的机器码</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%AA%E6%8C%87%E4%BB%A4-ldr\"><span class=\"toc-text\">伪指令    ldr</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">跳转指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%94%A8%E6%B1%87%E7%BC%96-%E5%AE%9E%E7%8E%B0C%E8%AF%AD%E8%A8%80%E5%8A%9F%E8%83%BD\"><span class=\"toc-text\">用汇编 实现C语言功能</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%BB%E8%BE%91%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">逻辑指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81%E6%98%AF%E5%90%A6%E6%98%AFARM%E7%8A%B6%E6%80%81%EF%BC%8C%E6%98%AF%E5%88%99%E5%88%87%E6%8D%A2%E5%88%B0user-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">1.判断当前工作状态是否是ARM状态，是则切换到user 工作模式？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E8%83%BD%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BF%AB%E9%80%9F%E4%B8%AD%E6%96%AD%EF%BC%9F\"><span class=\"toc-text\">2.使能中断和快速中断？</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">算术指令</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E9%AB%98%E7%BA%A7\"><span class=\"toc-text\">汇编指令高级</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Load-Store%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">Load&#x2F;Store架构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%80%E7%AE%80%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">最简示例</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%89%8D%E5%90%8E%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">前后索引</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#load-store%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">load_store实现数据拷贝</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GNU%E6%B1%87%E7%BC%96%E4%BC%AA%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">GNU汇编伪指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">批量操作指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A0%86%E6%A0%88%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">堆栈操作指令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">软中断指令</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">异常处理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%E8%A1%A8\"><span class=\"toc-text\">异常向量表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%E8%A1%A8%E5%92%8CARM%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%98%AF%E5%AF%B9%E5%BA%94%E7%9A%84\"><span class=\"toc-text\">异常向量表和ARM处理器的工作模式是对应的</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%B8%AD%E6%96%AD%E6%9C%80%E7%AE%80\"><span class=\"toc-text\">软中断最简</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%8E%B0%E5%9C%A8%E7%9A%84%E7%96%91%E9%97%AE%EF%BC%9A\"><span class=\"toc-text\">现在的疑问：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%8C%9C%E6%B5%8B%EF%BC%9A\"><span class=\"toc-text\">猜测：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%AE%8C%E6%95%B4\"><span class=\"toc-text\">软中断完整</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#contex-a-%E6%88%96%E8%80%85-contex-8%E7%9A%84%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8\"><span class=\"toc-text\">contex-a 或者 contex-8的异常中断向量表</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"祥瑞","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/04/08/L9tIA0.jpg","link":"/","description":"励志成为野生钢铁侠-稚晖君的小弟 <br /> @ <b>B站：电工渣</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ARMV8_汇编","uid":"1b233e39e81d8746e996add6970c9f45","slug":"ARMV8-汇编","date":"2022-04-08T05:37:48.000Z","updated":"2022-04-09T09:52:59.649Z","comments":true,"path":"api/articles/ARMV8-汇编.json","keywords":null,"cover":"https://s1.ax1x.com/2022/04/09/Li1OZq.jpg","text":"指令集手册 https://developer.arm.com/documentation/ddi0596/2021-09/Base-Instructions ARMV8发明的原因： 三大动因 //应对大内存 虚拟化和安全的需求 //大内存(Large Memory): 突破32...","link":"","photos":[],"count_time":{"symbolsCount":"9.1k","symbolsTime":"8 mins."},"categories":[{"name":"ARM开发","slug":"ARM开发","count":2,"path":"api/categories/ARM开发.json"}],"tags":[{"name":"记录","slug":"记录","count":3,"path":"api/tags/记录.json"}],"author":{"name":"祥瑞","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/04/08/L9tIA0.jpg","link":"/","description":"励志成为野生钢铁侠-稚晖君的小弟 <br /> @ <b>B站：电工渣</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":false},"next_post":{"title":"嵌入式系统设计与应用","uid":"0f8d9761b605a0589f071d0c0d4184a4","slug":"嵌入式系统设计与应用","date":"2022-03-01T02:43:21.000Z","updated":"2022-04-09T09:54:41.883Z","comments":true,"path":"api/articles/嵌入式系统设计与应用.json","keywords":null,"cover":"https://s1.ax1x.com/2022/04/09/LiGlIP.png","text":"前言材料及参考书获取资源 书号是实体书背面的二维码 相关网站www.arm.com www.21ic.com/embed/ www.home.eeworld.com.cn（电子工程世界） bbs.elecfans.com(电子发烧友) 感觉不是很活跃 第一章第一节课嵌入式概念：嵌...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"课程学习","slug":"课程学习","count":6,"path":"api/categories/课程学习.json"}],"tags":[{"name":"linux","slug":"linux","count":3,"path":"api/tags/linux.json"}],"author":{"name":"祥瑞","slug":"blog-author","avatar":"https://s1.ax1x.com/2022/04/08/L9tIA0.jpg","link":"/","description":"励志成为野生钢铁侠-稚晖君的小弟 <br /> @ <b>B站：电工渣</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}